(*Generated by Sail from User.*)
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import SailStdpp.ConcurrencyInterfaceTypesV2.
Require Import SailStdpp.ConcurrencyInterfaceV2.
Require Import SailStdpp.ConcurrencyInterfaceBuiltinsV2.
Require Import User_types.
Import Defs.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition neq_int (x : Z) (y : Z) : bool := negb ((Z.eqb (x) (y))).

Definition neq_bool (x : bool) (y : bool) : bool := negb ((Bool.eqb (x) (y))).

Definition eq_bits_int {n : Z} (x : mword n) (y : Z) (*(n >=? 0) && (y >=? 0)*) : bool :=
   Z.eqb ((uint (x))) (y).

Definition __id (x : Z) : Z := x.

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shl_int (m) (n) else shr_int (m) ((Z.opp (n))).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shr_int (m) (n) else shl_int (m) ((Z.opp (n))).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if andb ((Z.ltb (n) (0))) ((Z.gtb (m) (0))) then Z.sub ((Z.quot ((Z.add (n) (1))) (m))) (1)
   else if andb ((Z.gtb (n) (0))) ((Z.ltb (m) (0))) then Z.sub ((Z.quot ((Z.sub (n) (1))) (m))) (1)
   else Z.quot (n) (m).

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub (n) ((Z.mul (m) ((fdiv_int (n) (m))))).

Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) (*(len >=? 0) && (v0 >=? 0)*) : mword len :=
   if Z.leb (len) v0 then vector_truncate (v) (len) else zero_extend (v) (len).

Definition sail_ones (n : Z) (*n >=? 0*) : mword n := not_vec ((zeros (n))).

Definition slice_mask (n : Z) (i : Z) (l : Z) (*n >=? 0*) : mword n :=
   if Z.geb (l) (n) then shiftl ((sail_ones (n))) (i)
   else
     let one : bits n := sail_mask (n) ((('b"1")  : bits 1)) in
     shiftl ((sub_vec ((shiftl (one) (l))) (one))) (i).

Definition to_bytes_le (n : Z) (b : mword (8 * n)) (*n >? 0*) : vec (mword 8) n :=
   let res := vector_init (n) ((zeros (8))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       vec_update_dec (res) (i)
         ((autocast (T := mword)
           (subrange_vec_dec (b) ((Z.add ((Z.mul (8) (i))) (7))) ((Z.mul (8) (i)))))))).

Definition from_bytes_le (n : Z) (v : vec (mword 8) n) (*n >? 0*) : mword (8 * n) :=
   let res := zeros ((Z.mul (8) (n))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       update_subrange_vec_dec (res) ((Z.add ((Z.mul (8) (i))) (7))) ((Z.mul (8) (i)))
         ((autocast (T := mword)
           (vec_access_dec (v) (i)))))).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.

Definition concat_str_bits {n : Z} (str : string) (x : mword n) : string :=
   String.append (str) ((string_of_bits (x))).

Definition concat_str_dec (str : string) (x : Z) : string := String.append (str) ((dec_str (x))).

Definition undefined_SecurityState '(tt : unit) : M (SecurityState) :=
   (internal_pick ([SS_NonSecure; SS_Root; SS_Realm; SS_Secure]))  : M (SecurityState).

Definition undefined_PARTIDspaceType '(tt : unit) : M (PARTIDspaceType) :=
   (internal_pick ([PIdSpace_Secure; PIdSpace_Root; PIdSpace_Realm; PIdSpace_NonSecure]))
    : M (PARTIDspaceType).

Definition undefined_MPAMinfo '(tt : unit) : M (MPAMinfo) :=
   (undefined_PARTIDspaceType (tt)) >>= fun (w__0 : PARTIDspaceType) =>
   (undefined_bitvector (16)) >>= fun (w__1 : mword 16) =>
   (undefined_bitvector (8)) >>= fun (w__2 : mword 8) =>
   returnM (({| MPAMinfo_mpam_sp := w__0;  MPAMinfo_partid := w__1;  MPAMinfo_pmg := w__2 |})).

Definition undefined_AccessType '(tt : unit) : M (AccessType) :=
   (internal_pick
      ([AccessType_IFETCH;
      AccessType_GPR;
      AccessType_ASIMD;
      AccessType_SVE;
      AccessType_SME;
      AccessType_IC;
      AccessType_DC;
      AccessType_DCZero;
      AccessType_AT;
      AccessType_NV2;
      AccessType_SPE;
      AccessType_GCS;
      AccessType_GPTW;
      AccessType_TTW]))
    : M (AccessType).

Definition undefined_VARange '(tt : unit) : M (VARange) :=
   (internal_pick ([VARange_LOWER; VARange_UPPER]))  : M (VARange).

Definition undefined_MemAtomicOp '(tt : unit) : M (MemAtomicOp) :=
   (internal_pick
      ([MemAtomicOp_GCSSS1;
      MemAtomicOp_ADD;
      MemAtomicOp_BIC;
      MemAtomicOp_EOR;
      MemAtomicOp_ORR;
      MemAtomicOp_SMAX;
      MemAtomicOp_SMIN;
      MemAtomicOp_UMAX;
      MemAtomicOp_UMIN;
      MemAtomicOp_SWP;
      MemAtomicOp_CAS]))
    : M (MemAtomicOp).

Definition undefined_CacheOp '(tt : unit) : M (CacheOp) :=
   (internal_pick ([CacheOp_Clean; CacheOp_Invalidate; CacheOp_CleanInvalidate]))  : M (CacheOp).

Definition undefined_CacheOpScope '(tt : unit) : M (CacheOpScope) :=
   (internal_pick
      ([CacheOpScope_SetWay;
      CacheOpScope_PoU;
      CacheOpScope_PoC;
      CacheOpScope_PoE;
      CacheOpScope_PoP;
      CacheOpScope_PoDP;
      CacheOpScope_PoPA;
      CacheOpScope_ALLU;
      CacheOpScope_ALLUIS]))
    : M (CacheOpScope).

Definition undefined_CacheType '(tt : unit) : M (CacheType) :=
   (internal_pick ([CacheType_Data; CacheType_Tag; CacheType_Data_Tag; CacheType_Instruction]))
    : M (CacheType).

Definition undefined_CachePASpace '(tt : unit) : M (CachePASpace) :=
   (internal_pick
      ([CPAS_NonSecure;
      CPAS_Any;
      CPAS_RealmNonSecure;
      CPAS_Realm;
      CPAS_Root;
      CPAS_SecureNonSecure;
      CPAS_Secure]))
    : M (CachePASpace).

Definition undefined_AccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   (undefined_AccessType (tt)) >>= fun (w__0 : AccessType) =>
   (undefined_bitvector (2)) >>= fun (w__1 : mword 2) =>
   (undefined_SecurityState (tt)) >>= fun (w__2 : SecurityState) =>
   (undefined_bool (tt)) >>= fun (w__3 : bool) =>
   (undefined_bool (tt)) >>= fun (w__4 : bool) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bool (tt)) >>= fun (w__7 : bool) =>
   (undefined_bool (tt)) >>= fun (w__8 : bool) =>
   (undefined_MemAtomicOp (tt)) >>= fun (w__9 : MemAtomicOp) =>
   (undefined_bool (tt)) >>= fun (w__10 : bool) =>
   (undefined_bool (tt)) >>= fun (w__11 : bool) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_CacheOp (tt)) >>= fun (w__13 : CacheOp) =>
   (undefined_CacheOpScope (tt)) >>= fun (w__14 : CacheOpScope) =>
   (undefined_CacheType (tt)) >>= fun (w__15 : CacheType) =>
   (undefined_bool (tt)) >>= fun (w__16 : bool) =>
   (undefined_bool (tt)) >>= fun (w__17 : bool) =>
   (undefined_bool (tt)) >>= fun (w__18 : bool) =>
   (undefined_bool (tt)) >>= fun (w__19 : bool) =>
   (undefined_bool (tt)) >>= fun (w__20 : bool) =>
   (undefined_bool (tt)) >>= fun (w__21 : bool) =>
   (undefined_bool (tt)) >>= fun (w__22 : bool) =>
   (undefined_bool (tt)) >>= fun (w__23 : bool) =>
   (undefined_bool (tt)) >>= fun (w__24 : bool) =>
   (undefined_bool (tt)) >>= fun (w__25 : bool) =>
   (undefined_bool (tt)) >>= fun (w__26 : bool) =>
   (undefined_bool (tt)) >>= fun (w__27 : bool) =>
   (undefined_VARange (tt)) >>= fun (w__28 : VARange) =>
   (undefined_bool (tt)) >>= fun (w__29 : bool) =>
   (undefined_bool (tt)) >>= fun (w__30 : bool) =>
   (undefined_bool (tt)) >>= fun (w__31 : bool) =>
   (undefined_MPAMinfo (tt)) >>= fun (w__32 : MPAMinfo) =>
   returnM (({| AccessDescriptor_acctype := w__0;
                AccessDescriptor_el := w__1;
                AccessDescriptor_ss := w__2;
                AccessDescriptor_acqsc := w__3;
                AccessDescriptor_acqpc := w__4;
                AccessDescriptor_relsc := w__5;
                AccessDescriptor_limitedordered := w__6;
                AccessDescriptor_exclusive := w__7;
                AccessDescriptor_atomicop := w__8;
                AccessDescriptor_modop := w__9;
                AccessDescriptor_nontemporal := w__10;
                AccessDescriptor_read := w__11;
                AccessDescriptor_write := w__12;
                AccessDescriptor_cacheop := w__13;
                AccessDescriptor_opscope := w__14;
                AccessDescriptor_cachetype := w__15;
                AccessDescriptor_pan := w__16;
                AccessDescriptor_transactional := w__17;
                AccessDescriptor_nonfault := w__18;
                AccessDescriptor_firstfault := w__19;
                AccessDescriptor_first := w__20;
                AccessDescriptor_contiguous := w__21;
                AccessDescriptor_streamingsve := w__22;
                AccessDescriptor_ls64 := w__23;
                AccessDescriptor_mops := w__24;
                AccessDescriptor_rcw := w__25;
                AccessDescriptor_rcws := w__26;
                AccessDescriptor_toplevel := w__27;
                AccessDescriptor_varange := w__28;
                AccessDescriptor_a32lsmd := w__29;
                AccessDescriptor_tagchecked := w__30;
                AccessDescriptor_tagaccess := w__31;
                AccessDescriptor_mpam := w__32 |})).

Definition undefined_MemType '(tt : unit) : M (MemType) :=
   (internal_pick ([MemType_Normal; MemType_Device]))  : M (MemType).

Definition undefined_DeviceType '(tt : unit) : M (DeviceType) :=
   (internal_pick ([DeviceType_GRE; DeviceType_nGRE; DeviceType_nGnRE; DeviceType_nGnRnE]))
    : M (DeviceType).

Definition undefined_MemAttrHints '(tt : unit) : M (MemAttrHints) :=
   (undefined_bitvector (2)) >>= fun (w__0 : mword 2) =>
   (undefined_bitvector (2)) >>= fun (w__1 : mword 2) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   returnM (({| MemAttrHints_attrs := w__0;
                MemAttrHints_hints := w__1;
                MemAttrHints_transient := w__2 |})).

Definition undefined_Shareability '(tt : unit) : M (Shareability) :=
   (internal_pick ([Shareability_NSH; Shareability_ISH; Shareability_OSH]))  : M (Shareability).

Definition undefined_MemoryOrdering '(tt : unit) : M (MemoryOrdering) :=
   (internal_pick ([Ordering_Relaxed; Ordering_Acquire; Ordering_AcquireRCpc; Ordering_Release]))
    : M (MemoryOrdering).

Definition undefined_MemTagType '(tt : unit) : M (MemTagType) :=
   (internal_pick ([MemTag_Untagged; MemTag_AllocationTagged; MemTag_CanonicallyTagged]))
    : M (MemTagType).

Definition undefined_MemoryAttributes '(tt : unit) : M (MemoryAttributes) :=
   (undefined_MemType (tt)) >>= fun (w__0 : MemType) =>
   (undefined_DeviceType (tt)) >>= fun (w__1 : DeviceType) =>
   (undefined_MemAttrHints (tt)) >>= fun (w__2 : MemAttrHints) =>
   (undefined_MemAttrHints (tt)) >>= fun (w__3 : MemAttrHints) =>
   (undefined_Shareability (tt)) >>= fun (w__4 : Shareability) =>
   (undefined_MemTagType (tt)) >>= fun (w__5 : MemTagType) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bitvector (1)) >>= fun (w__7 : mword 1) =>
   returnM (({| MemoryAttributes_memtype := w__0;
                MemoryAttributes_device := w__1;
                MemoryAttributes_inner := w__2;
                MemoryAttributes_outer := w__3;
                MemoryAttributes_shareability := w__4;
                MemoryAttributes_tags := w__5;
                MemoryAttributes_notagaccess := w__6;
                MemoryAttributes_xs := w__7 |})).

Definition undefined_PASpace '(tt : unit) : M (PASpace) :=
   (internal_pick ([PAS_NonSecure; PAS_Secure; PAS_Root; PAS_Realm]))  : M (PASpace).

Definition undefined_FullAddress '(tt : unit) : M (FullAddress) :=
   (undefined_PASpace (tt)) >>= fun (w__0 : PASpace) =>
   (undefined_bitvector (56)) >>= fun (w__1 : mword 56) =>
   returnM (({| FullAddress_paspace := w__0;  FullAddress_address := w__1 |})).

Definition undefined_GPCF '(tt : unit) : M (GPCF) :=
   (internal_pick ([GPCF_None; GPCF_AddressSize; GPCF_Walk; GPCF_EABT; GPCF_Fail]))  : M (GPCF).

Definition undefined_GPCFRecord '(tt : unit) : M (GPCFRecord) :=
   (undefined_GPCF (tt)) >>= fun (w__0 : GPCF) =>
   (undefined_int (tt)) >>= fun (w__1 : Z) =>
   returnM (({| GPCFRecord_gpf := w__0;  GPCFRecord_level := w__1 |})).

Definition undefined_Fault '(tt : unit) : M (Fault) :=
   (internal_pick
      ([Fault_None;
      Fault_AccessFlag;
      Fault_Alignment;
      Fault_Background;
      Fault_Domain;
      Fault_Permission;
      Fault_Translation;
      Fault_AddressSize;
      Fault_SyncExternal;
      Fault_SyncExternalOnWalk;
      Fault_SyncParity;
      Fault_SyncParityOnWalk;
      Fault_GPCFOnWalk;
      Fault_GPCFOnOutput;
      Fault_AsyncParity;
      Fault_AsyncExternal;
      Fault_TagCheck;
      Fault_Debug;
      Fault_TLBConflict;
      Fault_BranchTarget;
      Fault_HWUpdateAccessFlag;
      Fault_Lockdown;
      Fault_Exclusive;
      Fault_ICacheMaint]))
    : M (Fault).

Definition undefined_ErrorState '(tt : unit) : M (ErrorState) :=
   (internal_pick
      ([ErrorState_UC;
      ErrorState_UEU;
      ErrorState_UEO;
      ErrorState_UER;
      ErrorState_CE;
      ErrorState_Uncategorized;
      ErrorState_IMPDEF]))
    : M (ErrorState).

Definition undefined_FaultRecord '(tt : unit) : M (FaultRecord) :=
   (undefined_Fault (tt)) >>= fun (w__0 : Fault) =>
   (undefined_AccessDescriptor (tt)) >>= fun (w__1 : AccessDescriptor) =>
   (undefined_FullAddress (tt)) >>= fun (w__2 : FullAddress) =>
   (undefined_GPCFRecord (tt)) >>= fun (w__3 : GPCFRecord) =>
   (undefined_FullAddress (tt)) >>= fun (w__4 : FullAddress) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bool (tt)) >>= fun (w__7 : bool) =>
   (undefined_bool (tt)) >>= fun (w__8 : bool) =>
   (undefined_bool (tt)) >>= fun (w__9 : bool) =>
   (undefined_int (tt)) >>= fun (w__10 : Z) =>
   (undefined_bitvector (1)) >>= fun (w__11 : mword 1) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_bool (tt)) >>= fun (w__13 : bool) =>
   (undefined_bool (tt)) >>= fun (w__14 : bool) =>
   (undefined_bool (tt)) >>= fun (w__15 : bool) =>
   (undefined_bool (tt)) >>= fun (w__16 : bool) =>
   (undefined_bitvector (4)) >>= fun (w__17 : mword 4) =>
   (undefined_ErrorState (tt)) >>= fun (w__18 : ErrorState) =>
   (undefined_bitvector (4)) >>= fun (w__19 : mword 4) =>
   returnM (({| FaultRecord_statuscode := w__0;
                FaultRecord_access := w__1;
                FaultRecord_ipaddress := w__2;
                FaultRecord_gpcf := w__3;
                FaultRecord_paddress := w__4;
                FaultRecord_gpcfs2walk := w__5;
                FaultRecord_s2fs1walk := w__6;
                FaultRecord_write := w__7;
                FaultRecord_s1tagnotdata := w__8;
                FaultRecord_tagaccess := w__9;
                FaultRecord_level := w__10;
                FaultRecord_extflag := w__11;
                FaultRecord_secondstage := w__12;
                FaultRecord_assuredonly := w__13;
                FaultRecord_toplevel := w__14;
                FaultRecord_overlay := w__15;
                FaultRecord_dirtybit := w__16;
                FaultRecord_domain := w__17;
                FaultRecord_merrorstate := w__18;
                FaultRecord_debugmoe := w__19 |})).

Definition undefined_MBReqDomain '(tt : unit) : M (MBReqDomain) :=
   (internal_pick
      ([MBReqDomain_Nonshareable;
      MBReqDomain_InnerShareable;
      MBReqDomain_OuterShareable;
      MBReqDomain_FullSystem]))
    : M (MBReqDomain).

Definition undefined_MBReqTypes '(tt : unit) : M (MBReqTypes) :=
   (internal_pick ([MBReqTypes_Reads; MBReqTypes_Writes; MBReqTypes_All]))  : M (MBReqTypes).

Definition undefined_CacheRecord '(tt : unit) : M (CacheRecord) :=
   (undefined_AccessType (tt)) >>= fun (w__0 : AccessType) =>
   (undefined_CacheOp (tt)) >>= fun (w__1 : CacheOp) =>
   (undefined_CacheOpScope (tt)) >>= fun (w__2 : CacheOpScope) =>
   (undefined_CacheType (tt)) >>= fun (w__3 : CacheType) =>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   (undefined_FullAddress (tt)) >>= fun (w__5 : FullAddress) =>
   (undefined_bitvector (64)) >>= fun (w__6 : mword 64) =>
   (undefined_int (tt)) >>= fun (w__7 : Z) =>
   (undefined_int (tt)) >>= fun (w__8 : Z) =>
   (undefined_int (tt)) >>= fun (w__9 : Z) =>
   (undefined_Shareability (tt)) >>= fun (w__10 : Shareability) =>
   (undefined_bool (tt)) >>= fun (w__11 : bool) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_bitvector (16)) >>= fun (w__13 : mword 16) =>
   (undefined_bool (tt)) >>= fun (w__14 : bool) =>
   (undefined_bitvector (16)) >>= fun (w__15 : mword 16) =>
   (undefined_SecurityState (tt)) >>= fun (w__16 : SecurityState) =>
   (undefined_CachePASpace (tt)) >>= fun (w__17 : CachePASpace) =>
   returnM (({| CacheRecord_acctype := w__0;
                CacheRecord_cacheop := w__1;
                CacheRecord_opscope := w__2;
                CacheRecord_cachetype := w__3;
                CacheRecord_regval := w__4;
                CacheRecord_paddress := w__5;
                CacheRecord_vaddress := w__6;
                CacheRecord_setnum := w__7;
                CacheRecord_waynum := w__8;
                CacheRecord_level := w__9;
                CacheRecord_shareability := w__10;
                CacheRecord_translated := w__11;
                CacheRecord_is_vmid_valid := w__12;
                CacheRecord_vmid := w__13;
                CacheRecord_is_asid_valid := w__14;
                CacheRecord_asid := w__15;
                CacheRecord_security := w__16;
                CacheRecord_cpas := w__17 |})).

Definition undefined_Regime '(tt : unit) : M (Regime) :=
   (internal_pick ([Regime_EL3; Regime_EL30; Regime_EL2; Regime_EL20; Regime_EL10]))  : M (Regime).

Definition undefined_TGx '(tt : unit) : M (TGx) :=
   (internal_pick ([TGx_4KB; TGx_16KB; TGx_64KB]))  : M (TGx).

Definition undefined_TLBContext '(tt : unit) : M (TLBContext) :=
   (undefined_SecurityState (tt)) >>= fun (w__0 : SecurityState) =>
   (undefined_Regime (tt)) >>= fun (w__1 : Regime) =>
   (undefined_bitvector (16)) >>= fun (w__2 : mword 16) =>
   (undefined_bitvector (16)) >>= fun (w__3 : mword 16) =>
   (undefined_bitvector (1)) >>= fun (w__4 : mword 1) =>
   (undefined_PASpace (tt)) >>= fun (w__5 : PASpace) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bool (tt)) >>= fun (w__7 : bool) =>
   (undefined_bool (tt)) >>= fun (w__8 : bool) =>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   (undefined_TGx (tt)) >>= fun (w__10 : TGx) =>
   (undefined_bitvector (1)) >>= fun (w__11 : mword 1) =>
   (undefined_int (tt)) >>= fun (w__12 : Z) =>
   (undefined_bool (tt)) >>= fun (w__13 : bool) =>
   (undefined_bitvector (1)) >>= fun (w__14 : mword 1) =>
   returnM (({| TLBContext_ss := w__0;
                TLBContext_regime := w__1;
                TLBContext_vmid := w__2;
                TLBContext_asid := w__3;
                TLBContext_nG := w__4;
                TLBContext_ipaspace := w__5;
                TLBContext_includes_s1_name := w__6;
                TLBContext_includes_s2_name := w__7;
                TLBContext_includes_gpt_name := w__8;
                TLBContext_ia := w__9;
                TLBContext_tg := w__10;
                TLBContext_cnp := w__11;
                TLBContext_level := w__12;
                TLBContext_isd128 := w__13;
                TLBContext_xs := w__14 |})).

Definition undefined_AddressDescriptor '(tt : unit) : M (AddressDescriptor) :=
   (undefined_FaultRecord (tt)) >>= fun (w__0 : FaultRecord) =>
   (undefined_MemoryAttributes (tt)) >>= fun (w__1 : MemoryAttributes) =>
   (undefined_FullAddress (tt)) >>= fun (w__2 : FullAddress) =>
   (undefined_TLBContext (tt)) >>= fun (w__3 : TLBContext) =>
   (undefined_bool (tt)) >>= fun (w__4 : bool) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bitvector (16)) >>= fun (w__6 : mword 16) =>
   (undefined_bitvector (64)) >>= fun (w__7 : mword 64) =>
   returnM (({| AddressDescriptor_fault := w__0;
                AddressDescriptor_memattrs := w__1;
                AddressDescriptor_paddress := w__2;
                AddressDescriptor_tlbcontext := w__3;
                AddressDescriptor_s1assured := w__4;
                AddressDescriptor_s2fs1mro := w__5;
                AddressDescriptor_mecid := w__6;
                AddressDescriptor_vaddress := w__7 |})).

Definition undefined_TranslationStartInfo '(tt : unit) : M (TranslationStartInfo) :=
   (undefined_SecurityState (tt)) >>= fun (w__0 : SecurityState) =>
   (undefined_Regime (tt)) >>= fun (w__1 : Regime) =>
   (undefined_bitvector (16)) >>= fun (w__2 : mword 16) =>
   (undefined_bitvector (16)) >>= fun (w__3 : mword 16) =>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   (undefined_bitvector (1)) >>= fun (w__5 : mword 1) =>
   (undefined_AccessDescriptor (tt)) >>= fun (w__6 : AccessDescriptor) =>
   (undefined_int (tt)) >>= fun (w__7 : Z) =>
   returnM (({| TranslationStartInfo_ss := w__0;
                TranslationStartInfo_regime := w__1;
                TranslationStartInfo_vmid := w__2;
                TranslationStartInfo_asid := w__3;
                TranslationStartInfo_va := w__4;
                TranslationStartInfo_cnp := w__5;
                TranslationStartInfo_accdesc := w__6;
                TranslationStartInfo_size := w__7 |})).

Definition undefined_TLBILevel '(tt : unit) : M (TLBILevel) :=
   (internal_pick ([TLBILevel_Any; TLBILevel_Last]))  : M (TLBILevel).

Definition undefined_TLBIOp '(tt : unit) : M (TLBIOp) :=
   (internal_pick
      ([TLBIOp_DALL;
      TLBIOp_DASID;
      TLBIOp_DVA;
      TLBIOp_IALL;
      TLBIOp_IASID;
      TLBIOp_IVA;
      TLBIOp_ALL;
      TLBIOp_ASID;
      TLBIOp_IPAS2;
      TLBIPOp_IPAS2;
      TLBIOp_VAA;
      TLBIOp_VA;
      TLBIPOp_VAA;
      TLBIPOp_VA;
      TLBIOp_VMALL;
      TLBIOp_VMALLS12;
      TLBIOp_RIPAS2;
      TLBIPOp_RIPAS2;
      TLBIOp_RVAA;
      TLBIOp_RVA;
      TLBIPOp_RVAA;
      TLBIPOp_RVA;
      TLBIOp_RPA;
      TLBIOp_PAALL]))
    : M (TLBIOp).

Definition undefined_TLBIMemAttr '(tt : unit) : M (TLBIMemAttr) :=
   (internal_pick ([TLBI_AllAttr; TLBI_ExcludeXS]))  : M (TLBIMemAttr).

Definition undefined_TLBIRecord '(tt : unit) : M (TLBIRecord) :=
   (undefined_TLBIOp (tt)) >>= fun (w__0 : TLBIOp) =>
   (undefined_bool (tt)) >>= fun (w__1 : bool) =>
   (undefined_SecurityState (tt)) >>= fun (w__2 : SecurityState) =>
   (undefined_Regime (tt)) >>= fun (w__3 : Regime) =>
   (undefined_bitvector (16)) >>= fun (w__4 : mword 16) =>
   (undefined_bitvector (16)) >>= fun (w__5 : mword 16) =>
   (undefined_TLBILevel (tt)) >>= fun (w__6 : TLBILevel) =>
   (undefined_TLBIMemAttr (tt)) >>= fun (w__7 : TLBIMemAttr) =>
   (undefined_PASpace (tt)) >>= fun (w__8 : PASpace) =>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   (undefined_bitvector (64)) >>= fun (w__10 : mword 64) =>
   (undefined_bool (tt)) >>= fun (w__11 : bool) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_bitvector (4)) >>= fun (w__13 : mword 4) =>
   (undefined_bitvector (2)) >>= fun (w__14 : mword 2) =>
   returnM (({| TLBIRecord_op := w__0;
                TLBIRecord_from_aarch64 := w__1;
                TLBIRecord_security := w__2;
                TLBIRecord_regime := w__3;
                TLBIRecord_vmid := w__4;
                TLBIRecord_asid := w__5;
                TLBIRecord_level := w__6;
                TLBIRecord_attr := w__7;
                TLBIRecord_ipaspace := w__8;
                TLBIRecord_address := w__9;
                TLBIRecord_end_address_name := w__10;
                TLBIRecord_d64 := w__11;
                TLBIRecord_d128 := w__12;
                TLBIRecord_ttl := w__13;
                TLBIRecord_tg := w__14 |})).

Definition undefined_TLBIInfo '(tt : unit) : M (TLBIInfo) :=
   (undefined_TLBIRecord (tt)) >>= fun (w__0 : TLBIRecord) =>
   (undefined_Shareability (tt)) >>= fun (w__1 : Shareability) =>
   returnM (({| TLBIInfo_rec := w__0;  TLBIInfo_shareability := w__1 |})).

Definition undefined_DxB '(tt : unit) : M (DxB) :=
   (undefined_MBReqDomain (tt)) >>= fun (w__0 : MBReqDomain) =>
   (undefined_MBReqTypes (tt)) >>= fun (w__1 : MBReqTypes) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   returnM (({| DxB_domain := w__0;  DxB_types := w__1;  DxB_nXS := w__2 |})).

Definition undefined_move_imm_data '(tt : unit) : M (move_imm_data) :=
   (undefined_bitvector (16)) >>= fun (w__0 : mword 16) =>
   (undefined_bitvector (2)) >>= fun (w__1 : mword 2) =>
   returnM (({| move_imm_data_imm := w__0;  move_imm_data_hw := w__1 |})).

Definition GPRs : vec (register_ref (bits 64)) 31 :=
vec_of_list_len [R30_ref;R29_ref;R28_ref;R27_ref;R26_ref;R25_ref;R24_ref;R23_ref;R22_ref;R21_ref;
                 R20_ref;R19_ref;R18_ref;R17_ref;R16_ref;R15_ref;R14_ref;R13_ref;R12_ref;R11_ref;
                 R10_ref;R9_ref;R8_ref;R7_ref;R6_ref;R5_ref;R4_ref;R3_ref;R2_ref;R1_ref;R0_ref].
#[export] Hint Unfold GPRs : sail.
Definition wX (n : Z) (value : mword 64) (*(0 <=? n) && (n <=? 31)*) : M (unit) :=
   (if neq_int (n) (31) return M (unit) then
      write_reg_ref (vec_access_dec (GPRs) (n)) value
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition rX (n : Z) (*(0 <=? n) && (n <=? 31)*) : M (mword 64) :=
   (if neq_int (n) (31) return M (mword 64) then
      (reg_deref ((vec_access_dec (GPRs) (n))))
       : M (mword 64)
    else returnM (((Ox"0000000000000000")  : mword 64)))
    : M (mword 64).

Definition wW (n : Z) (value : mword 32) (*(0 <=? n) && (n <=? 31)*) : M (unit) :=
   (if neq_int (n) (31) return M (unit) then
      write_reg_ref (vec_access_dec (GPRs) (n)) (zero_extend (value) (64))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition rW (n : Z) (*(0 <=? n) && (n <=? 31)*) : M (mword 32) :=
   (if neq_int (n) (31) return M (mword 32) then
      (reg_deref ((vec_access_dec (GPRs) (n)))) >>= fun (w__0 : mword 64) =>
      returnM ((subrange_vec_dec (w__0) (31) (0)))
    else returnM (((Ox"00000000")  : mword 32)))
    : M (mword 32).

Definition rPC '(tt : unit) : M (mword 64) := ((read_reg _PC)  : M (mword 64))  : M (mword 64).

Definition wPC (pc : mword 64) : M (unit) := write_reg _PC pc  : M (unit).

Definition is_ok {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => true | Err _ => false end.

Definition is_err {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => false | Err _ => true end.

Definition ok_option {a : Type} {b : Type} (r : result a b) : option a :=
   match r with | Ok x => Some (x) | Err _ => None end.

Definition err_option {a : Type} {b : Type} (r : result a b) : option b :=
   match r with | Ok _ => None | Err err => Some (err) end.

Definition unwrap_or {a : Type} {b : Type} (r : result a b) (y : a) : a :=
   match r with | Ok x => x | Err _ => y end.

Definition sail_instr_announce {n : Z} (_ : mword n) (*n >? 0*) : unit := tt.

Definition sail_branch_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition sail_reset_registers '(tt : unit) : unit := tt.

Definition sail_synchronize_registers '(tt : unit) : unit := tt.

Definition sail_mark_register {a : Type} (_ : register_ref a) (_ : string) : unit := tt.

Definition sail_mark_register_pair {a : Type} {b : Type}
(_ : register_ref a) (_ : register_ref b) (_ : string)
: unit :=
   tt.

Definition sail_ignore_write_to {a : Type} (reg : register_ref a) : unit :=
   sail_mark_register (reg) ("ignore_write").

Definition sail_pick_dependency {a : Type} (reg : register_ref a) : unit :=
   sail_mark_register (reg) ("pick").

Definition __monomorphize {n : Z} (bv : mword n) (*n >=? 0*) : mword n := bv.

Definition __monomorphize_int (n : Z) : Z := n.

Definition __monomorphize_bool (b : bool) : bool := b.

Definition __monomorphize_reads : bool := false.
#[export] Hint Unfold __monomorphize_reads : sail.
Definition __monomorphize_writes : bool := false.
#[export] Hint Unfold __monomorphize_writes : sail.
Definition sail_address_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition addr_size' : Z := 64.
#[export] Hint Unfold addr_size' : sail.
Definition base_AccessDescriptor (acctype : AccessType) : AccessDescriptor :=
   {| AccessDescriptor_acctype := acctype;
      AccessDescriptor_el := zeros (2);
      AccessDescriptor_ss := SS_NonSecure;
      AccessDescriptor_acqsc := false;
      AccessDescriptor_acqpc := false;
      AccessDescriptor_relsc := false;
      AccessDescriptor_limitedordered := false;
      AccessDescriptor_exclusive := false;
      AccessDescriptor_atomicop := false;
      AccessDescriptor_modop := MemAtomicOp_ADD;
      AccessDescriptor_nontemporal := false;
      AccessDescriptor_read := false;
      AccessDescriptor_write := false;
      AccessDescriptor_cacheop := CacheOp_Clean;
      AccessDescriptor_opscope := CacheOpScope_ALLU;
      AccessDescriptor_cachetype := CacheType_Data;
      AccessDescriptor_pan := false;
      AccessDescriptor_transactional := false;
      AccessDescriptor_nonfault := false;
      AccessDescriptor_firstfault := false;
      AccessDescriptor_first := false;
      AccessDescriptor_contiguous := false;
      AccessDescriptor_streamingsve := false;
      AccessDescriptor_ls64 := false;
      AccessDescriptor_mops := false;
      AccessDescriptor_rcw := false;
      AccessDescriptor_rcws := false;
      AccessDescriptor_toplevel := false;
      AccessDescriptor_varange := VARange_LOWER;
      AccessDescriptor_a32lsmd := false;
      AccessDescriptor_tagchecked := false;
      AccessDescriptor_tagaccess := false;
      AccessDescriptor_mpam :=
        {| MPAMinfo_mpam_sp := PIdSpace_NonSecure;
           MPAMinfo_partid := (Ox"0000")  : mword 16;
           MPAMinfo_pmg := (Ox"00")  : mword 8 |} |}.

Definition current_el '(tt : unit) : mword 2 := ('b"00")  : mword 2.

Definition create_GPRAccessDescriptor (is_write : bool) (ordering : MemoryOrdering)
: AccessDescriptor :=
   let accdesc := base_AccessDescriptor (AccessType_GPR) in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_write := is_write|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_read := negb (is_write)|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_el := current_el (tt)|> in
   match ordering with
   | Ordering_Relaxed => accdesc
   | Ordering_Acquire => accdesc <|AccessDescriptor_acqsc := true|>
   | Ordering_AcquireRCpc => accdesc <|AccessDescriptor_acqpc := true|>
   | Ordering_Release => accdesc <|AccessDescriptor_relsc := true|>
   end.

Definition create_readAccessDescriptor '(tt : unit) : AccessDescriptor :=
   create_GPRAccessDescriptor (false) (Ordering_Relaxed).

Definition create_writeAccessDescriptor '(tt : unit) : AccessDescriptor :=
   create_GPRAccessDescriptor (true) (Ordering_Relaxed).

Definition create_readAcquireAccessDescriptor (ordering : MemoryOrdering) : AccessDescriptor :=
   create_GPRAccessDescriptor (false) (ordering).

Definition create_writeReleaseAccessDescriptor '(tt : unit) : AccessDescriptor :=
   create_GPRAccessDescriptor (true) (Ordering_Release).

Definition create_iFetchAccessDescriptor '(tt : unit) : AccessDescriptor :=
   let accdesc := base_AccessDescriptor (AccessType_IFETCH) in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_read := true|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_write := false|> in
   accdesc
   <|AccessDescriptor_el := current_el (tt)|>.

Definition addr_space_def := tt.
#[export] Hint Unfold addr_space_def : sail.
Definition read_memory (N : Z) (addr : mword 64) (accdesc : AccessDescriptor) (*N >? 0*)
: M (mword (N * 8)) :=
   let req : Mem_request N 0 addr_size addr_space AccessDescriptor :=
     {| Mem_request_access_kind := accdesc;
        Mem_request_address := vector_truncate (addr) (addr_size');
        Mem_request_address_space := addr_space_def;
        Mem_request_size := N;
        Mem_request_num_tag := 0 |} in
   (sail_mem_read ((autocast (T := fun _sz => (Mem_request _ _ _sz _ _)%type) req))) >>= fun (w__0 : result ((vec (mword 8) N * vec bool 0)) unit) =>
   match w__0 with
   | Ok (bytes, _) => returnM ((autocast (T := mword) (from_bytes_le ((__id (N))) (bytes))))
   | Err _e => exit tt  : M (mword (N * 8))
   end
    : M (mword (N * 8)).

Definition iFetch (addr : mword 64) (accdesc : AccessDescriptor) : M (mword 32) :=
   (read_memory (4) (addr) (accdesc))  : M (mword (4 * 8)).

Definition rMem (N : Z) (addr : mword 64) (accdesc : AccessDescriptor) (*N >? 0*)
: M (mword (N * 8)) :=
   (read_memory (N) (addr) (accdesc))  : M (mword (N * 8)).

Definition wMem_Addr (addr : mword 64) : unit :=
   sail_address_announce (64) ((zero_extend (addr) (64))).

Definition wMem (N : Z) (addr : mword 64) (value : mword (N * 8)) (accdesc : AccessDescriptor)
(*N >? 0*)
: M (unit) :=
   let req : Mem_request N 0 addr_size addr_space AccessDescriptor :=
     {| Mem_request_access_kind := accdesc;
        Mem_request_address := vector_truncate (addr) (addr_size');
        Mem_request_address_space := addr_space_def;
        Mem_request_size := N;
        Mem_request_num_tag := 0 |} in
   (sail_mem_write ((autocast (T := fun _sz => (Mem_request _ _ _sz _ _)%type) req))
      ((to_bytes_le (N) ((autocast (T := mword)  value)))) ((vec_of_list_len []))) >>= fun (w__0 : result unit unit) =>
   match w__0 with | Ok _ => returnM (tt) | Err _ => exit tt  : M (unit) end
    : M (unit).

Definition dataMemoryBarrier (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   (sail_barrier
      ((Barrier_DMB (({| DxB_domain := domain;  DxB_types := types;  DxB_nXS := false |})))))
    : M (unit).

Definition dataSynchronizationBarrer (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   (sail_barrier
      ((Barrier_DSB (({| DxB_domain := domain;  DxB_types := types;  DxB_nXS := false |})))))
    : M (unit).

Definition instructionSynchronizationBarrier '(tt : unit) : M (unit) :=
   (sail_barrier ((Barrier_ISB (tt))))  : M (unit).

Definition translate_address (va : mword 64) (accdesc : AccessDescriptor) : option (mword 64) :=
   Some (va).

Definition execute_load (sf : bitU) (t : Z) (vaddr : mword 64) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   catch_early_return
     (let accdesc := create_readAccessDescriptor (tt) in
     match translate_address (vaddr) (accdesc) with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 64))  : MR (unit) (mword 64)
     end >>= fun (addr : bits addr_size) =>
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__1 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__1) (4))) >>
     (if eq_bit (sf) (B1) return MR (unit) (unit) then
        liftR ((rMem (8) (addr) (accdesc))) >>= fun (data : bits 64) =>
        liftR ((wX (t) (data)))
         : MR (unit) (unit)
      else
        liftR ((rMem (4) (addr) (accdesc))) >>= fun (data : bits 32) =>
        liftR ((wW (t) (data)))
         : MR (unit) (unit))
      : MR (unit) (unit)).

Definition execute_store (sf : bitU) (t : Z) (vaddr : mword 64) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   catch_early_return
     (let accdesc := create_writeAccessDescriptor (tt) in
     match translate_address (vaddr) (accdesc) with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 64))  : MR (unit) (mword 64)
     end >>= fun (addr : bits addr_size) =>
     let '(_) := (wMem_Addr (addr))  : unit in
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__1 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__1) (4))) >>
     (if eq_bit (sf) (B1) return MR (unit) (unit) then
        liftR ((rX (t))) >>= fun data =>
        liftR ((wMem (8) (addr) (data) (accdesc)))
         : MR (unit) (unit)
      else
        liftR ((rW (t))) >>= fun data =>
        liftR ((wMem (4) (addr) (data) (accdesc)))
         : MR (unit) (unit))
      : MR (unit) (unit)).

Definition execute_load_acquire (sf : bitU) (t : Z) (vaddr : mword 64) (ordering : MemoryOrdering)
(*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   catch_early_return
     (let accdesc := create_readAcquireAccessDescriptor (ordering) in
     match translate_address (vaddr) (accdesc) with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 64))  : MR (unit) (mword 64)
     end >>= fun (addr : bits addr_size) =>
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__1 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__1) (4))) >>
     (if eq_bit (sf) (B1) return MR (unit) (unit) then
        liftR ((rMem (8) (addr) (accdesc))) >>= fun (data : bits 64) =>
        liftR ((wX (t) (data)))
         : MR (unit) (unit)
      else
        liftR ((rMem (4) (addr) (accdesc))) >>= fun (data : bits 32) =>
        liftR ((wW (t) (data)))
         : MR (unit) (unit))
      : MR (unit) (unit)).

Definition execute_store_release (sf : bitU) (t : Z) (vaddr : mword 64) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   catch_early_return
     (let accdesc := create_writeReleaseAccessDescriptor (tt) in
     match translate_address (vaddr) (accdesc) with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 64))  : MR (unit) (mword 64)
     end >>= fun (addr : bits addr_size) =>
     let '(_) := (wMem_Addr (addr))  : unit in
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__1 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__1) (4))) >>
     (if eq_bit (sf) (B1) return MR (unit) (unit) then
        liftR ((rX (t))) >>= fun data =>
        liftR ((wMem (8) (addr) (data) (accdesc)))
         : MR (unit) (unit)
      else
        liftR ((rW (t))) >>= fun data =>
        liftR ((wMem (4) (addr) (data) (accdesc)))
         : MR (unit) (unit))
      : MR (unit) (unit)).

Definition decodeLoadStoreRegister
(size : mword 2) (opc : mword 2) (Rm : mword 5) (option_v : mword 3) (S' : bitU) (Rn : mword 5)
(Rt : mword 5)
: option ast :=
   let t : reg_index := uint (Rt) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
   if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
   then
     None
   else if orb ((neq_vec (option_v) ((('b"011")  : mword 3)))) ((eq_bit (S') (B1))) then None
   else if eq_vec (opc) ((('b"01")  : mword 2)) then Some ((Load ((sf, t, n, OperandReg (m)))))
   else if eq_vec (opc) ((('b"00")  : mword 2)) then Some ((Store ((sf, t, n, OperandReg (m)))))
   else None.

Definition decodeLoadStoreImmediate
(size : mword 2) (opc : mword 2) (imm12 : mword 12) (Rn : mword 5) (Rt : mword 5)
: option ast :=
   let t : reg_index := uint (Rt) in
   let n : reg_index := uint (Rn) in
   let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
   if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
   then
     None
   else if eq_vec (opc) ((('b"01")  : mword 2)) then Some ((Load ((sf, t, n, OperandImm (imm12)))))
   else if eq_vec (opc) ((('b"00")  : mword 2)) then Some ((Store ((sf, t, n, OperandImm (imm12)))))
   else None.

Definition decodeBitwiseAndRegister
(sf : bitU) (shift : mword 2) (N : bitU) (Rm : mword 5) (imm6 : mword 6) (Rn : mword 5)
(Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if andb ((eq_bit (sf) (B0))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))) then None
   else if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
   else Some ((BitwiseAnd ((sf, d, n, OperandReg (m))))).

Definition decode_bitmask_immediate (N : bitU) (imms : mword 6) (immr : mword 6) : option (mword 64) :=
   if andb ((eq_bit (N) (B1))) ((eq_vec (immr) ((('b"000000")  : mword 6)))) then
     let ones : Z := Z.add ((uint (imms))) (1) in
     if andb ((Z.geb (ones) (1))) ((Z.leb (ones) (63))) then
       let mask : bits 64 := sail_mask (64) ((sail_ones (ones))) in
       Some (mask)
     else None
   else None.

Definition decodeBitwiseAndImmediate
(sf : bitU) (N : bitU) (immr : mword 6) (imms : mword 6) (Rn : mword 5) (Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   if andb ((eq_bit (sf) (B0))) ((eq_bit (N) (B1))) then None
   else
     match decode_bitmask_immediate (N) (imms) (immr) with
     | Some mask =>
        let imm12 : bits 12 := subrange_vec_dec (mask) (11) (0) in
        Some ((BitwiseAnd ((sf, d, n, OperandImm (imm12)))))
     | None => None
     end.

Definition decodeExclusiveOr
(sf : bitU) (shift : mword 2) (N : bitU) (Rm : mword 5) (imm6 : mword 6) (Rn : mword 5)
(Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if andb ((eq_bit (sf) (B0))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))) then None
   else if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
   else Some ((ExclusiveOr ((sf, d, n, m)))).

Definition decodeInclusiveOr
(sf : bitU) (shift : mword 2) (N : bitU) (Rm : mword 5) (imm6 : mword 6) (Rn : mword 5)
(Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if andb ((eq_bit (sf) (B0))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))) then None
   else if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
   else Some ((InclusiveOr ((sf, d, n, m)))).

Definition decodeAddSub
(sf : bitU) (op : bitU) (is_imm : bitU) (shift : mword 2) (imm12 : mword 12) (imm6 : mword 6)
(Rm : mword 5) (Rn : mword 5) (Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if andb ((eq_bit (sf) (B0)))
        ((andb ((eq_bit (is_imm) (B0))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))))) then
     None
   else if eq_bit (is_imm) (B0) then
     if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
     else if eq_bit (op) (B0) then Some ((Add ((sf, d, n, OperandReg (m)))))
     else Some ((Sub ((sf, d, n, OperandReg (m)))))
   else if eq_vec (shift) ((('b"00")  : mword 2)) then
     if eq_bit (op) (B0) then Some ((Add ((sf, d, n, OperandImm (imm12)))))
     else Some ((Sub ((sf, d, n, OperandImm (imm12)))))
   else None.

Definition decodeCompare
(sf : bitU) (shift : mword 2) (imm12 : mword 12) (imm6 : mword 6) (Rm : mword 5) (Rn : mword 5)
: option ast :=
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   let is_imm :=
     orb ((neq_vec (imm12) (((Ox"000")  : mword 12))))
       ((andb ((eq_vec (Rm) ((('b"00000")  : mword 5))))
           ((eq_vec (imm6) ((('b"000000")  : mword 6)))))) in
   if andb ((eq_bit (sf) (B0)))
        ((andb ((Bool.eqb (is_imm) (false))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))))) then
     None
   else if Bool.eqb (is_imm) (false) then
     if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
     else Some ((Compare ((sf, n, OperandReg (m)))))
   else if eq_vec (shift) ((('b"00")  : mword 2)) then
     Some ((Compare ((sf, n, OperandImm (imm12)))))
   else None.

Definition decodeDataBarrier (CRm : mword 4) (is_sync : bool) : option ast :=
   pure_early_return
     (let b__3 := subrange_vec_dec (CRm) (3) (2) in
     (if eq_vec (b__3) ((('b"11")  : mword 2)) then inr (MBReqDomain_FullSystem)
      else if eq_vec (b__3) ((('b"10")  : mword 2)) then inr (MBReqDomain_InnerShareable)
      else if eq_vec (b__3) ((('b"01")  : mword 2)) then inr (MBReqDomain_Nonshareable)
      else if eq_vec (b__3) ((('b"00")  : mword 2)) then inr (MBReqDomain_OuterShareable)
      else
        (inl (None  : option ast) : sum (option ast) MBReqDomain)
         : sum (option ast) (MBReqDomain)) >>$= fun '(domain) =>
     let b__0 := subrange_vec_dec (CRm) (1) (0) in
     (if eq_vec (b__0) ((('b"01")  : mword 2)) then inr (MBReqTypes_Reads)
      else if eq_vec (b__0) ((('b"10")  : mword 2)) then inr (MBReqTypes_Writes)
      else if eq_vec (b__0) ((('b"11")  : mword 2)) then inr (MBReqTypes_All)
      else (inl (None  : option ast) : sum (option ast) MBReqTypes)  : sum (option ast) (MBReqTypes)) >>$= fun '(types) =>
     inr ((if is_sync then Some ((DataSynchronizationBarrier ((domain, types))))
           else Some ((DataMemoryBarrier ((domain, types))))))).

Definition decodeCompareAndBranch (sf : bitU) (op : bitU) (imm19 : mword 19) (Rt : mword 5)
: option ast :=
   let t : reg_index := uint (Rt) in
   let offset : bits 64 := sign_extend ((concat_vec (imm19) ((('b"00")  : mword 2)))) (64) in
   let iszero : bool := eq_bit (op) (B0) in
   Some ((CompareAndBranch ((sf, t, offset, iszero)))).

Definition execute_Sub (sf : bitU) (d : Z) (n : Z) (op : operand) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun op1 =>
      match op with
      | OperandReg m => (rX (m))  : M (mword 64)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (64)))
      end >>= fun (op2 : bits 64) =>
      (wX (d) ((add_vec (op1) ((add_vec_int ((not_vec (op2))) (1))))))
       : M (unit)
    else
      (rW (n)) >>= fun op1 =>
      match op with
      | OperandReg m => (rW (m))  : M (mword 32)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (32)))
      end >>= fun (op2 : bits 32) =>
      (wW (d) ((add_vec (op1) ((add_vec_int ((not_vec (op2))) (1))))))
       : M (unit))
    : M (unit).

Definition execute_StoreRelease (sf : bitU) (t : Z) (n : Z) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   (rX (n)) >>= fun (addr : bits 64) => (execute_store_release (sf) (t) (addr))  : M (unit).

Definition execute_Store (sf : bitU) (t : Z) (n : Z) (op : operand) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   match op with
   | OperandReg m =>
      (rX (n)) >>= fun (w__0 : mword 64) =>
      (rX (m)) >>= fun (w__1 : mword 64) => returnM ((add_vec (w__0) (w__1)))
   | OperandImm imm12 =>
      (if eq_bit (sf) (B1) return M (mword 64) then
         (rX (n)) >>= fun (w__2 : mword 64) =>
         returnM ((add_vec (w__2)
                     ((zero_extend ((concat_vec (imm12) ((('b"000")  : mword 3)))) (64)))))
       else
         (rX (n)) >>= fun (w__3 : mword 64) =>
         returnM ((add_vec (w__3)
                     ((zero_extend ((concat_vec (imm12) ((('b"00")  : mword 2)))) (64))))))
       : M (mword 64)
   end >>= fun (addr : bits 64) =>
   (execute_store (sf) (t) (addr))
    : M (unit).

Definition execute_Nop '(tt : unit) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4))
    : M (unit).

Definition execute_Move (sf : bitU) (d : Z) (op : move_operand) (*(0 <=? d) && (d <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      match op with
      | MoveReg m => (rX (m))  : M (mword 64)
      | MoveImm data =>
         let b__2 := data.(move_imm_data_hw) in
         returnM ((if eq_vec (b__2) ((('b"00")  : mword 2)) then
                     zero_extend (data.(move_imm_data_imm)) (64)
                   else if eq_vec (b__2) ((('b"01")  : mword 2)) then
                     concat_vec ((zero_extend (data.(move_imm_data_imm)) (48)))
                       (((Ox"0000")
                        : mword 16))
                   else if eq_vec (b__2) ((('b"10")  : mword 2)) then
                     concat_vec ((zero_extend (data.(move_imm_data_imm)) (32)))
                       (((Ox"00000000")
                        : mword 32))
                   else concat_vec (data.(move_imm_data_imm)) (((Ox"000000000000")  : mword 48))))
      end >>= fun (res : bits 64) =>
      (wX (d) (res))
       : M (unit)
    else
      match op with
      | MoveReg m => (rW (m))  : M (mword 32)
      | MoveImm data =>
         let b__0 := data.(move_imm_data_hw) in
         returnM ((if eq_vec (b__0) ((('b"00")  : mword 2)) then
                     zero_extend (data.(move_imm_data_imm)) (32)
                   else if eq_vec (b__0) ((('b"01")  : mword 2)) then
                     concat_vec (data.(move_imm_data_imm)) (((Ox"0000")  : mword 16))
                   else zeros (32)))
      end >>= fun (res : bits 32) =>
      (wW (d) (res))
       : M (unit))
    : M (unit).

Definition execute_LogicalShiftRight (sf : bitU) (d : Z) (n : Z) (op : operand)
(*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun operand =>
      match op with
      | OperandReg m =>
         (rX (m)) >>= fun (w__1 : mword 64) => returnM ((uint ((subrange_vec_dec (w__1) (5) (0)))))
      | OperandImm imm => returnM ((uint ((subrange_vec_dec (imm) (5) (0)))))
      end >>= fun (shift_amount : Z) =>
      (wX (d) ((shiftr (operand) (shift_amount))))
       : M (unit)
    else
      (rW (n)) >>= fun operand =>
      match op with
      | OperandReg m =>
         (rW (m)) >>= fun (w__2 : mword 32) => returnM ((uint ((subrange_vec_dec (w__2) (4) (0)))))
      | OperandImm imm => returnM ((uint ((subrange_vec_dec (imm) (4) (0)))))
      end >>= fun (shift_amount : Z) =>
      (wW (d) ((shiftr (operand) (shift_amount))))
       : M (unit))
    : M (unit).

Definition execute_LoadAcquire (sf : bitU) (t : Z) (n : Z) (ordering : MemoryOrdering)
(*(0 <=? t) && (t <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   (rX (n)) >>= fun (addr : bits 64) =>
   (execute_load_acquire (sf) (t) (addr) (ordering))
    : M (unit).

Definition execute_Load (sf : bitU) (t : Z) (n : Z) (op : operand) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   match op with
   | OperandReg m =>
      (rX (n)) >>= fun (w__0 : mword 64) =>
      (rX (m)) >>= fun (w__1 : mword 64) => returnM ((add_vec (w__0) (w__1)))
   | OperandImm imm12 =>
      (if eq_bit (sf) (B1) return M (mword 64) then
         (rX (n)) >>= fun (w__2 : mword 64) =>
         returnM ((add_vec (w__2)
                     ((zero_extend ((concat_vec (imm12) ((('b"000")  : mword 3)))) (64)))))
       else
         (rX (n)) >>= fun (w__3 : mword 64) =>
         returnM ((add_vec (w__3)
                     ((zero_extend ((concat_vec (imm12) ((('b"00")  : mword 2)))) (64))))))
       : M (mword 64)
   end >>= fun (addr : bits 64) =>
   (execute_load (sf) (t) (addr))
    : M (unit).

Definition execute_InstructionSynchronizationBarrier '(tt : unit) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >> (instructionSynchronizationBarrier (tt))  : M (unit).

Definition execute_InclusiveOr (sf : bitU) (d : Z) (n : Z) (m : Z) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun operand1 =>
      (rX (m)) >>= fun operand2 => (wX (d) ((or_vec (operand1) (operand2))))  : M (unit)
    else
      (rW (n)) >>= fun operand1 =>
      (rW (m)) >>= fun operand2 => (wW (d) ((or_vec (operand1) (operand2))))  : M (unit))
    : M (unit).

Definition execute_ExclusiveOr (sf : bitU) (d : Z) (n : Z) (m : Z) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun operand1 =>
      (rX (m)) >>= fun operand2 => (wX (d) ((xor_vec (operand1) (operand2))))  : M (unit)
    else
      (rW (n)) >>= fun operand1 =>
      (rW (m)) >>= fun operand2 => (wW (d) ((xor_vec (operand1) (operand2))))  : M (unit))
    : M (unit).

Definition execute_DataSynchronizationBarrier (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (dataSynchronizationBarrer (domain) (types))
    : M (unit).

Definition execute_DataMemoryBarrier (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >> (dataMemoryBarrier (domain) (types))  : M (unit).

Definition execute_CompareAndBranch (sf : bitU) (t : Z) (offset : mword 64) (iszero : bool)
(*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   (if eq_bit (sf) (B1) return M (mword 64) then (rX (t))  : M (mword 64)
    else (rW (t)) >>= fun (w__1 : mword 32) => returnM ((zero_extend (w__1) (64)))) >>= fun (operand : bits 64) =>
   let condition_met :=
     if iszero then eq_vec (operand) (((Ox"0000000000000000")  : mword 64))
     else neq_vec (operand) (((Ox"0000000000000000")  : mword 64)) in
   (if condition_met return M (unit) then
      (rPC (tt)) >>= fun base =>
      let addr := add_vec (base) (offset) in
      (wPC (addr))
       : M (unit)
    else
      ((read_reg _PC)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
      write_reg _PC (add_vec_int (w__2) (4))
       : M (unit))
    : M (unit).

Definition execute_Branch (offset : mword 64) : M (unit) :=
   (rPC (tt)) >>= fun base =>
   let target := add_vec (base) (offset) in
   (wPC (target))
    : M (unit).

Definition execute_BitwiseAnd (sf : bitU) (d : Z) (n : Z) (op : operand) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun operand1 =>
      match op with
      | OperandReg m => (rX (m))  : M (mword 64)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (64)))
      end >>= fun (operand2 : bits 64) =>
      (wX (d) ((and_vec (operand1) (operand2))))
       : M (unit)
    else
      (rW (n)) >>= fun operand1 =>
      match op with
      | OperandReg m => (rW (m))  : M (mword 32)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (32)))
      end >>= fun (operand2 : bits 32) =>
      (wW (d) ((and_vec (operand1) (operand2))))
       : M (unit))
    : M (unit).

Definition execute_Add (sf : bitU) (d : Z) (n : Z) (op : operand) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun op1 =>
      match op with
      | OperandReg m => (rX (m))  : M (mword 64)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (64)))
      end >>= fun (op2 : bits 64) =>
      (wX (d) ((add_vec (op1) (op2))))
       : M (unit)
    else
      (rW (n)) >>= fun op1 =>
      match op with
      | OperandReg m => (rW (m))  : M (mword 32)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (32)))
      end >>= fun (op2 : bits 32) =>
      (wW (d) ((add_vec (op1) (op2))))
       : M (unit))
    : M (unit).

Definition execute (merge_var : ast) : M (unit) :=
   match merge_var with
   | Load (sf, t, n, op) => (execute_Load (sf) (t) (n) (op))  : M (unit)
   | Store (sf, t, n, op) => (execute_Store (sf) (t) (n) (op))  : M (unit)
   | LoadAcquire (sf, t, n, ordering) => (execute_LoadAcquire (sf) (t) (n) (ordering))  : M (unit)
   | StoreRelease (sf, t, n) => (execute_StoreRelease (sf) (t) (n))  : M (unit)
   | BitwiseAnd (sf, d, n, op) => (execute_BitwiseAnd (sf) (d) (n) (op))  : M (unit)
   | ExclusiveOr (sf, d, n, m) => (execute_ExclusiveOr (sf) (d) (n) (m))  : M (unit)
   | InclusiveOr (sf, d, n, m) => (execute_InclusiveOr (sf) (d) (n) (m))  : M (unit)
   | Move (sf, d, op) => (execute_Move (sf) (d) (op))  : M (unit)
   | Add (sf, d, n, op) => (execute_Add (sf) (d) (n) (op))  : M (unit)
   | Sub (sf, d, n, op) => (execute_Sub (sf) (d) (n) (op))  : M (unit)
   | DataMemoryBarrier (domain, types) => (execute_DataMemoryBarrier (domain) (types))  : M (unit)
   | DataSynchronizationBarrier (domain, types) =>
      (execute_DataSynchronizationBarrier (domain) (types))  : M (unit)
   | InstructionSynchronizationBarrier arg0 =>
      (execute_InstructionSynchronizationBarrier (arg0))  : M (unit)
   | Nop arg0 => (execute_Nop (arg0))  : M (unit)
   | CompareAndBranch (sf, t, offset, iszero) =>
      (execute_CompareAndBranch (sf) (t) (offset) (iszero))  : M (unit)
   | LogicalShiftRight (sf, d, n, op) => (execute_LogicalShiftRight (sf) (d) (n) (op))  : M (unit)
   | Branch offset => (execute_Branch (offset))  : M (unit)
   | _ =>
      assert_exp' false "Pattern match failure at instrs-user.sail:731.0-738.1" >>= fun _ => exit tt
   end
    : M (unit).

Definition decode (v__0 : mword 32) : option ast :=
   if andb ((eq_vec ((subrange_vec_dec (v__0) (29) (24))) ((('b"111000")  : mword 6))))
        ((andb ((eq_vec ((subrange_vec_dec (v__0) (21) (21))) ((('b"1")  : mword 1))))
            ((eq_vec ((subrange_vec_dec (v__0) (11) (10))) ((('b"10")  : mword 2)))))) then
     let S' := access_vec_dec (v__0) (12) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let option_v : bits 3 := subrange_vec_dec (v__0) (15) (13) in
     let opc : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     decodeLoadStoreRegister (size) (opc) (Rm) (option_v) (S') (Rn) (Rt)
   else if eq_vec ((subrange_vec_dec (v__0) (29) (24))) ((('b"111001")  : mword 6)) then
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let opc : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm12 : bits 12 := subrange_vec_dec (v__0) (21) (10) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     decodeLoadStoreImmediate (size) (opc) (imm12) (Rn) (Rt)
   else if eq_vec ((subrange_vec_dec (v__0) (29) (10))) (((Ox"237DF")  : mword 20)) then
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let t : reg_index := uint (Rt) in
     let n : reg_index := uint (Rn) in
     let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
     if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
     then
       None
     else Some ((LoadAcquire ((sf, t, n, Ordering_Acquire))))
   else if eq_vec ((subrange_vec_dec (v__0) (29) (10))) (((Ox"22FF0")  : mword 20)) then
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let t : reg_index := uint (Rt) in
     let n : reg_index := uint (Rn) in
     let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
     if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
     then
       None
     else Some ((LoadAcquire ((sf, t, n, Ordering_AcquireRCpc))))
   else if eq_vec ((subrange_vec_dec (v__0) (29) (10))) (((Ox"227FF")  : mword 20)) then
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let t : reg_index := uint (Rt) in
     let n : reg_index := uint (Rn) in
     let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
     if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
     then
       None
     else Some ((StoreRelease ((sf, t, n))))
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0001010")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (21) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeBitwiseAndRegister (sf) (shift) (N) (Rm) (imm6) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (23))) (((Ox"24")  : mword 8)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (22) in
     let imms : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let immr : bits 6 := subrange_vec_dec (v__0) (21) (16) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeBitwiseAndImmediate (sf) (N) (immr) (imms) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1001010")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (21) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeExclusiveOr (sf) (shift) (N) (Rm) (imm6) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0101010")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (21) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeInclusiveOr (sf) (shift) (N) (Rm) (imm6) (Rn) (Rd)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (21))) ((('b"0101010000")  : mword 10))))
             ((eq_vec ((subrange_vec_dec (v__0) (15) (5))) ((('b"00000011111")  : mword 11)))) then
     let sf := access_vec_dec (v__0) (31) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     let m : reg_index := uint (Rm) in
     Some ((Move ((sf, d, MoveReg (m)))))
   else if eq_vec ((subrange_vec_dec (v__0) (30) (23))) (((Ox"A5")  : mword 8)) then
     let sf := access_vec_dec (v__0) (31) in
     let imm16 : bits 16 := subrange_vec_dec (v__0) (20) (5) in
     let hw : bits 2 := subrange_vec_dec (v__0) (22) (21) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     if andb ((eq_bit (sf) (B0))) ((eq_bit ((access_vec_dec (hw) (1))) (B1))) then None
     else
       Some
         ((Move ((sf, d, MoveImm (({| move_imm_data_imm := imm16;  move_imm_data_hw := hw |}))))))
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0001011")  : mword 7))))
             ((eq_vec ((subrange_vec_dec (v__0) (21) (21))) ((('b"0")  : mword 1)))) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeAddSub (sf) (B0) (B0) (shift) (((Ox"000")  : mword 12)) (imm6) (Rm) (Rn) (Rd)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1001011")  : mword 7))))
             ((eq_vec ((subrange_vec_dec (v__0) (21) (21))) ((('b"0")  : mword 1)))) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeAddSub (sf) (B1) (B0) (shift) (((Ox"000")  : mword 12)) (imm6) (Rm) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0010001")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm12 : bits 12 := subrange_vec_dec (v__0) (21) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeAddSub (sf) (B0) (B1) (shift) (imm12) ((('b"000000")  : mword 6))
       ((('b"00000")
        : mword 5)) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1010001")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm12 : bits 12 := subrange_vec_dec (v__0) (21) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeAddSub (sf) (B1) (B1) (shift) (imm12) ((('b"000000")  : mword 6))
       ((('b"00000")
        : mword 5)) (Rn) (Rd)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1101011")  : mword 7))))
             ((andb ((eq_vec ((subrange_vec_dec (v__0) (21) (21))) ((('b"0")  : mword 1))))
                 ((eq_vec ((subrange_vec_dec (v__0) (4) (0))) ((('b"11111")  : mword 5)))))) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     decodeCompare (sf) (shift) (((Ox"000")  : mword 12)) (imm6) (Rm) (Rn)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1110001")  : mword 7))))
             ((eq_vec ((subrange_vec_dec (v__0) (4) (0))) ((('b"11111")  : mword 5)))) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm12 : bits 12 := subrange_vec_dec (v__0) (21) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     decodeCompare (sf) (shift) (imm12) ((('b"000000")  : mword 6)) ((('b"00000")  : mword 5)) (Rn)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (21))) ((('b"0011010100")  : mword 10))))
             ((eq_vec ((subrange_vec_dec (v__0) (11) (10))) ((('b"00")  : mword 2)))) then
     let sf := access_vec_dec (v__0) (31) in
     let cond : bits 4 := subrange_vec_dec (v__0) (15) (12) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     let n : reg_index := uint (Rn) in
     let m : reg_index := uint (Rm) in
     Some ((ConditionalSelect ((sf, d, n, m, cond))))
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (12))) (((Ox"D5033")  : mword 20))))
             ((eq_vec ((subrange_vec_dec (v__0) (7) (0))) (((Ox"BF")  : mword 8)))) then
     let CRm : bits 4 := subrange_vec_dec (v__0) (11) (8) in
     decodeDataBarrier (CRm) (false)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (12))) (((Ox"D5033")  : mword 20))))
             ((eq_vec ((subrange_vec_dec (v__0) (7) (0))) (((Ox"9F")  : mword 8)))) then
     let CRm : bits 4 := subrange_vec_dec (v__0) (11) (8) in
     decodeDataBarrier (CRm) (true)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (12))) (((Ox"D5033")  : mword 20))))
             ((eq_vec ((subrange_vec_dec (v__0) (7) (0))) (((Ox"DF")  : mword 8)))) then
     Some ((InstructionSynchronizationBarrier (tt)))
   else if eq_vec (v__0) (((Ox"D503201F")  : mword 32)) then Some ((Nop (tt)))
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0110100")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let imm19 : bits 19 := subrange_vec_dec (v__0) (23) (5) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeCompareAndBranch (sf) (B0) (imm19) (Rt)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0110101")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let imm19 : bits 19 := subrange_vec_dec (v__0) (23) (5) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeCompareAndBranch (sf) (B1) (imm19) (Rt)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (23))) (((Ox"A6")  : mword 8)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (22) in
     let imms : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let immr : bits 6 := subrange_vec_dec (v__0) (21) (16) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     let n : reg_index := uint (Rn) in
     let valid_64 :=
       andb ((eq_bit (sf) (B1)))
         ((andb ((eq_bit (N) (B1))) ((eq_vec (imms) ((('b"111111")  : mword 6)))))) in
     let valid_32 :=
       andb ((eq_bit (sf) (B0)))
         ((andb ((eq_bit (N) (B0))) ((eq_vec (imms) ((('b"011111")  : mword 6)))))) in
     if orb (valid_64) (valid_32) then
       Some ((LogicalShiftRight ((sf, d, n, OperandImm ((zero_extend (immr) (12)))))))
     else None
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (21))) ((('b"0011010110")  : mword 10))))
             ((eq_vec ((subrange_vec_dec (v__0) (15) (10))) ((('b"001001")  : mword 6)))) then
     let sf := access_vec_dec (v__0) (31) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     let n : reg_index := uint (Rn) in
     let m : reg_index := uint (Rm) in
     Some ((LogicalShiftRight ((sf, d, n, OperandReg (m)))))
   else if eq_vec ((subrange_vec_dec (v__0) (31) (26))) ((('b"000101")  : mword 6)) then
     let imm26 : bits 26 := subrange_vec_dec (v__0) (25) (0) in
     let offset : bits 64 := sign_extend ((concat_vec (imm26) ((('b"00")  : mword 2)))) (64) in
     Some ((Branch (offset)))
   else None.

Definition fetch_and_execute '(tt : unit) : M (unit) :=
   catch_early_return
     (let accdesc := create_iFetchAccessDescriptor (tt) in
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__0 : mword 64) =>
     match translate_address (w__0) (accdesc) with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 64))  : MR (unit) (mword 64)
     end >>= fun (addr : bits addr_size) =>
     liftR ((iFetch (addr) (accdesc))) >>= fun machineCode =>
     let instr := decode (machineCode) in
     match instr with
     | Some instr => liftR ((execute (instr)))  : MR (unit) (unit)
     | None => liftR (assert_exp' false "Unsupported Encoding") >>= fun _ => liftR (exit tt)
     end
      : MR (unit) (unit)).

Definition initialize_registers '(tt : unit) : M (unit) :=
   (undefined_bitvector (64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC w__0 >>
   (undefined_bitvector (64)) >>= fun (w__1 : mword 64) =>
   write_reg R30 w__1 >>
   (undefined_bitvector (64)) >>= fun (w__2 : mword 64) =>
   write_reg R29 w__2 >>
   (undefined_bitvector (64)) >>= fun (w__3 : mword 64) =>
   write_reg R28 w__3 >>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   write_reg R27 w__4 >>
   (undefined_bitvector (64)) >>= fun (w__5 : mword 64) =>
   write_reg R26 w__5 >>
   (undefined_bitvector (64)) >>= fun (w__6 : mword 64) =>
   write_reg R25 w__6 >>
   (undefined_bitvector (64)) >>= fun (w__7 : mword 64) =>
   write_reg R24 w__7 >>
   (undefined_bitvector (64)) >>= fun (w__8 : mword 64) =>
   write_reg R23 w__8 >>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   write_reg R22 w__9 >>
   (undefined_bitvector (64)) >>= fun (w__10 : mword 64) =>
   write_reg R21 w__10 >>
   (undefined_bitvector (64)) >>= fun (w__11 : mword 64) =>
   write_reg R20 w__11 >>
   (undefined_bitvector (64)) >>= fun (w__12 : mword 64) =>
   write_reg R19 w__12 >>
   (undefined_bitvector (64)) >>= fun (w__13 : mword 64) =>
   write_reg R18 w__13 >>
   (undefined_bitvector (64)) >>= fun (w__14 : mword 64) =>
   write_reg R17 w__14 >>
   (undefined_bitvector (64)) >>= fun (w__15 : mword 64) =>
   write_reg R16 w__15 >>
   (undefined_bitvector (64)) >>= fun (w__16 : mword 64) =>
   write_reg R15 w__16 >>
   (undefined_bitvector (64)) >>= fun (w__17 : mword 64) =>
   write_reg R14 w__17 >>
   (undefined_bitvector (64)) >>= fun (w__18 : mword 64) =>
   write_reg R13 w__18 >>
   (undefined_bitvector (64)) >>= fun (w__19 : mword 64) =>
   write_reg R12 w__19 >>
   (undefined_bitvector (64)) >>= fun (w__20 : mword 64) =>
   write_reg R11 w__20 >>
   (undefined_bitvector (64)) >>= fun (w__21 : mword 64) =>
   write_reg R10 w__21 >>
   (undefined_bitvector (64)) >>= fun (w__22 : mword 64) =>
   write_reg R9 w__22 >>
   (undefined_bitvector (64)) >>= fun (w__23 : mword 64) =>
   write_reg R8 w__23 >>
   (undefined_bitvector (64)) >>= fun (w__24 : mword 64) =>
   write_reg R7 w__24 >>
   (undefined_bitvector (64)) >>= fun (w__25 : mword 64) =>
   write_reg R6 w__25 >>
   (undefined_bitvector (64)) >>= fun (w__26 : mword 64) =>
   write_reg R5 w__26 >>
   (undefined_bitvector (64)) >>= fun (w__27 : mword 64) =>
   write_reg R4 w__27 >>
   (undefined_bitvector (64)) >>= fun (w__28 : mword 64) =>
   write_reg R3 w__28 >>
   (undefined_bitvector (64)) >>= fun (w__29 : mword 64) =>
   write_reg R2 w__29 >>
   (undefined_bitvector (64)) >>= fun (w__30 : mword 64) =>
   write_reg R1 w__30 >>
   (undefined_bitvector (64)) >>= fun (w__31 : mword 64) => write_reg R0 w__31  : M (unit).

Definition sail_model_init (_ : unit) : M (unit) := (initialize_registers (tt))  : M (unit).



