(*Generated by Sail from System.*)


From stdpp Require Import base countable.
Require Eqdep.
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import SailStdpp.ConcurrencyInterfaceTypesV2.
Require Import SailStdpp.ConcurrencyInterfaceV2.
Require Import SailStdpp.ConcurrencyInterfaceBuiltinsV2.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.

Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.

Definition bits (n : Z) : Type := mword n.

Inductive SecurityState := SS_NonSecure | SS_Root | SS_Realm | SS_Secure.
Definition num_of_SecurityState (arg_ : SecurityState) : Z :=
   match arg_ with | SS_NonSecure => 0 | SS_Root => 1 | SS_Realm => 2 | SS_Secure => 3 end.

Definition SecurityState_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : SecurityState :=
   let l__132 := arg_ in
   if Z.eqb (l__132) (0) then SS_NonSecure
   else if Z.eqb (l__132) (1) then SS_Root
   else if Z.eqb (l__132) (2) then SS_Realm
   else SS_Secure.

Lemma SecurityState_num_of_roundtrip (x : SecurityState) : SecurityState_of_num (num_of_SecurityState x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_SecurityState_injective (x y : SecurityState) : num_of_SecurityState x = num_of_SecurityState y -> x = y.
  intro.
  rewrite <- (SecurityState_num_of_roundtrip x).
  rewrite <- (SecurityState_num_of_roundtrip y).
  congruence.
Qed.
Definition SecurityState_eq_dec (x y : SecurityState) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_SecurityState x) (num_of_SecurityState y) with
  | left e => left (num_of_SecurityState_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition SecurityState_beq (x y : SecurityState) : bool :=
  Z.eqb (num_of_SecurityState x) (num_of_SecurityState y).
Lemma SecurityState_beq_iff x y : SecurityState_beq x y = true <-> x = y.
  unfold SecurityState_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_SecurityState_injective | congruence].
Qed.
Lemma SecurityState_beq_refl x : SecurityState_beq x x = true.
apply SecurityState_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_SecurityState : EqDecision SecurityState := SecurityState_eq_dec.
#[export]
Instance Countable_SecurityState : Countable SecurityState.
refine {|
  encode x := encode (num_of_SecurityState x);
  decode x := z ← decode x; mret (SecurityState_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite SecurityState_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_SecurityState : Inhabited SecurityState := { inhabitant := SS_NonSecure }.


Definition PARTIDtype : Type := bits 16.

Definition PMGtype : Type := bits 8.

Inductive PARTIDspaceType := PIdSpace_Secure | PIdSpace_Root | PIdSpace_Realm | PIdSpace_NonSecure.
Definition num_of_PARTIDspaceType (arg_ : PARTIDspaceType) : Z :=
   match arg_ with
   | PIdSpace_Secure => 0
   | PIdSpace_Root => 1
   | PIdSpace_Realm => 2
   | PIdSpace_NonSecure => 3
   end.

Definition PARTIDspaceType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : PARTIDspaceType :=
   let l__129 := arg_ in
   if Z.eqb (l__129) (0) then PIdSpace_Secure
   else if Z.eqb (l__129) (1) then PIdSpace_Root
   else if Z.eqb (l__129) (2) then PIdSpace_Realm
   else PIdSpace_NonSecure.

Lemma PARTIDspaceType_num_of_roundtrip (x : PARTIDspaceType) : PARTIDspaceType_of_num (num_of_PARTIDspaceType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_PARTIDspaceType_injective (x y : PARTIDspaceType) : num_of_PARTIDspaceType x = num_of_PARTIDspaceType y -> x = y.
  intro.
  rewrite <- (PARTIDspaceType_num_of_roundtrip x).
  rewrite <- (PARTIDspaceType_num_of_roundtrip y).
  congruence.
Qed.
Definition PARTIDspaceType_eq_dec (x y : PARTIDspaceType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_PARTIDspaceType x) (num_of_PARTIDspaceType y) with
  | left e => left (num_of_PARTIDspaceType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition PARTIDspaceType_beq (x y : PARTIDspaceType) : bool :=
  Z.eqb (num_of_PARTIDspaceType x) (num_of_PARTIDspaceType y).
Lemma PARTIDspaceType_beq_iff x y : PARTIDspaceType_beq x y = true <-> x = y.
  unfold PARTIDspaceType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_PARTIDspaceType_injective | congruence].
Qed.
Lemma PARTIDspaceType_beq_refl x : PARTIDspaceType_beq x x = true.
apply PARTIDspaceType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_PARTIDspaceType : EqDecision PARTIDspaceType := PARTIDspaceType_eq_dec.
#[export]
Instance Countable_PARTIDspaceType : Countable PARTIDspaceType.
refine {|
  encode x := encode (num_of_PARTIDspaceType x);
  decode x := z ← decode x; mret (PARTIDspaceType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite PARTIDspaceType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_PARTIDspaceType : Inhabited PARTIDspaceType := { inhabitant := PIdSpace_Secure }.


Record MPAMinfo := {
  MPAMinfo_mpam_sp : PARTIDspaceType;
  MPAMinfo_partid : PARTIDtype;
  MPAMinfo_pmg : PMGtype;
}.
Arguments MPAMinfo : clear implicits.
#[export]
Instance Decidable_eq_MPAMinfo : EqDecision MPAMinfo.
   intros [x0 x1 x2].
   intros [y0 y1 y2].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_MPAMinfo : Countable MPAMinfo.
refine {|
  encode x := encode (MPAMinfo_mpam_sp x, MPAMinfo_partid x, MPAMinfo_pmg x);
  decode x := '(x0, x1, x2) ← decode x;
              mret (Build_MPAMinfo x0 x1 x2)
|}.
abstract (
  intros [x0 x1 x2];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_MPAMinfo : Settable _ := settable! Build_MPAMinfo <MPAMinfo_mpam_sp; MPAMinfo_partid; MPAMinfo_pmg>.
#[export]
Instance dummy_MPAMinfo : Inhabited (MPAMinfo) := {
  inhabitant := {|
    MPAMinfo_mpam_sp := inhabitant;
    MPAMinfo_partid := inhabitant;
    MPAMinfo_pmg := inhabitant
|} }.


Inductive AccessType :=
  | AccessType_IFETCH
  | AccessType_GPR
  | AccessType_ASIMD
  | AccessType_SVE
  | AccessType_SME
  | AccessType_IC
  | AccessType_DC
  | AccessType_DCZero
  | AccessType_AT
  | AccessType_NV2
  | AccessType_SPE
  | AccessType_GCS
  | AccessType_GPTW
  | AccessType_TTW.
Definition num_of_AccessType (arg_ : AccessType) : Z :=
   match arg_ with
   | AccessType_IFETCH => 0
   | AccessType_GPR => 1
   | AccessType_ASIMD => 2
   | AccessType_SVE => 3
   | AccessType_SME => 4
   | AccessType_IC => 5
   | AccessType_DC => 6
   | AccessType_DCZero => 7
   | AccessType_AT => 8
   | AccessType_NV2 => 9
   | AccessType_SPE => 10
   | AccessType_GCS => 11
   | AccessType_GPTW => 12
   | AccessType_TTW => 13
   end.

Definition AccessType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 13)*) : AccessType :=
   let l__116 := arg_ in
   if Z.eqb (l__116) (0) then AccessType_IFETCH
   else if Z.eqb (l__116) (1) then AccessType_GPR
   else if Z.eqb (l__116) (2) then AccessType_ASIMD
   else if Z.eqb (l__116) (3) then AccessType_SVE
   else if Z.eqb (l__116) (4) then AccessType_SME
   else if Z.eqb (l__116) (5) then AccessType_IC
   else if Z.eqb (l__116) (6) then AccessType_DC
   else if Z.eqb (l__116) (7) then AccessType_DCZero
   else if Z.eqb (l__116) (8) then AccessType_AT
   else if Z.eqb (l__116) (9) then AccessType_NV2
   else if Z.eqb (l__116) (10) then AccessType_SPE
   else if Z.eqb (l__116) (11) then AccessType_GCS
   else if Z.eqb (l__116) (12) then AccessType_GPTW
   else AccessType_TTW.

Lemma AccessType_num_of_roundtrip (x : AccessType) : AccessType_of_num (num_of_AccessType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_AccessType_injective (x y : AccessType) : num_of_AccessType x = num_of_AccessType y -> x = y.
  intro.
  rewrite <- (AccessType_num_of_roundtrip x).
  rewrite <- (AccessType_num_of_roundtrip y).
  congruence.
Qed.
Definition AccessType_eq_dec (x y : AccessType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_AccessType x) (num_of_AccessType y) with
  | left e => left (num_of_AccessType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition AccessType_beq (x y : AccessType) : bool :=
  Z.eqb (num_of_AccessType x) (num_of_AccessType y).
Lemma AccessType_beq_iff x y : AccessType_beq x y = true <-> x = y.
  unfold AccessType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_AccessType_injective | congruence].
Qed.
Lemma AccessType_beq_refl x : AccessType_beq x x = true.
apply AccessType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_AccessType : EqDecision AccessType := AccessType_eq_dec.
#[export]
Instance Countable_AccessType : Countable AccessType.
refine {|
  encode x := encode (num_of_AccessType x);
  decode x := z ← decode x; mret (AccessType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite AccessType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_AccessType : Inhabited AccessType := { inhabitant := AccessType_IFETCH }.


Inductive VARange := VARange_LOWER | VARange_UPPER.
Definition num_of_VARange (arg_ : VARange) : Z :=
   match arg_ with | VARange_LOWER => 0 | VARange_UPPER => 1 end.

Definition VARange_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : VARange :=
   let l__115 := arg_ in
   if Z.eqb (l__115) (0) then VARange_LOWER
   else VARange_UPPER.

Lemma VARange_num_of_roundtrip (x : VARange) : VARange_of_num (num_of_VARange x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_VARange_injective (x y : VARange) : num_of_VARange x = num_of_VARange y -> x = y.
  intro.
  rewrite <- (VARange_num_of_roundtrip x).
  rewrite <- (VARange_num_of_roundtrip y).
  congruence.
Qed.
Definition VARange_eq_dec (x y : VARange) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_VARange x) (num_of_VARange y) with
  | left e => left (num_of_VARange_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition VARange_beq (x y : VARange) : bool :=
  Z.eqb (num_of_VARange x) (num_of_VARange y).
Lemma VARange_beq_iff x y : VARange_beq x y = true <-> x = y.
  unfold VARange_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_VARange_injective | congruence].
Qed.
Lemma VARange_beq_refl x : VARange_beq x x = true.
apply VARange_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_VARange : EqDecision VARange := VARange_eq_dec.
#[export]
Instance Countable_VARange : Countable VARange.
refine {|
  encode x := encode (num_of_VARange x);
  decode x := z ← decode x; mret (VARange_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite VARange_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_VARange : Inhabited VARange := { inhabitant := VARange_LOWER }.


Inductive MemAtomicOp :=
  | MemAtomicOp_GCSSS1
  | MemAtomicOp_ADD
  | MemAtomicOp_BIC
  | MemAtomicOp_EOR
  | MemAtomicOp_ORR
  | MemAtomicOp_SMAX
  | MemAtomicOp_SMIN
  | MemAtomicOp_UMAX
  | MemAtomicOp_UMIN
  | MemAtomicOp_SWP
  | MemAtomicOp_CAS.
Definition num_of_MemAtomicOp (arg_ : MemAtomicOp) : Z :=
   match arg_ with
   | MemAtomicOp_GCSSS1 => 0
   | MemAtomicOp_ADD => 1
   | MemAtomicOp_BIC => 2
   | MemAtomicOp_EOR => 3
   | MemAtomicOp_ORR => 4
   | MemAtomicOp_SMAX => 5
   | MemAtomicOp_SMIN => 6
   | MemAtomicOp_UMAX => 7
   | MemAtomicOp_UMIN => 8
   | MemAtomicOp_SWP => 9
   | MemAtomicOp_CAS => 10
   end.

Definition MemAtomicOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 10)*) : MemAtomicOp :=
   let l__105 := arg_ in
   if Z.eqb (l__105) (0) then MemAtomicOp_GCSSS1
   else if Z.eqb (l__105) (1) then MemAtomicOp_ADD
   else if Z.eqb (l__105) (2) then MemAtomicOp_BIC
   else if Z.eqb (l__105) (3) then MemAtomicOp_EOR
   else if Z.eqb (l__105) (4) then MemAtomicOp_ORR
   else if Z.eqb (l__105) (5) then MemAtomicOp_SMAX
   else if Z.eqb (l__105) (6) then MemAtomicOp_SMIN
   else if Z.eqb (l__105) (7) then MemAtomicOp_UMAX
   else if Z.eqb (l__105) (8) then MemAtomicOp_UMIN
   else if Z.eqb (l__105) (9) then MemAtomicOp_SWP
   else MemAtomicOp_CAS.

Lemma MemAtomicOp_num_of_roundtrip (x : MemAtomicOp) : MemAtomicOp_of_num (num_of_MemAtomicOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MemAtomicOp_injective (x y : MemAtomicOp) : num_of_MemAtomicOp x = num_of_MemAtomicOp y -> x = y.
  intro.
  rewrite <- (MemAtomicOp_num_of_roundtrip x).
  rewrite <- (MemAtomicOp_num_of_roundtrip y).
  congruence.
Qed.
Definition MemAtomicOp_eq_dec (x y : MemAtomicOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MemAtomicOp x) (num_of_MemAtomicOp y) with
  | left e => left (num_of_MemAtomicOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MemAtomicOp_beq (x y : MemAtomicOp) : bool :=
  Z.eqb (num_of_MemAtomicOp x) (num_of_MemAtomicOp y).
Lemma MemAtomicOp_beq_iff x y : MemAtomicOp_beq x y = true <-> x = y.
  unfold MemAtomicOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MemAtomicOp_injective | congruence].
Qed.
Lemma MemAtomicOp_beq_refl x : MemAtomicOp_beq x x = true.
apply MemAtomicOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MemAtomicOp : EqDecision MemAtomicOp := MemAtomicOp_eq_dec.
#[export]
Instance Countable_MemAtomicOp : Countable MemAtomicOp.
refine {|
  encode x := encode (num_of_MemAtomicOp x);
  decode x := z ← decode x; mret (MemAtomicOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MemAtomicOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MemAtomicOp : Inhabited MemAtomicOp := { inhabitant := MemAtomicOp_GCSSS1 }.


Inductive CacheOp := CacheOp_Clean | CacheOp_Invalidate | CacheOp_CleanInvalidate.
Definition num_of_CacheOp (arg_ : CacheOp) : Z :=
   match arg_ with | CacheOp_Clean => 0 | CacheOp_Invalidate => 1 | CacheOp_CleanInvalidate => 2 end.

Definition CacheOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : CacheOp :=
   let l__103 := arg_ in
   if Z.eqb (l__103) (0) then CacheOp_Clean
   else if Z.eqb (l__103) (1) then CacheOp_Invalidate
   else CacheOp_CleanInvalidate.

Lemma CacheOp_num_of_roundtrip (x : CacheOp) : CacheOp_of_num (num_of_CacheOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_CacheOp_injective (x y : CacheOp) : num_of_CacheOp x = num_of_CacheOp y -> x = y.
  intro.
  rewrite <- (CacheOp_num_of_roundtrip x).
  rewrite <- (CacheOp_num_of_roundtrip y).
  congruence.
Qed.
Definition CacheOp_eq_dec (x y : CacheOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_CacheOp x) (num_of_CacheOp y) with
  | left e => left (num_of_CacheOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition CacheOp_beq (x y : CacheOp) : bool :=
  Z.eqb (num_of_CacheOp x) (num_of_CacheOp y).
Lemma CacheOp_beq_iff x y : CacheOp_beq x y = true <-> x = y.
  unfold CacheOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_CacheOp_injective | congruence].
Qed.
Lemma CacheOp_beq_refl x : CacheOp_beq x x = true.
apply CacheOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_CacheOp : EqDecision CacheOp := CacheOp_eq_dec.
#[export]
Instance Countable_CacheOp : Countable CacheOp.
refine {|
  encode x := encode (num_of_CacheOp x);
  decode x := z ← decode x; mret (CacheOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite CacheOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_CacheOp : Inhabited CacheOp := { inhabitant := CacheOp_Clean }.


Inductive CacheOpScope :=
  | CacheOpScope_SetWay
  | CacheOpScope_PoU
  | CacheOpScope_PoC
  | CacheOpScope_PoE
  | CacheOpScope_PoP
  | CacheOpScope_PoDP
  | CacheOpScope_PoPA
  | CacheOpScope_ALLU
  | CacheOpScope_ALLUIS.
Definition num_of_CacheOpScope (arg_ : CacheOpScope) : Z :=
   match arg_ with
   | CacheOpScope_SetWay => 0
   | CacheOpScope_PoU => 1
   | CacheOpScope_PoC => 2
   | CacheOpScope_PoE => 3
   | CacheOpScope_PoP => 4
   | CacheOpScope_PoDP => 5
   | CacheOpScope_PoPA => 6
   | CacheOpScope_ALLU => 7
   | CacheOpScope_ALLUIS => 8
   end.

Definition CacheOpScope_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 8)*) : CacheOpScope :=
   let l__95 := arg_ in
   if Z.eqb (l__95) (0) then CacheOpScope_SetWay
   else if Z.eqb (l__95) (1) then CacheOpScope_PoU
   else if Z.eqb (l__95) (2) then CacheOpScope_PoC
   else if Z.eqb (l__95) (3) then CacheOpScope_PoE
   else if Z.eqb (l__95) (4) then CacheOpScope_PoP
   else if Z.eqb (l__95) (5) then CacheOpScope_PoDP
   else if Z.eqb (l__95) (6) then CacheOpScope_PoPA
   else if Z.eqb (l__95) (7) then CacheOpScope_ALLU
   else CacheOpScope_ALLUIS.

Lemma CacheOpScope_num_of_roundtrip (x : CacheOpScope) : CacheOpScope_of_num (num_of_CacheOpScope x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_CacheOpScope_injective (x y : CacheOpScope) : num_of_CacheOpScope x = num_of_CacheOpScope y -> x = y.
  intro.
  rewrite <- (CacheOpScope_num_of_roundtrip x).
  rewrite <- (CacheOpScope_num_of_roundtrip y).
  congruence.
Qed.
Definition CacheOpScope_eq_dec (x y : CacheOpScope) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_CacheOpScope x) (num_of_CacheOpScope y) with
  | left e => left (num_of_CacheOpScope_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition CacheOpScope_beq (x y : CacheOpScope) : bool :=
  Z.eqb (num_of_CacheOpScope x) (num_of_CacheOpScope y).
Lemma CacheOpScope_beq_iff x y : CacheOpScope_beq x y = true <-> x = y.
  unfold CacheOpScope_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_CacheOpScope_injective | congruence].
Qed.
Lemma CacheOpScope_beq_refl x : CacheOpScope_beq x x = true.
apply CacheOpScope_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_CacheOpScope : EqDecision CacheOpScope := CacheOpScope_eq_dec.
#[export]
Instance Countable_CacheOpScope : Countable CacheOpScope.
refine {|
  encode x := encode (num_of_CacheOpScope x);
  decode x := z ← decode x; mret (CacheOpScope_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite CacheOpScope_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_CacheOpScope : Inhabited CacheOpScope := { inhabitant := CacheOpScope_SetWay }.


Inductive CacheType := CacheType_Data | CacheType_Tag | CacheType_Data_Tag | CacheType_Instruction.
Definition num_of_CacheType (arg_ : CacheType) : Z :=
   match arg_ with
   | CacheType_Data => 0
   | CacheType_Tag => 1
   | CacheType_Data_Tag => 2
   | CacheType_Instruction => 3
   end.

Definition CacheType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : CacheType :=
   let l__92 := arg_ in
   if Z.eqb (l__92) (0) then CacheType_Data
   else if Z.eqb (l__92) (1) then CacheType_Tag
   else if Z.eqb (l__92) (2) then CacheType_Data_Tag
   else CacheType_Instruction.

Lemma CacheType_num_of_roundtrip (x : CacheType) : CacheType_of_num (num_of_CacheType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_CacheType_injective (x y : CacheType) : num_of_CacheType x = num_of_CacheType y -> x = y.
  intro.
  rewrite <- (CacheType_num_of_roundtrip x).
  rewrite <- (CacheType_num_of_roundtrip y).
  congruence.
Qed.
Definition CacheType_eq_dec (x y : CacheType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_CacheType x) (num_of_CacheType y) with
  | left e => left (num_of_CacheType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition CacheType_beq (x y : CacheType) : bool :=
  Z.eqb (num_of_CacheType x) (num_of_CacheType y).
Lemma CacheType_beq_iff x y : CacheType_beq x y = true <-> x = y.
  unfold CacheType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_CacheType_injective | congruence].
Qed.
Lemma CacheType_beq_refl x : CacheType_beq x x = true.
apply CacheType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_CacheType : EqDecision CacheType := CacheType_eq_dec.
#[export]
Instance Countable_CacheType : Countable CacheType.
refine {|
  encode x := encode (num_of_CacheType x);
  decode x := z ← decode x; mret (CacheType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite CacheType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_CacheType : Inhabited CacheType := { inhabitant := CacheType_Data }.


Inductive CachePASpace :=
  | CPAS_NonSecure
  | CPAS_Any
  | CPAS_RealmNonSecure
  | CPAS_Realm
  | CPAS_Root
  | CPAS_SecureNonSecure
  | CPAS_Secure.
Definition num_of_CachePASpace (arg_ : CachePASpace) : Z :=
   match arg_ with
   | CPAS_NonSecure => 0
   | CPAS_Any => 1
   | CPAS_RealmNonSecure => 2
   | CPAS_Realm => 3
   | CPAS_Root => 4
   | CPAS_SecureNonSecure => 5
   | CPAS_Secure => 6
   end.

Definition CachePASpace_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 6)*) : CachePASpace :=
   let l__86 := arg_ in
   if Z.eqb (l__86) (0) then CPAS_NonSecure
   else if Z.eqb (l__86) (1) then CPAS_Any
   else if Z.eqb (l__86) (2) then CPAS_RealmNonSecure
   else if Z.eqb (l__86) (3) then CPAS_Realm
   else if Z.eqb (l__86) (4) then CPAS_Root
   else if Z.eqb (l__86) (5) then CPAS_SecureNonSecure
   else CPAS_Secure.

Lemma CachePASpace_num_of_roundtrip (x : CachePASpace) : CachePASpace_of_num (num_of_CachePASpace x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_CachePASpace_injective (x y : CachePASpace) : num_of_CachePASpace x = num_of_CachePASpace y -> x = y.
  intro.
  rewrite <- (CachePASpace_num_of_roundtrip x).
  rewrite <- (CachePASpace_num_of_roundtrip y).
  congruence.
Qed.
Definition CachePASpace_eq_dec (x y : CachePASpace) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_CachePASpace x) (num_of_CachePASpace y) with
  | left e => left (num_of_CachePASpace_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition CachePASpace_beq (x y : CachePASpace) : bool :=
  Z.eqb (num_of_CachePASpace x) (num_of_CachePASpace y).
Lemma CachePASpace_beq_iff x y : CachePASpace_beq x y = true <-> x = y.
  unfold CachePASpace_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_CachePASpace_injective | congruence].
Qed.
Lemma CachePASpace_beq_refl x : CachePASpace_beq x x = true.
apply CachePASpace_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_CachePASpace : EqDecision CachePASpace := CachePASpace_eq_dec.
#[export]
Instance Countable_CachePASpace : Countable CachePASpace.
refine {|
  encode x := encode (num_of_CachePASpace x);
  decode x := z ← decode x; mret (CachePASpace_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite CachePASpace_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_CachePASpace : Inhabited CachePASpace := { inhabitant := CPAS_NonSecure }.


Record AccessDescriptor := {
  AccessDescriptor_acctype : AccessType;
  AccessDescriptor_el : bits 2;
  AccessDescriptor_ss : SecurityState;
  AccessDescriptor_acqsc : bool;
  AccessDescriptor_acqpc : bool;
  AccessDescriptor_relsc : bool;
  AccessDescriptor_limitedordered : bool;
  AccessDescriptor_exclusive : bool;
  AccessDescriptor_atomicop : bool;
  AccessDescriptor_modop : MemAtomicOp;
  AccessDescriptor_nontemporal : bool;
  AccessDescriptor_read : bool;
  AccessDescriptor_write : bool;
  AccessDescriptor_cacheop : CacheOp;
  AccessDescriptor_opscope : CacheOpScope;
  AccessDescriptor_cachetype : CacheType;
  AccessDescriptor_pan : bool;
  AccessDescriptor_transactional : bool;
  AccessDescriptor_nonfault : bool;
  AccessDescriptor_firstfault : bool;
  AccessDescriptor_first : bool;
  AccessDescriptor_contiguous : bool;
  AccessDescriptor_streamingsve : bool;
  AccessDescriptor_ls64 : bool;
  AccessDescriptor_mops : bool;
  AccessDescriptor_rcw : bool;
  AccessDescriptor_rcws : bool;
  AccessDescriptor_toplevel : bool;
  AccessDescriptor_varange : VARange;
  AccessDescriptor_a32lsmd : bool;
  AccessDescriptor_tagchecked : bool;
  AccessDescriptor_tagaccess : bool;
  AccessDescriptor_mpam : MPAMinfo;
}.
Arguments AccessDescriptor : clear implicits.
#[export]
Instance Decidable_eq_AccessDescriptor : EqDecision AccessDescriptor.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16 y17 y18 y19 y20 y21 y22 y23 y24 y25 y26 y27 y28 y29 y30 y31 y32].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
  cmp_record_field x15 y15.
  cmp_record_field x16 y16.
  cmp_record_field x17 y17.
  cmp_record_field x18 y18.
  cmp_record_field x19 y19.
  cmp_record_field x20 y20.
  cmp_record_field x21 y21.
  cmp_record_field x22 y22.
  cmp_record_field x23 y23.
  cmp_record_field x24 y24.
  cmp_record_field x25 y25.
  cmp_record_field x26 y26.
  cmp_record_field x27 y27.
  cmp_record_field x28 y28.
  cmp_record_field x29 y29.
  cmp_record_field x30 y30.
  cmp_record_field x31 y31.
  cmp_record_field x32 y32.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_AccessDescriptor : Countable AccessDescriptor.
refine {|
  encode x := encode (AccessDescriptor_acctype x, AccessDescriptor_el x, AccessDescriptor_ss x, AccessDescriptor_acqsc x, AccessDescriptor_acqpc x, AccessDescriptor_relsc x, AccessDescriptor_limitedordered x, AccessDescriptor_exclusive x, AccessDescriptor_atomicop x, AccessDescriptor_modop x, AccessDescriptor_nontemporal x, AccessDescriptor_read x, AccessDescriptor_write x, AccessDescriptor_cacheop x, AccessDescriptor_opscope x, AccessDescriptor_cachetype x, AccessDescriptor_pan x, AccessDescriptor_transactional x, AccessDescriptor_nonfault x, AccessDescriptor_firstfault x, AccessDescriptor_first x, AccessDescriptor_contiguous x, AccessDescriptor_streamingsve x, AccessDescriptor_ls64 x, AccessDescriptor_mops x, AccessDescriptor_rcw x, AccessDescriptor_rcws x, AccessDescriptor_toplevel x, AccessDescriptor_varange x, AccessDescriptor_a32lsmd x, AccessDescriptor_tagchecked x, AccessDescriptor_tagaccess x, AccessDescriptor_mpam x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32) ← decode x;
              mret (Build_AccessDescriptor x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_AccessDescriptor : Settable _ := settable! Build_AccessDescriptor <AccessDescriptor_acctype; AccessDescriptor_el; AccessDescriptor_ss; AccessDescriptor_acqsc; AccessDescriptor_acqpc; AccessDescriptor_relsc; AccessDescriptor_limitedordered; AccessDescriptor_exclusive; AccessDescriptor_atomicop; AccessDescriptor_modop; AccessDescriptor_nontemporal; AccessDescriptor_read; AccessDescriptor_write; AccessDescriptor_cacheop; AccessDescriptor_opscope; AccessDescriptor_cachetype; AccessDescriptor_pan; AccessDescriptor_transactional; AccessDescriptor_nonfault; AccessDescriptor_firstfault; AccessDescriptor_first; AccessDescriptor_contiguous; AccessDescriptor_streamingsve; AccessDescriptor_ls64; AccessDescriptor_mops; AccessDescriptor_rcw; AccessDescriptor_rcws; AccessDescriptor_toplevel; AccessDescriptor_varange; AccessDescriptor_a32lsmd; AccessDescriptor_tagchecked; AccessDescriptor_tagaccess; AccessDescriptor_mpam>.
#[export]
Instance dummy_AccessDescriptor : Inhabited (AccessDescriptor) := {
  inhabitant := {|
    AccessDescriptor_acctype := inhabitant;
    AccessDescriptor_el := inhabitant;
    AccessDescriptor_ss := inhabitant;
    AccessDescriptor_acqsc := inhabitant;
    AccessDescriptor_acqpc := inhabitant;
    AccessDescriptor_relsc := inhabitant;
    AccessDescriptor_limitedordered := inhabitant;
    AccessDescriptor_exclusive := inhabitant;
    AccessDescriptor_atomicop := inhabitant;
    AccessDescriptor_modop := inhabitant;
    AccessDescriptor_nontemporal := inhabitant;
    AccessDescriptor_read := inhabitant;
    AccessDescriptor_write := inhabitant;
    AccessDescriptor_cacheop := inhabitant;
    AccessDescriptor_opscope := inhabitant;
    AccessDescriptor_cachetype := inhabitant;
    AccessDescriptor_pan := inhabitant;
    AccessDescriptor_transactional := inhabitant;
    AccessDescriptor_nonfault := inhabitant;
    AccessDescriptor_firstfault := inhabitant;
    AccessDescriptor_first := inhabitant;
    AccessDescriptor_contiguous := inhabitant;
    AccessDescriptor_streamingsve := inhabitant;
    AccessDescriptor_ls64 := inhabitant;
    AccessDescriptor_mops := inhabitant;
    AccessDescriptor_rcw := inhabitant;
    AccessDescriptor_rcws := inhabitant;
    AccessDescriptor_toplevel := inhabitant;
    AccessDescriptor_varange := inhabitant;
    AccessDescriptor_a32lsmd := inhabitant;
    AccessDescriptor_tagchecked := inhabitant;
    AccessDescriptor_tagaccess := inhabitant;
    AccessDescriptor_mpam := inhabitant
|} }.


Inductive MemType := MemType_Normal | MemType_Device.
Definition num_of_MemType (arg_ : MemType) : Z :=
   match arg_ with | MemType_Normal => 0 | MemType_Device => 1 end.

Definition MemType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : MemType :=
   let l__85 := arg_ in
   if Z.eqb (l__85) (0) then MemType_Normal
   else MemType_Device.

Lemma MemType_num_of_roundtrip (x : MemType) : MemType_of_num (num_of_MemType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MemType_injective (x y : MemType) : num_of_MemType x = num_of_MemType y -> x = y.
  intro.
  rewrite <- (MemType_num_of_roundtrip x).
  rewrite <- (MemType_num_of_roundtrip y).
  congruence.
Qed.
Definition MemType_eq_dec (x y : MemType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MemType x) (num_of_MemType y) with
  | left e => left (num_of_MemType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MemType_beq (x y : MemType) : bool :=
  Z.eqb (num_of_MemType x) (num_of_MemType y).
Lemma MemType_beq_iff x y : MemType_beq x y = true <-> x = y.
  unfold MemType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MemType_injective | congruence].
Qed.
Lemma MemType_beq_refl x : MemType_beq x x = true.
apply MemType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MemType : EqDecision MemType := MemType_eq_dec.
#[export]
Instance Countable_MemType : Countable MemType.
refine {|
  encode x := encode (num_of_MemType x);
  decode x := z ← decode x; mret (MemType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MemType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MemType : Inhabited MemType := { inhabitant := MemType_Normal }.


Inductive DeviceType := DeviceType_GRE | DeviceType_nGRE | DeviceType_nGnRE | DeviceType_nGnRnE.
Definition num_of_DeviceType (arg_ : DeviceType) : Z :=
   match arg_ with
   | DeviceType_GRE => 0
   | DeviceType_nGRE => 1
   | DeviceType_nGnRE => 2
   | DeviceType_nGnRnE => 3
   end.

Definition DeviceType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : DeviceType :=
   let l__82 := arg_ in
   if Z.eqb (l__82) (0) then DeviceType_GRE
   else if Z.eqb (l__82) (1) then DeviceType_nGRE
   else if Z.eqb (l__82) (2) then DeviceType_nGnRE
   else DeviceType_nGnRnE.

Lemma DeviceType_num_of_roundtrip (x : DeviceType) : DeviceType_of_num (num_of_DeviceType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_DeviceType_injective (x y : DeviceType) : num_of_DeviceType x = num_of_DeviceType y -> x = y.
  intro.
  rewrite <- (DeviceType_num_of_roundtrip x).
  rewrite <- (DeviceType_num_of_roundtrip y).
  congruence.
Qed.
Definition DeviceType_eq_dec (x y : DeviceType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_DeviceType x) (num_of_DeviceType y) with
  | left e => left (num_of_DeviceType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition DeviceType_beq (x y : DeviceType) : bool :=
  Z.eqb (num_of_DeviceType x) (num_of_DeviceType y).
Lemma DeviceType_beq_iff x y : DeviceType_beq x y = true <-> x = y.
  unfold DeviceType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_DeviceType_injective | congruence].
Qed.
Lemma DeviceType_beq_refl x : DeviceType_beq x x = true.
apply DeviceType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_DeviceType : EqDecision DeviceType := DeviceType_eq_dec.
#[export]
Instance Countable_DeviceType : Countable DeviceType.
refine {|
  encode x := encode (num_of_DeviceType x);
  decode x := z ← decode x; mret (DeviceType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite DeviceType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_DeviceType : Inhabited DeviceType := { inhabitant := DeviceType_GRE }.


Record MemAttrHints := {
  MemAttrHints_attrs : bits 2;
  MemAttrHints_hints : bits 2;
  MemAttrHints_transient : bool;
}.
Arguments MemAttrHints : clear implicits.
#[export]
Instance Decidable_eq_MemAttrHints : EqDecision MemAttrHints.
   intros [x0 x1 x2].
   intros [y0 y1 y2].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_MemAttrHints : Countable MemAttrHints.
refine {|
  encode x := encode (MemAttrHints_attrs x, MemAttrHints_hints x, MemAttrHints_transient x);
  decode x := '(x0, x1, x2) ← decode x;
              mret (Build_MemAttrHints x0 x1 x2)
|}.
abstract (
  intros [x0 x1 x2];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_MemAttrHints : Settable _ := settable! Build_MemAttrHints <MemAttrHints_attrs; MemAttrHints_hints; MemAttrHints_transient>.
#[export]
Instance dummy_MemAttrHints : Inhabited (MemAttrHints) := {
  inhabitant := {|
    MemAttrHints_attrs := inhabitant;
    MemAttrHints_hints := inhabitant;
    MemAttrHints_transient := inhabitant
|} }.


Inductive Shareability := Shareability_NSH | Shareability_ISH | Shareability_OSH.
Definition num_of_Shareability (arg_ : Shareability) : Z :=
   match arg_ with | Shareability_NSH => 0 | Shareability_ISH => 1 | Shareability_OSH => 2 end.

Definition Shareability_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : Shareability :=
   let l__80 := arg_ in
   if Z.eqb (l__80) (0) then Shareability_NSH
   else if Z.eqb (l__80) (1) then Shareability_ISH
   else Shareability_OSH.

Lemma Shareability_num_of_roundtrip (x : Shareability) : Shareability_of_num (num_of_Shareability x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_Shareability_injective (x y : Shareability) : num_of_Shareability x = num_of_Shareability y -> x = y.
  intro.
  rewrite <- (Shareability_num_of_roundtrip x).
  rewrite <- (Shareability_num_of_roundtrip y).
  congruence.
Qed.
Definition Shareability_eq_dec (x y : Shareability) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_Shareability x) (num_of_Shareability y) with
  | left e => left (num_of_Shareability_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition Shareability_beq (x y : Shareability) : bool :=
  Z.eqb (num_of_Shareability x) (num_of_Shareability y).
Lemma Shareability_beq_iff x y : Shareability_beq x y = true <-> x = y.
  unfold Shareability_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_Shareability_injective | congruence].
Qed.
Lemma Shareability_beq_refl x : Shareability_beq x x = true.
apply Shareability_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_Shareability : EqDecision Shareability := Shareability_eq_dec.
#[export]
Instance Countable_Shareability : Countable Shareability.
refine {|
  encode x := encode (num_of_Shareability x);
  decode x := z ← decode x; mret (Shareability_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite Shareability_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_Shareability : Inhabited Shareability := { inhabitant := Shareability_NSH }.


Inductive MemTagType := MemTag_Untagged | MemTag_AllocationTagged | MemTag_CanonicallyTagged.
Definition num_of_MemTagType (arg_ : MemTagType) : Z :=
   match arg_ with
   | MemTag_Untagged => 0
   | MemTag_AllocationTagged => 1
   | MemTag_CanonicallyTagged => 2
   end.

Definition MemTagType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : MemTagType :=
   let l__78 := arg_ in
   if Z.eqb (l__78) (0) then MemTag_Untagged
   else if Z.eqb (l__78) (1) then MemTag_AllocationTagged
   else MemTag_CanonicallyTagged.

Lemma MemTagType_num_of_roundtrip (x : MemTagType) : MemTagType_of_num (num_of_MemTagType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MemTagType_injective (x y : MemTagType) : num_of_MemTagType x = num_of_MemTagType y -> x = y.
  intro.
  rewrite <- (MemTagType_num_of_roundtrip x).
  rewrite <- (MemTagType_num_of_roundtrip y).
  congruence.
Qed.
Definition MemTagType_eq_dec (x y : MemTagType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MemTagType x) (num_of_MemTagType y) with
  | left e => left (num_of_MemTagType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MemTagType_beq (x y : MemTagType) : bool :=
  Z.eqb (num_of_MemTagType x) (num_of_MemTagType y).
Lemma MemTagType_beq_iff x y : MemTagType_beq x y = true <-> x = y.
  unfold MemTagType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MemTagType_injective | congruence].
Qed.
Lemma MemTagType_beq_refl x : MemTagType_beq x x = true.
apply MemTagType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MemTagType : EqDecision MemTagType := MemTagType_eq_dec.
#[export]
Instance Countable_MemTagType : Countable MemTagType.
refine {|
  encode x := encode (num_of_MemTagType x);
  decode x := z ← decode x; mret (MemTagType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MemTagType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MemTagType : Inhabited MemTagType := { inhabitant := MemTag_Untagged }.


Record MemoryAttributes := {
  MemoryAttributes_memtype : MemType;
  MemoryAttributes_device : DeviceType;
  MemoryAttributes_inner : MemAttrHints;
  MemoryAttributes_outer : MemAttrHints;
  MemoryAttributes_shareability : Shareability;
  MemoryAttributes_tags : MemTagType;
  MemoryAttributes_notagaccess : bool;
  MemoryAttributes_xs : bits 1;
}.
Arguments MemoryAttributes : clear implicits.
#[export]
Instance Decidable_eq_MemoryAttributes : EqDecision MemoryAttributes.
   intros [x0 x1 x2 x3 x4 x5 x6 x7].
   intros [y0 y1 y2 y3 y4 y5 y6 y7].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_MemoryAttributes : Countable MemoryAttributes.
refine {|
  encode x := encode (MemoryAttributes_memtype x, MemoryAttributes_device x, MemoryAttributes_inner x, MemoryAttributes_outer x, MemoryAttributes_shareability x, MemoryAttributes_tags x, MemoryAttributes_notagaccess x, MemoryAttributes_xs x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7) ← decode x;
              mret (Build_MemoryAttributes x0 x1 x2 x3 x4 x5 x6 x7)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_MemoryAttributes : Settable _ := settable! Build_MemoryAttributes <MemoryAttributes_memtype; MemoryAttributes_device; MemoryAttributes_inner; MemoryAttributes_outer; MemoryAttributes_shareability; MemoryAttributes_tags; MemoryAttributes_notagaccess; MemoryAttributes_xs>.
#[export]
Instance dummy_MemoryAttributes : Inhabited (MemoryAttributes) := {
  inhabitant := {|
    MemoryAttributes_memtype := inhabitant;
    MemoryAttributes_device := inhabitant;
    MemoryAttributes_inner := inhabitant;
    MemoryAttributes_outer := inhabitant;
    MemoryAttributes_shareability := inhabitant;
    MemoryAttributes_tags := inhabitant;
    MemoryAttributes_notagaccess := inhabitant;
    MemoryAttributes_xs := inhabitant
|} }.


Inductive PASpace := PAS_NonSecure | PAS_Secure | PAS_Root | PAS_Realm.
Definition num_of_PASpace (arg_ : PASpace) : Z :=
   match arg_ with | PAS_NonSecure => 0 | PAS_Secure => 1 | PAS_Root => 2 | PAS_Realm => 3 end.

Definition PASpace_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : PASpace :=
   let l__75 := arg_ in
   if Z.eqb (l__75) (0) then PAS_NonSecure
   else if Z.eqb (l__75) (1) then PAS_Secure
   else if Z.eqb (l__75) (2) then PAS_Root
   else PAS_Realm.

Lemma PASpace_num_of_roundtrip (x : PASpace) : PASpace_of_num (num_of_PASpace x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_PASpace_injective (x y : PASpace) : num_of_PASpace x = num_of_PASpace y -> x = y.
  intro.
  rewrite <- (PASpace_num_of_roundtrip x).
  rewrite <- (PASpace_num_of_roundtrip y).
  congruence.
Qed.
Definition PASpace_eq_dec (x y : PASpace) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_PASpace x) (num_of_PASpace y) with
  | left e => left (num_of_PASpace_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition PASpace_beq (x y : PASpace) : bool :=
  Z.eqb (num_of_PASpace x) (num_of_PASpace y).
Lemma PASpace_beq_iff x y : PASpace_beq x y = true <-> x = y.
  unfold PASpace_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_PASpace_injective | congruence].
Qed.
Lemma PASpace_beq_refl x : PASpace_beq x x = true.
apply PASpace_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_PASpace : EqDecision PASpace := PASpace_eq_dec.
#[export]
Instance Countable_PASpace : Countable PASpace.
refine {|
  encode x := encode (num_of_PASpace x);
  decode x := z ← decode x; mret (PASpace_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite PASpace_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_PASpace : Inhabited PASpace := { inhabitant := PAS_NonSecure }.


Record FullAddress := {
  FullAddress_paspace : PASpace;
  FullAddress_address : bits 56;
}.
Arguments FullAddress : clear implicits.
#[export]
Instance Decidable_eq_FullAddress : EqDecision FullAddress.
   intros [x0 x1].
   intros [y0 y1].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_FullAddress : Countable FullAddress.
refine {|
  encode x := encode (FullAddress_paspace x, FullAddress_address x);
  decode x := '(x0, x1) ← decode x;
              mret (Build_FullAddress x0 x1)
|}.
abstract (
  intros [x0 x1];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_FullAddress : Settable _ := settable! Build_FullAddress <FullAddress_paspace; FullAddress_address>.
#[export]
Instance dummy_FullAddress : Inhabited (FullAddress) := {
  inhabitant := {| FullAddress_paspace := inhabitant; FullAddress_address := inhabitant
|} }.


Inductive GPCF := GPCF_None | GPCF_AddressSize | GPCF_Walk | GPCF_EABT | GPCF_Fail.
Definition num_of_GPCF (arg_ : GPCF) : Z :=
   match arg_ with
   | GPCF_None => 0
   | GPCF_AddressSize => 1
   | GPCF_Walk => 2
   | GPCF_EABT => 3
   | GPCF_Fail => 4
   end.

Definition GPCF_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 4)*) : GPCF :=
   let l__71 := arg_ in
   if Z.eqb (l__71) (0) then GPCF_None
   else if Z.eqb (l__71) (1) then GPCF_AddressSize
   else if Z.eqb (l__71) (2) then GPCF_Walk
   else if Z.eqb (l__71) (3) then GPCF_EABT
   else GPCF_Fail.

Lemma GPCF_num_of_roundtrip (x : GPCF) : GPCF_of_num (num_of_GPCF x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_GPCF_injective (x y : GPCF) : num_of_GPCF x = num_of_GPCF y -> x = y.
  intro.
  rewrite <- (GPCF_num_of_roundtrip x).
  rewrite <- (GPCF_num_of_roundtrip y).
  congruence.
Qed.
Definition GPCF_eq_dec (x y : GPCF) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_GPCF x) (num_of_GPCF y) with
  | left e => left (num_of_GPCF_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition GPCF_beq (x y : GPCF) : bool :=
  Z.eqb (num_of_GPCF x) (num_of_GPCF y).
Lemma GPCF_beq_iff x y : GPCF_beq x y = true <-> x = y.
  unfold GPCF_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_GPCF_injective | congruence].
Qed.
Lemma GPCF_beq_refl x : GPCF_beq x x = true.
apply GPCF_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_GPCF : EqDecision GPCF := GPCF_eq_dec.
#[export]
Instance Countable_GPCF : Countable GPCF.
refine {|
  encode x := encode (num_of_GPCF x);
  decode x := z ← decode x; mret (GPCF_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite GPCF_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_GPCF : Inhabited GPCF := { inhabitant := GPCF_None }.


Record GPCFRecord := {
  GPCFRecord_gpf : GPCF;
  GPCFRecord_level : Z;
}.
Arguments GPCFRecord : clear implicits.
#[export]
Instance Decidable_eq_GPCFRecord : EqDecision GPCFRecord.
   intros [x0 x1].
   intros [y0 y1].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_GPCFRecord : Countable GPCFRecord.
refine {|
  encode x := encode (GPCFRecord_gpf x, GPCFRecord_level x);
  decode x := '(x0, x1) ← decode x;
              mret (Build_GPCFRecord x0 x1)
|}.
abstract (
  intros [x0 x1];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_GPCFRecord : Settable _ := settable! Build_GPCFRecord <GPCFRecord_gpf; GPCFRecord_level>.
#[export]
Instance dummy_GPCFRecord : Inhabited (GPCFRecord) := {
  inhabitant := {| GPCFRecord_gpf := inhabitant; GPCFRecord_level := inhabitant
|} }.


Inductive Fault :=
  | Fault_None
  | Fault_AccessFlag
  | Fault_Alignment
  | Fault_Background
  | Fault_Domain
  | Fault_Permission
  | Fault_Translation
  | Fault_AddressSize
  | Fault_SyncExternal
  | Fault_SyncExternalOnWalk
  | Fault_SyncParity
  | Fault_SyncParityOnWalk
  | Fault_GPCFOnWalk
  | Fault_GPCFOnOutput
  | Fault_AsyncParity
  | Fault_AsyncExternal
  | Fault_TagCheck
  | Fault_Debug
  | Fault_TLBConflict
  | Fault_BranchTarget
  | Fault_HWUpdateAccessFlag
  | Fault_Lockdown
  | Fault_Exclusive
  | Fault_ICacheMaint.
Definition num_of_Fault (arg_ : Fault) : Z :=
   match arg_ with
   | Fault_None => 0
   | Fault_AccessFlag => 1
   | Fault_Alignment => 2
   | Fault_Background => 3
   | Fault_Domain => 4
   | Fault_Permission => 5
   | Fault_Translation => 6
   | Fault_AddressSize => 7
   | Fault_SyncExternal => 8
   | Fault_SyncExternalOnWalk => 9
   | Fault_SyncParity => 10
   | Fault_SyncParityOnWalk => 11
   | Fault_GPCFOnWalk => 12
   | Fault_GPCFOnOutput => 13
   | Fault_AsyncParity => 14
   | Fault_AsyncExternal => 15
   | Fault_TagCheck => 16
   | Fault_Debug => 17
   | Fault_TLBConflict => 18
   | Fault_BranchTarget => 19
   | Fault_HWUpdateAccessFlag => 20
   | Fault_Lockdown => 21
   | Fault_Exclusive => 22
   | Fault_ICacheMaint => 23
   end.

Definition Fault_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 23)*) : Fault :=
   let l__48 := arg_ in
   if Z.eqb (l__48) (0) then Fault_None
   else if Z.eqb (l__48) (1) then Fault_AccessFlag
   else if Z.eqb (l__48) (2) then Fault_Alignment
   else if Z.eqb (l__48) (3) then Fault_Background
   else if Z.eqb (l__48) (4) then Fault_Domain
   else if Z.eqb (l__48) (5) then Fault_Permission
   else if Z.eqb (l__48) (6) then Fault_Translation
   else if Z.eqb (l__48) (7) then Fault_AddressSize
   else if Z.eqb (l__48) (8) then Fault_SyncExternal
   else if Z.eqb (l__48) (9) then Fault_SyncExternalOnWalk
   else if Z.eqb (l__48) (10) then Fault_SyncParity
   else if Z.eqb (l__48) (11) then Fault_SyncParityOnWalk
   else if Z.eqb (l__48) (12) then Fault_GPCFOnWalk
   else if Z.eqb (l__48) (13) then Fault_GPCFOnOutput
   else if Z.eqb (l__48) (14) then Fault_AsyncParity
   else if Z.eqb (l__48) (15) then Fault_AsyncExternal
   else if Z.eqb (l__48) (16) then Fault_TagCheck
   else if Z.eqb (l__48) (17) then Fault_Debug
   else if Z.eqb (l__48) (18) then Fault_TLBConflict
   else if Z.eqb (l__48) (19) then Fault_BranchTarget
   else if Z.eqb (l__48) (20) then Fault_HWUpdateAccessFlag
   else if Z.eqb (l__48) (21) then Fault_Lockdown
   else if Z.eqb (l__48) (22) then Fault_Exclusive
   else Fault_ICacheMaint.

Lemma Fault_num_of_roundtrip (x : Fault) : Fault_of_num (num_of_Fault x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_Fault_injective (x y : Fault) : num_of_Fault x = num_of_Fault y -> x = y.
  intro.
  rewrite <- (Fault_num_of_roundtrip x).
  rewrite <- (Fault_num_of_roundtrip y).
  congruence.
Qed.
Definition Fault_eq_dec (x y : Fault) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_Fault x) (num_of_Fault y) with
  | left e => left (num_of_Fault_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition Fault_beq (x y : Fault) : bool :=
  Z.eqb (num_of_Fault x) (num_of_Fault y).
Lemma Fault_beq_iff x y : Fault_beq x y = true <-> x = y.
  unfold Fault_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_Fault_injective | congruence].
Qed.
Lemma Fault_beq_refl x : Fault_beq x x = true.
apply Fault_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_Fault : EqDecision Fault := Fault_eq_dec.
#[export]
Instance Countable_Fault : Countable Fault.
refine {|
  encode x := encode (num_of_Fault x);
  decode x := z ← decode x; mret (Fault_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite Fault_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_Fault : Inhabited Fault := { inhabitant := Fault_None }.


Inductive ErrorState :=
  | ErrorState_UC
  | ErrorState_UEU
  | ErrorState_UEO
  | ErrorState_UER
  | ErrorState_CE
  | ErrorState_Uncategorized
  | ErrorState_IMPDEF.
Definition num_of_ErrorState (arg_ : ErrorState) : Z :=
   match arg_ with
   | ErrorState_UC => 0
   | ErrorState_UEU => 1
   | ErrorState_UEO => 2
   | ErrorState_UER => 3
   | ErrorState_CE => 4
   | ErrorState_Uncategorized => 5
   | ErrorState_IMPDEF => 6
   end.

Definition ErrorState_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 6)*) : ErrorState :=
   let l__42 := arg_ in
   if Z.eqb (l__42) (0) then ErrorState_UC
   else if Z.eqb (l__42) (1) then ErrorState_UEU
   else if Z.eqb (l__42) (2) then ErrorState_UEO
   else if Z.eqb (l__42) (3) then ErrorState_UER
   else if Z.eqb (l__42) (4) then ErrorState_CE
   else if Z.eqb (l__42) (5) then ErrorState_Uncategorized
   else ErrorState_IMPDEF.

Lemma ErrorState_num_of_roundtrip (x : ErrorState) : ErrorState_of_num (num_of_ErrorState x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_ErrorState_injective (x y : ErrorState) : num_of_ErrorState x = num_of_ErrorState y -> x = y.
  intro.
  rewrite <- (ErrorState_num_of_roundtrip x).
  rewrite <- (ErrorState_num_of_roundtrip y).
  congruence.
Qed.
Definition ErrorState_eq_dec (x y : ErrorState) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_ErrorState x) (num_of_ErrorState y) with
  | left e => left (num_of_ErrorState_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition ErrorState_beq (x y : ErrorState) : bool :=
  Z.eqb (num_of_ErrorState x) (num_of_ErrorState y).
Lemma ErrorState_beq_iff x y : ErrorState_beq x y = true <-> x = y.
  unfold ErrorState_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_ErrorState_injective | congruence].
Qed.
Lemma ErrorState_beq_refl x : ErrorState_beq x x = true.
apply ErrorState_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_ErrorState : EqDecision ErrorState := ErrorState_eq_dec.
#[export]
Instance Countable_ErrorState : Countable ErrorState.
refine {|
  encode x := encode (num_of_ErrorState x);
  decode x := z ← decode x; mret (ErrorState_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite ErrorState_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_ErrorState : Inhabited ErrorState := { inhabitant := ErrorState_UC }.


Record FaultRecord := {
  FaultRecord_statuscode : Fault;
  FaultRecord_access : AccessDescriptor;
  FaultRecord_ipaddress : FullAddress;
  FaultRecord_gpcf : GPCFRecord;
  FaultRecord_paddress : FullAddress;
  FaultRecord_gpcfs2walk : bool;
  FaultRecord_s2fs1walk : bool;
  FaultRecord_write : bool;
  FaultRecord_s1tagnotdata : bool;
  FaultRecord_tagaccess : bool;
  FaultRecord_level : Z;
  FaultRecord_extflag : bits 1;
  FaultRecord_secondstage : bool;
  FaultRecord_assuredonly : bool;
  FaultRecord_toplevel : bool;
  FaultRecord_overlay : bool;
  FaultRecord_dirtybit : bool;
  FaultRecord_domain : bits 4;
  FaultRecord_merrorstate : ErrorState;
  FaultRecord_debugmoe : bits 4;
}.
Arguments FaultRecord : clear implicits.
#[export]
Instance Decidable_eq_FaultRecord : EqDecision FaultRecord.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16 y17 y18 y19].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
  cmp_record_field x15 y15.
  cmp_record_field x16 y16.
  cmp_record_field x17 y17.
  cmp_record_field x18 y18.
  cmp_record_field x19 y19.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_FaultRecord : Countable FaultRecord.
refine {|
  encode x := encode (FaultRecord_statuscode x, FaultRecord_access x, FaultRecord_ipaddress x, FaultRecord_gpcf x, FaultRecord_paddress x, FaultRecord_gpcfs2walk x, FaultRecord_s2fs1walk x, FaultRecord_write x, FaultRecord_s1tagnotdata x, FaultRecord_tagaccess x, FaultRecord_level x, FaultRecord_extflag x, FaultRecord_secondstage x, FaultRecord_assuredonly x, FaultRecord_toplevel x, FaultRecord_overlay x, FaultRecord_dirtybit x, FaultRecord_domain x, FaultRecord_merrorstate x, FaultRecord_debugmoe x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19) ← decode x;
              mret (Build_FaultRecord x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_FaultRecord : Settable _ := settable! Build_FaultRecord <FaultRecord_statuscode; FaultRecord_access; FaultRecord_ipaddress; FaultRecord_gpcf; FaultRecord_paddress; FaultRecord_gpcfs2walk; FaultRecord_s2fs1walk; FaultRecord_write; FaultRecord_s1tagnotdata; FaultRecord_tagaccess; FaultRecord_level; FaultRecord_extflag; FaultRecord_secondstage; FaultRecord_assuredonly; FaultRecord_toplevel; FaultRecord_overlay; FaultRecord_dirtybit; FaultRecord_domain; FaultRecord_merrorstate; FaultRecord_debugmoe>.
#[export]
Instance dummy_FaultRecord : Inhabited (FaultRecord) := {
  inhabitant := {|
    FaultRecord_statuscode := inhabitant;
    FaultRecord_access := inhabitant;
    FaultRecord_ipaddress := inhabitant;
    FaultRecord_gpcf := inhabitant;
    FaultRecord_paddress := inhabitant;
    FaultRecord_gpcfs2walk := inhabitant;
    FaultRecord_s2fs1walk := inhabitant;
    FaultRecord_write := inhabitant;
    FaultRecord_s1tagnotdata := inhabitant;
    FaultRecord_tagaccess := inhabitant;
    FaultRecord_level := inhabitant;
    FaultRecord_extflag := inhabitant;
    FaultRecord_secondstage := inhabitant;
    FaultRecord_assuredonly := inhabitant;
    FaultRecord_toplevel := inhabitant;
    FaultRecord_overlay := inhabitant;
    FaultRecord_dirtybit := inhabitant;
    FaultRecord_domain := inhabitant;
    FaultRecord_merrorstate := inhabitant;
    FaultRecord_debugmoe := inhabitant
|} }.


Inductive MBReqDomain :=
  | MBReqDomain_Nonshareable
  | MBReqDomain_InnerShareable
  | MBReqDomain_OuterShareable
  | MBReqDomain_FullSystem.
Definition num_of_MBReqDomain (arg_ : MBReqDomain) : Z :=
   match arg_ with
   | MBReqDomain_Nonshareable => 0
   | MBReqDomain_InnerShareable => 1
   | MBReqDomain_OuterShareable => 2
   | MBReqDomain_FullSystem => 3
   end.

Definition MBReqDomain_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : MBReqDomain :=
   let l__39 := arg_ in
   if Z.eqb (l__39) (0) then MBReqDomain_Nonshareable
   else if Z.eqb (l__39) (1) then MBReqDomain_InnerShareable
   else if Z.eqb (l__39) (2) then MBReqDomain_OuterShareable
   else MBReqDomain_FullSystem.

Lemma MBReqDomain_num_of_roundtrip (x : MBReqDomain) : MBReqDomain_of_num (num_of_MBReqDomain x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MBReqDomain_injective (x y : MBReqDomain) : num_of_MBReqDomain x = num_of_MBReqDomain y -> x = y.
  intro.
  rewrite <- (MBReqDomain_num_of_roundtrip x).
  rewrite <- (MBReqDomain_num_of_roundtrip y).
  congruence.
Qed.
Definition MBReqDomain_eq_dec (x y : MBReqDomain) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MBReqDomain x) (num_of_MBReqDomain y) with
  | left e => left (num_of_MBReqDomain_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MBReqDomain_beq (x y : MBReqDomain) : bool :=
  Z.eqb (num_of_MBReqDomain x) (num_of_MBReqDomain y).
Lemma MBReqDomain_beq_iff x y : MBReqDomain_beq x y = true <-> x = y.
  unfold MBReqDomain_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MBReqDomain_injective | congruence].
Qed.
Lemma MBReqDomain_beq_refl x : MBReqDomain_beq x x = true.
apply MBReqDomain_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MBReqDomain : EqDecision MBReqDomain := MBReqDomain_eq_dec.
#[export]
Instance Countable_MBReqDomain : Countable MBReqDomain.
refine {|
  encode x := encode (num_of_MBReqDomain x);
  decode x := z ← decode x; mret (MBReqDomain_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MBReqDomain_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MBReqDomain : Inhabited MBReqDomain := { inhabitant := MBReqDomain_Nonshareable }.


Inductive MBReqTypes := MBReqTypes_Reads | MBReqTypes_Writes | MBReqTypes_All.
Definition num_of_MBReqTypes (arg_ : MBReqTypes) : Z :=
   match arg_ with | MBReqTypes_Reads => 0 | MBReqTypes_Writes => 1 | MBReqTypes_All => 2 end.

Definition MBReqTypes_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : MBReqTypes :=
   let l__37 := arg_ in
   if Z.eqb (l__37) (0) then MBReqTypes_Reads
   else if Z.eqb (l__37) (1) then MBReqTypes_Writes
   else MBReqTypes_All.

Lemma MBReqTypes_num_of_roundtrip (x : MBReqTypes) : MBReqTypes_of_num (num_of_MBReqTypes x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MBReqTypes_injective (x y : MBReqTypes) : num_of_MBReqTypes x = num_of_MBReqTypes y -> x = y.
  intro.
  rewrite <- (MBReqTypes_num_of_roundtrip x).
  rewrite <- (MBReqTypes_num_of_roundtrip y).
  congruence.
Qed.
Definition MBReqTypes_eq_dec (x y : MBReqTypes) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MBReqTypes x) (num_of_MBReqTypes y) with
  | left e => left (num_of_MBReqTypes_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MBReqTypes_beq (x y : MBReqTypes) : bool :=
  Z.eqb (num_of_MBReqTypes x) (num_of_MBReqTypes y).
Lemma MBReqTypes_beq_iff x y : MBReqTypes_beq x y = true <-> x = y.
  unfold MBReqTypes_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MBReqTypes_injective | congruence].
Qed.
Lemma MBReqTypes_beq_refl x : MBReqTypes_beq x x = true.
apply MBReqTypes_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MBReqTypes : EqDecision MBReqTypes := MBReqTypes_eq_dec.
#[export]
Instance Countable_MBReqTypes : Countable MBReqTypes.
refine {|
  encode x := encode (num_of_MBReqTypes x);
  decode x := z ← decode x; mret (MBReqTypes_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MBReqTypes_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MBReqTypes : Inhabited MBReqTypes := { inhabitant := MBReqTypes_Reads }.


Record CacheRecord := {
  CacheRecord_acctype : AccessType;
  CacheRecord_cacheop : CacheOp;
  CacheRecord_opscope : CacheOpScope;
  CacheRecord_cachetype : CacheType;
  CacheRecord_regval : bits 64;
  CacheRecord_paddress : FullAddress;
  CacheRecord_vaddress : bits 64;
  CacheRecord_setnum : Z;
  CacheRecord_waynum : Z;
  CacheRecord_level : Z;
  CacheRecord_shareability : Shareability;
  CacheRecord_translated : bool;
  CacheRecord_is_vmid_valid : bool;
  CacheRecord_vmid : bits 16;
  CacheRecord_is_asid_valid : bool;
  CacheRecord_asid : bits 16;
  CacheRecord_security : SecurityState;
  CacheRecord_cpas : CachePASpace;
}.
Arguments CacheRecord : clear implicits.
#[export]
Instance Decidable_eq_CacheRecord : EqDecision CacheRecord.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16 y17].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
  cmp_record_field x15 y15.
  cmp_record_field x16 y16.
  cmp_record_field x17 y17.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_CacheRecord : Countable CacheRecord.
refine {|
  encode x := encode (CacheRecord_acctype x, CacheRecord_cacheop x, CacheRecord_opscope x, CacheRecord_cachetype x, CacheRecord_regval x, CacheRecord_paddress x, CacheRecord_vaddress x, CacheRecord_setnum x, CacheRecord_waynum x, CacheRecord_level x, CacheRecord_shareability x, CacheRecord_translated x, CacheRecord_is_vmid_valid x, CacheRecord_vmid x, CacheRecord_is_asid_valid x, CacheRecord_asid x, CacheRecord_security x, CacheRecord_cpas x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17) ← decode x;
              mret (Build_CacheRecord x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_CacheRecord : Settable _ := settable! Build_CacheRecord <CacheRecord_acctype; CacheRecord_cacheop; CacheRecord_opscope; CacheRecord_cachetype; CacheRecord_regval; CacheRecord_paddress; CacheRecord_vaddress; CacheRecord_setnum; CacheRecord_waynum; CacheRecord_level; CacheRecord_shareability; CacheRecord_translated; CacheRecord_is_vmid_valid; CacheRecord_vmid; CacheRecord_is_asid_valid; CacheRecord_asid; CacheRecord_security; CacheRecord_cpas>.
#[export]
Instance dummy_CacheRecord : Inhabited (CacheRecord) := {
  inhabitant := {|
    CacheRecord_acctype := inhabitant;
    CacheRecord_cacheop := inhabitant;
    CacheRecord_opscope := inhabitant;
    CacheRecord_cachetype := inhabitant;
    CacheRecord_regval := inhabitant;
    CacheRecord_paddress := inhabitant;
    CacheRecord_vaddress := inhabitant;
    CacheRecord_setnum := inhabitant;
    CacheRecord_waynum := inhabitant;
    CacheRecord_level := inhabitant;
    CacheRecord_shareability := inhabitant;
    CacheRecord_translated := inhabitant;
    CacheRecord_is_vmid_valid := inhabitant;
    CacheRecord_vmid := inhabitant;
    CacheRecord_is_asid_valid := inhabitant;
    CacheRecord_asid := inhabitant;
    CacheRecord_security := inhabitant;
    CacheRecord_cpas := inhabitant
|} }.


Inductive Regime := Regime_EL3 | Regime_EL30 | Regime_EL2 | Regime_EL20 | Regime_EL10.
Definition num_of_Regime (arg_ : Regime) : Z :=
   match arg_ with
   | Regime_EL3 => 0
   | Regime_EL30 => 1
   | Regime_EL2 => 2
   | Regime_EL20 => 3
   | Regime_EL10 => 4
   end.

Definition Regime_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 4)*) : Regime :=
   let l__33 := arg_ in
   if Z.eqb (l__33) (0) then Regime_EL3
   else if Z.eqb (l__33) (1) then Regime_EL30
   else if Z.eqb (l__33) (2) then Regime_EL2
   else if Z.eqb (l__33) (3) then Regime_EL20
   else Regime_EL10.

Lemma Regime_num_of_roundtrip (x : Regime) : Regime_of_num (num_of_Regime x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_Regime_injective (x y : Regime) : num_of_Regime x = num_of_Regime y -> x = y.
  intro.
  rewrite <- (Regime_num_of_roundtrip x).
  rewrite <- (Regime_num_of_roundtrip y).
  congruence.
Qed.
Definition Regime_eq_dec (x y : Regime) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_Regime x) (num_of_Regime y) with
  | left e => left (num_of_Regime_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition Regime_beq (x y : Regime) : bool :=
  Z.eqb (num_of_Regime x) (num_of_Regime y).
Lemma Regime_beq_iff x y : Regime_beq x y = true <-> x = y.
  unfold Regime_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_Regime_injective | congruence].
Qed.
Lemma Regime_beq_refl x : Regime_beq x x = true.
apply Regime_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_Regime : EqDecision Regime := Regime_eq_dec.
#[export]
Instance Countable_Regime : Countable Regime.
refine {|
  encode x := encode (num_of_Regime x);
  decode x := z ← decode x; mret (Regime_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite Regime_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_Regime : Inhabited Regime := { inhabitant := Regime_EL3 }.


Inductive TGx := TGx_4KB | TGx_16KB | TGx_64KB.
Definition num_of_TGx (arg_ : TGx) : Z :=
   match arg_ with | TGx_4KB => 0 | TGx_16KB => 1 | TGx_64KB => 2 end.

Definition TGx_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : TGx :=
   let l__31 := arg_ in
   if Z.eqb (l__31) (0) then TGx_4KB
   else if Z.eqb (l__31) (1) then TGx_16KB
   else TGx_64KB.

Lemma TGx_num_of_roundtrip (x : TGx) : TGx_of_num (num_of_TGx x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_TGx_injective (x y : TGx) : num_of_TGx x = num_of_TGx y -> x = y.
  intro.
  rewrite <- (TGx_num_of_roundtrip x).
  rewrite <- (TGx_num_of_roundtrip y).
  congruence.
Qed.
Definition TGx_eq_dec (x y : TGx) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_TGx x) (num_of_TGx y) with
  | left e => left (num_of_TGx_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition TGx_beq (x y : TGx) : bool :=
  Z.eqb (num_of_TGx x) (num_of_TGx y).
Lemma TGx_beq_iff x y : TGx_beq x y = true <-> x = y.
  unfold TGx_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_TGx_injective | congruence].
Qed.
Lemma TGx_beq_refl x : TGx_beq x x = true.
apply TGx_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_TGx : EqDecision TGx := TGx_eq_dec.
#[export]
Instance Countable_TGx : Countable TGx.
refine {|
  encode x := encode (num_of_TGx x);
  decode x := z ← decode x; mret (TGx_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite TGx_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_TGx : Inhabited TGx := { inhabitant := TGx_4KB }.


Record TLBContext := {
  TLBContext_ss : SecurityState;
  TLBContext_regime : Regime;
  TLBContext_vmid : bits 16;
  TLBContext_asid : bits 16;
  TLBContext_nG : bits 1;
  TLBContext_ipaspace : PASpace;
  TLBContext_includes_s1_name : bool;
  TLBContext_includes_s2_name : bool;
  TLBContext_includes_gpt_name : bool;
  TLBContext_ia : bits 64;
  TLBContext_tg : TGx;
  TLBContext_cnp : bits 1;
  TLBContext_level : Z;
  TLBContext_isd128 : bool;
  TLBContext_xs : bits 1;
}.
Arguments TLBContext : clear implicits.
#[export]
Instance Decidable_eq_TLBContext : EqDecision TLBContext.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_TLBContext : Countable TLBContext.
refine {|
  encode x := encode (TLBContext_ss x, TLBContext_regime x, TLBContext_vmid x, TLBContext_asid x, TLBContext_nG x, TLBContext_ipaspace x, TLBContext_includes_s1_name x, TLBContext_includes_s2_name x, TLBContext_includes_gpt_name x, TLBContext_ia x, TLBContext_tg x, TLBContext_cnp x, TLBContext_level x, TLBContext_isd128 x, TLBContext_xs x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14) ← decode x;
              mret (Build_TLBContext x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_TLBContext : Settable _ := settable! Build_TLBContext <TLBContext_ss; TLBContext_regime; TLBContext_vmid; TLBContext_asid; TLBContext_nG; TLBContext_ipaspace; TLBContext_includes_s1_name; TLBContext_includes_s2_name; TLBContext_includes_gpt_name; TLBContext_ia; TLBContext_tg; TLBContext_cnp; TLBContext_level; TLBContext_isd128; TLBContext_xs>.
#[export]
Instance dummy_TLBContext : Inhabited (TLBContext) := {
  inhabitant := {|
    TLBContext_ss := inhabitant;
    TLBContext_regime := inhabitant;
    TLBContext_vmid := inhabitant;
    TLBContext_asid := inhabitant;
    TLBContext_nG := inhabitant;
    TLBContext_ipaspace := inhabitant;
    TLBContext_includes_s1_name := inhabitant;
    TLBContext_includes_s2_name := inhabitant;
    TLBContext_includes_gpt_name := inhabitant;
    TLBContext_ia := inhabitant;
    TLBContext_tg := inhabitant;
    TLBContext_cnp := inhabitant;
    TLBContext_level := inhabitant;
    TLBContext_isd128 := inhabitant;
    TLBContext_xs := inhabitant
|} }.


Record AddressDescriptor := {
  AddressDescriptor_fault : FaultRecord;
  AddressDescriptor_memattrs : MemoryAttributes;
  AddressDescriptor_paddress : FullAddress;
  AddressDescriptor_tlbcontext : TLBContext;
  AddressDescriptor_s1assured : bool;
  AddressDescriptor_s2fs1mro : bool;
  AddressDescriptor_mecid : bits 16;
  AddressDescriptor_vaddress : bits 64;
}.
Arguments AddressDescriptor : clear implicits.
#[export]
Instance Decidable_eq_AddressDescriptor : EqDecision AddressDescriptor.
   intros [x0 x1 x2 x3 x4 x5 x6 x7].
   intros [y0 y1 y2 y3 y4 y5 y6 y7].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_AddressDescriptor : Countable AddressDescriptor.
refine {|
  encode x := encode (AddressDescriptor_fault x, AddressDescriptor_memattrs x, AddressDescriptor_paddress x, AddressDescriptor_tlbcontext x, AddressDescriptor_s1assured x, AddressDescriptor_s2fs1mro x, AddressDescriptor_mecid x, AddressDescriptor_vaddress x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7) ← decode x;
              mret (Build_AddressDescriptor x0 x1 x2 x3 x4 x5 x6 x7)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_AddressDescriptor : Settable _ := settable! Build_AddressDescriptor <AddressDescriptor_fault; AddressDescriptor_memattrs; AddressDescriptor_paddress; AddressDescriptor_tlbcontext; AddressDescriptor_s1assured; AddressDescriptor_s2fs1mro; AddressDescriptor_mecid; AddressDescriptor_vaddress>.
#[export]
Instance dummy_AddressDescriptor : Inhabited (AddressDescriptor) := {
  inhabitant := {|
    AddressDescriptor_fault := inhabitant;
    AddressDescriptor_memattrs := inhabitant;
    AddressDescriptor_paddress := inhabitant;
    AddressDescriptor_tlbcontext := inhabitant;
    AddressDescriptor_s1assured := inhabitant;
    AddressDescriptor_s2fs1mro := inhabitant;
    AddressDescriptor_mecid := inhabitant;
    AddressDescriptor_vaddress := inhabitant
|} }.


Record TranslationStartInfo := {
  TranslationStartInfo_ss : SecurityState;
  TranslationStartInfo_regime : Regime;
  TranslationStartInfo_vmid : bits 16;
  TranslationStartInfo_asid : bits 16;
  TranslationStartInfo_va : bits 64;
  TranslationStartInfo_cnp : bits 1;
  TranslationStartInfo_accdesc : AccessDescriptor;
  TranslationStartInfo_size : Z;
}.
Arguments TranslationStartInfo : clear implicits.
#[export]
Instance Decidable_eq_TranslationStartInfo : EqDecision TranslationStartInfo.
   intros [x0 x1 x2 x3 x4 x5 x6 x7].
   intros [y0 y1 y2 y3 y4 y5 y6 y7].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_TranslationStartInfo : Countable TranslationStartInfo.
refine {|
  encode x := encode (TranslationStartInfo_ss x, TranslationStartInfo_regime x, TranslationStartInfo_vmid x, TranslationStartInfo_asid x, TranslationStartInfo_va x, TranslationStartInfo_cnp x, TranslationStartInfo_accdesc x, TranslationStartInfo_size x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7) ← decode x;
              mret (Build_TranslationStartInfo x0 x1 x2 x3 x4 x5 x6 x7)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_TranslationStartInfo : Settable _ := settable! Build_TranslationStartInfo <TranslationStartInfo_ss; TranslationStartInfo_regime; TranslationStartInfo_vmid; TranslationStartInfo_asid; TranslationStartInfo_va; TranslationStartInfo_cnp; TranslationStartInfo_accdesc; TranslationStartInfo_size>.
#[export]
Instance dummy_TranslationStartInfo : Inhabited (TranslationStartInfo) := {
  inhabitant := {|
    TranslationStartInfo_ss := inhabitant;
    TranslationStartInfo_regime := inhabitant;
    TranslationStartInfo_vmid := inhabitant;
    TranslationStartInfo_asid := inhabitant;
    TranslationStartInfo_va := inhabitant;
    TranslationStartInfo_cnp := inhabitant;
    TranslationStartInfo_accdesc := inhabitant;
    TranslationStartInfo_size := inhabitant
|} }.


Inductive TLBILevel := TLBILevel_Any | TLBILevel_Last.
Definition num_of_TLBILevel (arg_ : TLBILevel) : Z :=
   match arg_ with | TLBILevel_Any => 0 | TLBILevel_Last => 1 end.

Definition TLBILevel_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : TLBILevel :=
   let l__30 := arg_ in
   if Z.eqb (l__30) (0) then TLBILevel_Any
   else TLBILevel_Last.

Lemma TLBILevel_num_of_roundtrip (x : TLBILevel) : TLBILevel_of_num (num_of_TLBILevel x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_TLBILevel_injective (x y : TLBILevel) : num_of_TLBILevel x = num_of_TLBILevel y -> x = y.
  intro.
  rewrite <- (TLBILevel_num_of_roundtrip x).
  rewrite <- (TLBILevel_num_of_roundtrip y).
  congruence.
Qed.
Definition TLBILevel_eq_dec (x y : TLBILevel) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_TLBILevel x) (num_of_TLBILevel y) with
  | left e => left (num_of_TLBILevel_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition TLBILevel_beq (x y : TLBILevel) : bool :=
  Z.eqb (num_of_TLBILevel x) (num_of_TLBILevel y).
Lemma TLBILevel_beq_iff x y : TLBILevel_beq x y = true <-> x = y.
  unfold TLBILevel_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_TLBILevel_injective | congruence].
Qed.
Lemma TLBILevel_beq_refl x : TLBILevel_beq x x = true.
apply TLBILevel_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_TLBILevel : EqDecision TLBILevel := TLBILevel_eq_dec.
#[export]
Instance Countable_TLBILevel : Countable TLBILevel.
refine {|
  encode x := encode (num_of_TLBILevel x);
  decode x := z ← decode x; mret (TLBILevel_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite TLBILevel_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_TLBILevel : Inhabited TLBILevel := { inhabitant := TLBILevel_Any }.


Inductive TLBIOp :=
  | TLBIOp_DALL
  | TLBIOp_DASID
  | TLBIOp_DVA
  | TLBIOp_IALL
  | TLBIOp_IASID
  | TLBIOp_IVA
  | TLBIOp_ALL
  | TLBIOp_ASID
  | TLBIOp_IPAS2
  | TLBIPOp_IPAS2
  | TLBIOp_VAA
  | TLBIOp_VA
  | TLBIPOp_VAA
  | TLBIPOp_VA
  | TLBIOp_VMALL
  | TLBIOp_VMALLS12
  | TLBIOp_RIPAS2
  | TLBIPOp_RIPAS2
  | TLBIOp_RVAA
  | TLBIOp_RVA
  | TLBIPOp_RVAA
  | TLBIPOp_RVA
  | TLBIOp_RPA
  | TLBIOp_PAALL.
Definition num_of_TLBIOp (arg_ : TLBIOp) : Z :=
   match arg_ with
   | TLBIOp_DALL => 0
   | TLBIOp_DASID => 1
   | TLBIOp_DVA => 2
   | TLBIOp_IALL => 3
   | TLBIOp_IASID => 4
   | TLBIOp_IVA => 5
   | TLBIOp_ALL => 6
   | TLBIOp_ASID => 7
   | TLBIOp_IPAS2 => 8
   | TLBIPOp_IPAS2 => 9
   | TLBIOp_VAA => 10
   | TLBIOp_VA => 11
   | TLBIPOp_VAA => 12
   | TLBIPOp_VA => 13
   | TLBIOp_VMALL => 14
   | TLBIOp_VMALLS12 => 15
   | TLBIOp_RIPAS2 => 16
   | TLBIPOp_RIPAS2 => 17
   | TLBIOp_RVAA => 18
   | TLBIOp_RVA => 19
   | TLBIPOp_RVAA => 20
   | TLBIPOp_RVA => 21
   | TLBIOp_RPA => 22
   | TLBIOp_PAALL => 23
   end.

Definition TLBIOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 23)*) : TLBIOp :=
   let l__7 := arg_ in
   if Z.eqb (l__7) (0) then TLBIOp_DALL
   else if Z.eqb (l__7) (1) then TLBIOp_DASID
   else if Z.eqb (l__7) (2) then TLBIOp_DVA
   else if Z.eqb (l__7) (3) then TLBIOp_IALL
   else if Z.eqb (l__7) (4) then TLBIOp_IASID
   else if Z.eqb (l__7) (5) then TLBIOp_IVA
   else if Z.eqb (l__7) (6) then TLBIOp_ALL
   else if Z.eqb (l__7) (7) then TLBIOp_ASID
   else if Z.eqb (l__7) (8) then TLBIOp_IPAS2
   else if Z.eqb (l__7) (9) then TLBIPOp_IPAS2
   else if Z.eqb (l__7) (10) then TLBIOp_VAA
   else if Z.eqb (l__7) (11) then TLBIOp_VA
   else if Z.eqb (l__7) (12) then TLBIPOp_VAA
   else if Z.eqb (l__7) (13) then TLBIPOp_VA
   else if Z.eqb (l__7) (14) then TLBIOp_VMALL
   else if Z.eqb (l__7) (15) then TLBIOp_VMALLS12
   else if Z.eqb (l__7) (16) then TLBIOp_RIPAS2
   else if Z.eqb (l__7) (17) then TLBIPOp_RIPAS2
   else if Z.eqb (l__7) (18) then TLBIOp_RVAA
   else if Z.eqb (l__7) (19) then TLBIOp_RVA
   else if Z.eqb (l__7) (20) then TLBIPOp_RVAA
   else if Z.eqb (l__7) (21) then TLBIPOp_RVA
   else if Z.eqb (l__7) (22) then TLBIOp_RPA
   else TLBIOp_PAALL.

Lemma TLBIOp_num_of_roundtrip (x : TLBIOp) : TLBIOp_of_num (num_of_TLBIOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_TLBIOp_injective (x y : TLBIOp) : num_of_TLBIOp x = num_of_TLBIOp y -> x = y.
  intro.
  rewrite <- (TLBIOp_num_of_roundtrip x).
  rewrite <- (TLBIOp_num_of_roundtrip y).
  congruence.
Qed.
Definition TLBIOp_eq_dec (x y : TLBIOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_TLBIOp x) (num_of_TLBIOp y) with
  | left e => left (num_of_TLBIOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition TLBIOp_beq (x y : TLBIOp) : bool :=
  Z.eqb (num_of_TLBIOp x) (num_of_TLBIOp y).
Lemma TLBIOp_beq_iff x y : TLBIOp_beq x y = true <-> x = y.
  unfold TLBIOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_TLBIOp_injective | congruence].
Qed.
Lemma TLBIOp_beq_refl x : TLBIOp_beq x x = true.
apply TLBIOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_TLBIOp : EqDecision TLBIOp := TLBIOp_eq_dec.
#[export]
Instance Countable_TLBIOp : Countable TLBIOp.
refine {|
  encode x := encode (num_of_TLBIOp x);
  decode x := z ← decode x; mret (TLBIOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite TLBIOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_TLBIOp : Inhabited TLBIOp := { inhabitant := TLBIOp_DALL }.


Inductive TLBIMemAttr := TLBI_AllAttr | TLBI_ExcludeXS.
Definition num_of_TLBIMemAttr (arg_ : TLBIMemAttr) : Z :=
   match arg_ with | TLBI_AllAttr => 0 | TLBI_ExcludeXS => 1 end.

Definition TLBIMemAttr_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : TLBIMemAttr :=
   let l__6 := arg_ in
   if Z.eqb (l__6) (0) then TLBI_AllAttr
   else TLBI_ExcludeXS.

Lemma TLBIMemAttr_num_of_roundtrip (x : TLBIMemAttr) : TLBIMemAttr_of_num (num_of_TLBIMemAttr x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_TLBIMemAttr_injective (x y : TLBIMemAttr) : num_of_TLBIMemAttr x = num_of_TLBIMemAttr y -> x = y.
  intro.
  rewrite <- (TLBIMemAttr_num_of_roundtrip x).
  rewrite <- (TLBIMemAttr_num_of_roundtrip y).
  congruence.
Qed.
Definition TLBIMemAttr_eq_dec (x y : TLBIMemAttr) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_TLBIMemAttr x) (num_of_TLBIMemAttr y) with
  | left e => left (num_of_TLBIMemAttr_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition TLBIMemAttr_beq (x y : TLBIMemAttr) : bool :=
  Z.eqb (num_of_TLBIMemAttr x) (num_of_TLBIMemAttr y).
Lemma TLBIMemAttr_beq_iff x y : TLBIMemAttr_beq x y = true <-> x = y.
  unfold TLBIMemAttr_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_TLBIMemAttr_injective | congruence].
Qed.
Lemma TLBIMemAttr_beq_refl x : TLBIMemAttr_beq x x = true.
apply TLBIMemAttr_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_TLBIMemAttr : EqDecision TLBIMemAttr := TLBIMemAttr_eq_dec.
#[export]
Instance Countable_TLBIMemAttr : Countable TLBIMemAttr.
refine {|
  encode x := encode (num_of_TLBIMemAttr x);
  decode x := z ← decode x; mret (TLBIMemAttr_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite TLBIMemAttr_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_TLBIMemAttr : Inhabited TLBIMemAttr := { inhabitant := TLBI_AllAttr }.


Record TLBIRecord := {
  TLBIRecord_op : TLBIOp;
  TLBIRecord_from_aarch64 : bool;
  TLBIRecord_security : SecurityState;
  TLBIRecord_regime : Regime;
  TLBIRecord_vmid : bits 16;
  TLBIRecord_asid : bits 16;
  TLBIRecord_level : TLBILevel;
  TLBIRecord_attr : TLBIMemAttr;
  TLBIRecord_ipaspace : PASpace;
  TLBIRecord_address : bits 64;
  TLBIRecord_end_address_name : bits 64;
  TLBIRecord_d64 : bool;
  TLBIRecord_d128 : bool;
  TLBIRecord_ttl : bits 4;
  TLBIRecord_tg : bits 2;
}.
Arguments TLBIRecord : clear implicits.
#[export]
Instance Decidable_eq_TLBIRecord : EqDecision TLBIRecord.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_TLBIRecord : Countable TLBIRecord.
refine {|
  encode x := encode (TLBIRecord_op x, TLBIRecord_from_aarch64 x, TLBIRecord_security x, TLBIRecord_regime x, TLBIRecord_vmid x, TLBIRecord_asid x, TLBIRecord_level x, TLBIRecord_attr x, TLBIRecord_ipaspace x, TLBIRecord_address x, TLBIRecord_end_address_name x, TLBIRecord_d64 x, TLBIRecord_d128 x, TLBIRecord_ttl x, TLBIRecord_tg x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14) ← decode x;
              mret (Build_TLBIRecord x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_TLBIRecord : Settable _ := settable! Build_TLBIRecord <TLBIRecord_op; TLBIRecord_from_aarch64; TLBIRecord_security; TLBIRecord_regime; TLBIRecord_vmid; TLBIRecord_asid; TLBIRecord_level; TLBIRecord_attr; TLBIRecord_ipaspace; TLBIRecord_address; TLBIRecord_end_address_name; TLBIRecord_d64; TLBIRecord_d128; TLBIRecord_ttl; TLBIRecord_tg>.
#[export]
Instance dummy_TLBIRecord : Inhabited (TLBIRecord) := {
  inhabitant := {|
    TLBIRecord_op := inhabitant;
    TLBIRecord_from_aarch64 := inhabitant;
    TLBIRecord_security := inhabitant;
    TLBIRecord_regime := inhabitant;
    TLBIRecord_vmid := inhabitant;
    TLBIRecord_asid := inhabitant;
    TLBIRecord_level := inhabitant;
    TLBIRecord_attr := inhabitant;
    TLBIRecord_ipaspace := inhabitant;
    TLBIRecord_address := inhabitant;
    TLBIRecord_end_address_name := inhabitant;
    TLBIRecord_d64 := inhabitant;
    TLBIRecord_d128 := inhabitant;
    TLBIRecord_ttl := inhabitant;
    TLBIRecord_tg := inhabitant
|} }.


Record TLBIInfo := {
  TLBIInfo_rec : TLBIRecord;
  TLBIInfo_shareability : Shareability;
}.
Arguments TLBIInfo : clear implicits.
#[export]
Instance Decidable_eq_TLBIInfo : EqDecision TLBIInfo.
   intros [x0 x1].
   intros [y0 y1].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_TLBIInfo : Countable TLBIInfo.
refine {|
  encode x := encode (TLBIInfo_rec x, TLBIInfo_shareability x);
  decode x := '(x0, x1) ← decode x;
              mret (Build_TLBIInfo x0 x1)
|}.
abstract (
  intros [x0 x1];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_TLBIInfo : Settable _ := settable! Build_TLBIInfo <TLBIInfo_rec; TLBIInfo_shareability>.
#[export]
Instance dummy_TLBIInfo : Inhabited (TLBIInfo) := {
  inhabitant := {| TLBIInfo_rec := inhabitant; TLBIInfo_shareability := inhabitant
|} }.


Record DxB := {
  DxB_domain : MBReqDomain;
  DxB_types : MBReqTypes;
  DxB_nXS : bool;
}.
Arguments DxB : clear implicits.
#[export]
Instance Decidable_eq_DxB : EqDecision DxB.
   intros [x0 x1 x2].
   intros [y0 y1 y2].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_DxB : Countable DxB.
refine {|
  encode x := encode (DxB_domain x, DxB_types x, DxB_nXS x);
  decode x := '(x0, x1, x2) ← decode x;
              mret (Build_DxB x0 x1 x2)
|}.
abstract (
  intros [x0 x1 x2];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_DxB : Settable _ := settable! Build_DxB <DxB_domain; DxB_types; DxB_nXS>.
#[export]
Instance dummy_DxB : Inhabited (DxB) := {
  inhabitant := {| DxB_domain := inhabitant; DxB_types := inhabitant; DxB_nXS := inhabitant
|} }.


Inductive Barrier :=
| Barrier_DSB : DxB -> Barrier
| Barrier_DMB : DxB -> Barrier
| Barrier_ISB : unit -> Barrier
| Barrier_SSBB : unit -> Barrier
| Barrier_PSSBB : unit -> Barrier
| Barrier_SB : unit -> Barrier.
Arguments Barrier : clear implicits.

Definition sail_Barrier_encode (x : Barrier) := match x with
  | Barrier_DSB x' => encode (0, encode x')
  | Barrier_DMB x' => encode (1, encode x')
  | Barrier_ISB x' => encode (2, encode x')
  | Barrier_SSBB x' => encode (3, encode x')
  | Barrier_PSSBB x' => encode (4, encode x')
  | Barrier_SB x' => encode (5, encode x') end.
Definition sail_Barrier_decode x : option Barrier := match decode x with
  | Some (0, x') => Barrier_DSB <$> decode x'
  | Some (1, x') => Barrier_DMB <$> decode x'
  | Some (2, x') => Barrier_ISB <$> decode x'
  | Some (3, x') => Barrier_SSBB <$> decode x'
  | Some (4, x') => Barrier_PSSBB <$> decode x'
  | Some (5, x') => Barrier_SB <$> decode x'
  | _ => None end.
Lemma sail_Barrier_decode_encode : forall (x : Barrier), sail_Barrier_decode (sail_Barrier_encode x)
   = Some x.
Proof.
  unfold sail_Barrier_decode, sail_Barrier_encode;
  intros [x|x|x|x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_Barrier : EqDecision Barrier := decode_encode_eq_dec sail_Barrier_encode
  sail_Barrier_decode sail_Barrier_decode_encode .

#[export]
Instance Countable_Barrier : Countable Barrier := {|
  encode := sail_Barrier_encode;
  decode := sail_Barrier_decode;
  decode_encode := sail_Barrier_decode_encode
|}.
#[export]
Instance dummy_Barrier : Inhabited (Barrier) := { inhabitant := Barrier_DSB inhabitant }.

Definition reg_index : Type := Z.

Record ProcState := {
  ProcState_N : bits 1;
  ProcState_Z : bits 1;
  ProcState_C : bits 1;
  ProcState_V : bits 1;
  ProcState_D : bits 1;
  ProcState_A : bits 1;
  ProcState_I : bits 1;
  ProcState_F : bits 1;
  ProcState_EXLOCK : bits 1;
  ProcState_PAN : bits 1;
  ProcState_UAO : bits 1;
  ProcState_DIT : bits 1;
  ProcState_TCO : bits 1;
  ProcState_PM : bits 1;
  ProcState_PPEND : bits 1;
  ProcState_BTYPE : bits 2;
  ProcState_ZA : bits 1;
  ProcState_SM : bits 1;
  ProcState_ALLINT : bits 1;
  ProcState_SS : bits 1;
  ProcState_IL : bits 1;
  ProcState_EL : bits 2;
  ProcState_nRW : bits 1;
  ProcState_SP : bits 1;
  ProcState_Q : bits 1;
  ProcState_GE : bits 4;
  ProcState_SSBS : bits 1;
  ProcState_IT : bits 8;
  ProcState_J : bits 1;
  ProcState_T : bits 1;
  ProcState_E : bits 1;
  ProcState_M : bits 5;
}.
Arguments ProcState : clear implicits.
#[export]
Instance Decidable_eq_ProcState : EqDecision ProcState.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16 y17 y18 y19 y20 y21 y22 y23 y24 y25 y26 y27 y28 y29 y30 y31].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
  cmp_record_field x15 y15.
  cmp_record_field x16 y16.
  cmp_record_field x17 y17.
  cmp_record_field x18 y18.
  cmp_record_field x19 y19.
  cmp_record_field x20 y20.
  cmp_record_field x21 y21.
  cmp_record_field x22 y22.
  cmp_record_field x23 y23.
  cmp_record_field x24 y24.
  cmp_record_field x25 y25.
  cmp_record_field x26 y26.
  cmp_record_field x27 y27.
  cmp_record_field x28 y28.
  cmp_record_field x29 y29.
  cmp_record_field x30 y30.
  cmp_record_field x31 y31.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_ProcState : Countable ProcState.
refine {|
  encode x := encode (ProcState_N x, ProcState_Z x, ProcState_C x, ProcState_V x, ProcState_D x, ProcState_A x, ProcState_I x, ProcState_F x, ProcState_EXLOCK x, ProcState_PAN x, ProcState_UAO x, ProcState_DIT x, ProcState_TCO x, ProcState_PM x, ProcState_PPEND x, ProcState_BTYPE x, ProcState_ZA x, ProcState_SM x, ProcState_ALLINT x, ProcState_SS x, ProcState_IL x, ProcState_EL x, ProcState_nRW x, ProcState_SP x, ProcState_Q x, ProcState_GE x, ProcState_SSBS x, ProcState_IT x, ProcState_J x, ProcState_T x, ProcState_E x, ProcState_M x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31) ← decode x;
              mret (Build_ProcState x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_ProcState : Settable _ := settable! Build_ProcState <ProcState_N; ProcState_Z; ProcState_C; ProcState_V; ProcState_D; ProcState_A; ProcState_I; ProcState_F; ProcState_EXLOCK; ProcState_PAN; ProcState_UAO; ProcState_DIT; ProcState_TCO; ProcState_PM; ProcState_PPEND; ProcState_BTYPE; ProcState_ZA; ProcState_SM; ProcState_ALLINT; ProcState_SS; ProcState_IL; ProcState_EL; ProcState_nRW; ProcState_SP; ProcState_Q; ProcState_GE; ProcState_SSBS; ProcState_IT; ProcState_J; ProcState_T; ProcState_E; ProcState_M>.
#[export]
Instance dummy_ProcState : Inhabited (ProcState) := {
  inhabitant := {|
    ProcState_N := inhabitant;
    ProcState_Z := inhabitant;
    ProcState_C := inhabitant;
    ProcState_V := inhabitant;
    ProcState_D := inhabitant;
    ProcState_A := inhabitant;
    ProcState_I := inhabitant;
    ProcState_F := inhabitant;
    ProcState_EXLOCK := inhabitant;
    ProcState_PAN := inhabitant;
    ProcState_UAO := inhabitant;
    ProcState_DIT := inhabitant;
    ProcState_TCO := inhabitant;
    ProcState_PM := inhabitant;
    ProcState_PPEND := inhabitant;
    ProcState_BTYPE := inhabitant;
    ProcState_ZA := inhabitant;
    ProcState_SM := inhabitant;
    ProcState_ALLINT := inhabitant;
    ProcState_SS := inhabitant;
    ProcState_IL := inhabitant;
    ProcState_EL := inhabitant;
    ProcState_nRW := inhabitant;
    ProcState_SP := inhabitant;
    ProcState_Q := inhabitant;
    ProcState_GE := inhabitant;
    ProcState_SSBS := inhabitant;
    ProcState_IT := inhabitant;
    ProcState_J := inhabitant;
    ProcState_T := inhabitant;
    ProcState_E := inhabitant;
    ProcState_M := inhabitant
|} }.


Definition addr_size : Z := 56.
#[export] Hint Unfold addr_size : sail.

Inductive DescriptorType := DescriptorType_Table | DescriptorType_Leaf | DescriptorType_Invalid.
Definition num_of_DescriptorType (arg_ : DescriptorType) : Z :=
   match arg_ with
   | DescriptorType_Table => 0
   | DescriptorType_Leaf => 1
   | DescriptorType_Invalid => 2
   end.

Definition DescriptorType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : DescriptorType :=
   let l__4 := arg_ in
   if Z.eqb (l__4) (0) then DescriptorType_Table
   else if Z.eqb (l__4) (1) then DescriptorType_Leaf
   else DescriptorType_Invalid.

Lemma DescriptorType_num_of_roundtrip (x : DescriptorType) : DescriptorType_of_num (num_of_DescriptorType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_DescriptorType_injective (x y : DescriptorType) : num_of_DescriptorType x = num_of_DescriptorType y -> x = y.
  intro.
  rewrite <- (DescriptorType_num_of_roundtrip x).
  rewrite <- (DescriptorType_num_of_roundtrip y).
  congruence.
Qed.
Definition DescriptorType_eq_dec (x y : DescriptorType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_DescriptorType x) (num_of_DescriptorType y) with
  | left e => left (num_of_DescriptorType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition DescriptorType_beq (x y : DescriptorType) : bool :=
  Z.eqb (num_of_DescriptorType x) (num_of_DescriptorType y).
Lemma DescriptorType_beq_iff x y : DescriptorType_beq x y = true <-> x = y.
  unfold DescriptorType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_DescriptorType_injective | congruence].
Qed.
Lemma DescriptorType_beq_refl x : DescriptorType_beq x x = true.
apply DescriptorType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_DescriptorType : EqDecision DescriptorType := DescriptorType_eq_dec.
#[export]
Instance Countable_DescriptorType : Countable DescriptorType.
refine {|
  encode x := encode (num_of_DescriptorType x);
  decode x := z ← decode x; mret (DescriptorType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite DescriptorType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_DescriptorType : Inhabited DescriptorType := { inhabitant := DescriptorType_Table }.


Definition addr_space : Type := PASpace.

Definition abort : Type := Fault.

Inductive ast :=
| LoadRegister : (reg_index * reg_index * reg_index) -> ast
| StoreRegister : (reg_index * reg_index * reg_index) -> ast
| ExclusiveOr : (reg_index * reg_index * reg_index) -> ast
| DataMemoryBarrier : MBReqTypes -> ast
| CompareAndBranch : (reg_index * bits 64) -> ast.
Arguments ast : clear implicits.

Definition sail_ast_encode (x : ast) := match x with
  | LoadRegister x' => encode (0, encode x')
  | StoreRegister x' => encode (1, encode x')
  | ExclusiveOr x' => encode (2, encode x')
  | DataMemoryBarrier x' => encode (3, encode x')
  | CompareAndBranch x' => encode (4, encode x') end.
Definition sail_ast_decode x : option ast := match decode x with
  | Some (0, x') => LoadRegister <$> decode x'
  | Some (1, x') => StoreRegister <$> decode x'
  | Some (2, x') => ExclusiveOr <$> decode x'
  | Some (3, x') => DataMemoryBarrier <$> decode x'
  | Some (4, x') => CompareAndBranch <$> decode x'
  | _ => None end.
Lemma sail_ast_decode_encode : forall (x : ast), sail_ast_decode (sail_ast_encode x)  = Some x.
Proof.
  unfold sail_ast_decode, sail_ast_encode;
  intros [x|x|x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_ast : EqDecision ast := decode_encode_eq_dec sail_ast_encode sail_ast_decode
  sail_ast_decode_encode .

#[export]
Instance Countable_ast : Countable ast := {|
  encode := sail_ast_encode;
  decode := sail_ast_decode;
  decode_encode := sail_ast_decode_encode
|}.
#[export]
Instance dummy_ast : Inhabited (ast) := { inhabitant := LoadRegister inhabitant }.

Definition mem_acc_is_explicit (acc : AccessDescriptor) : bool :=
   generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR).

Definition mem_acc_is_ifetch (acc : AccessDescriptor) : bool :=
   generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_IFETCH).

Definition mem_acc_is_ttw (acc : AccessDescriptor) : bool :=
   generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_TTW).

Definition mem_acc_is_relaxed (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     ((andb ((negb (acc.(AccessDescriptor_acqpc))))
         ((andb ((negb (acc.(AccessDescriptor_acqsc)))) ((negb (acc.(AccessDescriptor_relsc)))))))).

Definition mem_acc_is_rel_acq_rcpc (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     (acc.(AccessDescriptor_acqpc)).

Definition mem_acc_is_rel_acq_rcsc (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     ((orb (acc.(AccessDescriptor_acqsc)) (acc.(AccessDescriptor_relsc)))).

Definition mem_acc_is_standalone (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     ((andb ((negb (acc.(AccessDescriptor_exclusive)))) ((negb (acc.(AccessDescriptor_atomicop)))))).

Definition mem_acc_is_exclusive (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     (acc.(AccessDescriptor_exclusive)).

Definition mem_acc_is_atomic_rmw (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     (acc.(AccessDescriptor_atomicop)).



Variant register_ProcState :=
  | PSTATE
.

Definition num_of_register_ProcState (r : register_ProcState) : Z :=
  match r with
  | PSTATE => 0
  end.
Definition register_ProcState_of_num (i : Z) : register_ProcState :=
  match i with
  | 0 => PSTATE
  | _ => PSTATE
  end.
Lemma register_ProcState_num_of_roundtrip (x : register_ProcState) : register_ProcState_of_num (num_of_register_ProcState x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_ProcState_injective (x y : register_ProcState) : num_of_register_ProcState x = num_of_register_ProcState y -> x = y.
  intro.
  rewrite <- (register_ProcState_num_of_roundtrip x).
  rewrite <- (register_ProcState_num_of_roundtrip y).
  congruence.
Qed.
Definition register_ProcState_eq_dec (x y : register_ProcState) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_ProcState x) (num_of_register_ProcState y) with
  | left e => left (num_of_register_ProcState_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_ProcState_beq (x y : register_ProcState) : bool :=
  Z.eqb (num_of_register_ProcState x) (num_of_register_ProcState y).
Lemma register_ProcState_beq_iff x y : register_ProcState_beq x y = true <-> x = y.
  unfold register_ProcState_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_ProcState_injective | congruence].
Qed.
Lemma register_ProcState_beq_refl x : register_ProcState_beq x x = true.
apply register_ProcState_beq_iff; reflexivity.
Qed.
Hint Rewrite register_ProcState_beq_iff : register_beq_iffs.
Hint Rewrite register_ProcState_beq_refl : register_beq_refls.
Definition register_ProcState_list : list (string * register_ProcState) := [
  ("PSTATE", PSTATE)
].

Instance Decidable_eq_register_ProcState : EqDecision register_ProcState := register_ProcState_eq_dec.
Instance Countable_register_ProcState : Countable register_ProcState. refine {|
  encode x := encode (num_of_register_ProcState x);
  decode x := register_ProcState_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_ProcState_num_of_roundtrip.
  reflexivity.
Defined.

Variant register_bitvector_64 :=
  | _PC
  | R30
  | R29
  | R28
  | R27
  | R26
  | R25
  | R24
  | R23
  | R22
  | R21
  | R20
  | R19
  | R18
  | R17
  | R16
  | R15
  | R14
  | R13
  | R12
  | R11
  | R10
  | R9
  | R8
  | R7
  | R6
  | R5
  | R4
  | R3
  | R2
  | R1
  | R0
  | SP_EL0
  | SP_EL1
  | SP_EL2
  | SP_EL3
  | ELR_EL1
  | ELR_EL2
  | ELR_EL3
  | ESR_EL1
  | ESR_EL2
  | ESR_EL3
  | FAR_EL1
  | FAR_EL2
  | FAR_EL3
  | PAR_EL1
  | TTBR0_EL1
  | TTBR1_EL1
  | TTBR0_EL2
  | TTBR1_EL2
  | TTBR0_EL3
  | VTTBR_EL2
  | VBAR_EL1
  | VBAR_EL2
  | VBAR_EL3
  | SPSR_EL1
  | SPSR_EL2
  | SPSR_EL3
  | ID_AA64MMFR0_EL1
  | ID_AA64MMFR1_EL1
  | ID_AA64MMFR2_EL1
  | ID_AA64MMFR3_EL1
  | ID_AA64MMFR4_EL1
  | TCR_EL1
  | TCR_EL2
  | TCR_EL3
  | VTCR_EL2
  | SCTLR_EL1
  | SCTLR_EL2
  | SCTLR_EL3
.

Definition num_of_register_bitvector_64 (r : register_bitvector_64) : Z :=
  match r with
  | _PC => 0
  | R30 => 1
  | R29 => 2
  | R28 => 3
  | R27 => 4
  | R26 => 5
  | R25 => 6
  | R24 => 7
  | R23 => 8
  | R22 => 9
  | R21 => 10
  | R20 => 11
  | R19 => 12
  | R18 => 13
  | R17 => 14
  | R16 => 15
  | R15 => 16
  | R14 => 17
  | R13 => 18
  | R12 => 19
  | R11 => 20
  | R10 => 21
  | R9 => 22
  | R8 => 23
  | R7 => 24
  | R6 => 25
  | R5 => 26
  | R4 => 27
  | R3 => 28
  | R2 => 29
  | R1 => 30
  | R0 => 31
  | SP_EL0 => 32
  | SP_EL1 => 33
  | SP_EL2 => 34
  | SP_EL3 => 35
  | ELR_EL1 => 36
  | ELR_EL2 => 37
  | ELR_EL3 => 38
  | ESR_EL1 => 39
  | ESR_EL2 => 40
  | ESR_EL3 => 41
  | FAR_EL1 => 42
  | FAR_EL2 => 43
  | FAR_EL3 => 44
  | PAR_EL1 => 45
  | TTBR0_EL1 => 46
  | TTBR1_EL1 => 47
  | TTBR0_EL2 => 48
  | TTBR1_EL2 => 49
  | TTBR0_EL3 => 50
  | VTTBR_EL2 => 51
  | VBAR_EL1 => 52
  | VBAR_EL2 => 53
  | VBAR_EL3 => 54
  | SPSR_EL1 => 55
  | SPSR_EL2 => 56
  | SPSR_EL3 => 57
  | ID_AA64MMFR0_EL1 => 58
  | ID_AA64MMFR1_EL1 => 59
  | ID_AA64MMFR2_EL1 => 60
  | ID_AA64MMFR3_EL1 => 61
  | ID_AA64MMFR4_EL1 => 62
  | TCR_EL1 => 63
  | TCR_EL2 => 64
  | TCR_EL3 => 65
  | VTCR_EL2 => 66
  | SCTLR_EL1 => 67
  | SCTLR_EL2 => 68
  | SCTLR_EL3 => 69
  end.
Definition register_bitvector_64_of_num (i : Z) : register_bitvector_64 :=
  match i with
  | 0 => _PC
  | 1 => R30
  | 2 => R29
  | 3 => R28
  | 4 => R27
  | 5 => R26
  | 6 => R25
  | 7 => R24
  | 8 => R23
  | 9 => R22
  | 10 => R21
  | 11 => R20
  | 12 => R19
  | 13 => R18
  | 14 => R17
  | 15 => R16
  | 16 => R15
  | 17 => R14
  | 18 => R13
  | 19 => R12
  | 20 => R11
  | 21 => R10
  | 22 => R9
  | 23 => R8
  | 24 => R7
  | 25 => R6
  | 26 => R5
  | 27 => R4
  | 28 => R3
  | 29 => R2
  | 30 => R1
  | 31 => R0
  | 32 => SP_EL0
  | 33 => SP_EL1
  | 34 => SP_EL2
  | 35 => SP_EL3
  | 36 => ELR_EL1
  | 37 => ELR_EL2
  | 38 => ELR_EL3
  | 39 => ESR_EL1
  | 40 => ESR_EL2
  | 41 => ESR_EL3
  | 42 => FAR_EL1
  | 43 => FAR_EL2
  | 44 => FAR_EL3
  | 45 => PAR_EL1
  | 46 => TTBR0_EL1
  | 47 => TTBR1_EL1
  | 48 => TTBR0_EL2
  | 49 => TTBR1_EL2
  | 50 => TTBR0_EL3
  | 51 => VTTBR_EL2
  | 52 => VBAR_EL1
  | 53 => VBAR_EL2
  | 54 => VBAR_EL3
  | 55 => SPSR_EL1
  | 56 => SPSR_EL2
  | 57 => SPSR_EL3
  | 58 => ID_AA64MMFR0_EL1
  | 59 => ID_AA64MMFR1_EL1
  | 60 => ID_AA64MMFR2_EL1
  | 61 => ID_AA64MMFR3_EL1
  | 62 => ID_AA64MMFR4_EL1
  | 63 => TCR_EL1
  | 64 => TCR_EL2
  | 65 => TCR_EL3
  | 66 => VTCR_EL2
  | 67 => SCTLR_EL1
  | 68 => SCTLR_EL2
  | 69 => SCTLR_EL3
  | _ => _PC
  end.
Lemma register_bitvector_64_num_of_roundtrip (x : register_bitvector_64) : register_bitvector_64_of_num (num_of_register_bitvector_64 x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_bitvector_64_injective (x y : register_bitvector_64) : num_of_register_bitvector_64 x = num_of_register_bitvector_64 y -> x = y.
  intro.
  rewrite <- (register_bitvector_64_num_of_roundtrip x).
  rewrite <- (register_bitvector_64_num_of_roundtrip y).
  congruence.
Qed.
Definition register_bitvector_64_eq_dec (x y : register_bitvector_64) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_bitvector_64 x) (num_of_register_bitvector_64 y) with
  | left e => left (num_of_register_bitvector_64_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_bitvector_64_beq (x y : register_bitvector_64) : bool :=
  Z.eqb (num_of_register_bitvector_64 x) (num_of_register_bitvector_64 y).
Lemma register_bitvector_64_beq_iff x y : register_bitvector_64_beq x y = true <-> x = y.
  unfold register_bitvector_64_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_bitvector_64_injective | congruence].
Qed.
Lemma register_bitvector_64_beq_refl x : register_bitvector_64_beq x x = true.
apply register_bitvector_64_beq_iff; reflexivity.
Qed.
Hint Rewrite register_bitvector_64_beq_iff : register_beq_iffs.
Hint Rewrite register_bitvector_64_beq_refl : register_beq_refls.
Definition register_bitvector_64_list : list (string * register_bitvector_64) := [
  ("_PC", _PC);
  ("R30", R30);
  ("R29", R29);
  ("R28", R28);
  ("R27", R27);
  ("R26", R26);
  ("R25", R25);
  ("R24", R24);
  ("R23", R23);
  ("R22", R22);
  ("R21", R21);
  ("R20", R20);
  ("R19", R19);
  ("R18", R18);
  ("R17", R17);
  ("R16", R16);
  ("R15", R15);
  ("R14", R14);
  ("R13", R13);
  ("R12", R12);
  ("R11", R11);
  ("R10", R10);
  ("R9", R9);
  ("R8", R8);
  ("R7", R7);
  ("R6", R6);
  ("R5", R5);
  ("R4", R4);
  ("R3", R3);
  ("R2", R2);
  ("R1", R1);
  ("R0", R0);
  ("SP_EL0", SP_EL0);
  ("SP_EL1", SP_EL1);
  ("SP_EL2", SP_EL2);
  ("SP_EL3", SP_EL3);
  ("ELR_EL1", ELR_EL1);
  ("ELR_EL2", ELR_EL2);
  ("ELR_EL3", ELR_EL3);
  ("ESR_EL1", ESR_EL1);
  ("ESR_EL2", ESR_EL2);
  ("ESR_EL3", ESR_EL3);
  ("FAR_EL1", FAR_EL1);
  ("FAR_EL2", FAR_EL2);
  ("FAR_EL3", FAR_EL3);
  ("PAR_EL1", PAR_EL1);
  ("TTBR0_EL1", TTBR0_EL1);
  ("TTBR1_EL1", TTBR1_EL1);
  ("TTBR0_EL2", TTBR0_EL2);
  ("TTBR1_EL2", TTBR1_EL2);
  ("TTBR0_EL3", TTBR0_EL3);
  ("VTTBR_EL2", VTTBR_EL2);
  ("VBAR_EL1", VBAR_EL1);
  ("VBAR_EL2", VBAR_EL2);
  ("VBAR_EL3", VBAR_EL3);
  ("SPSR_EL1", SPSR_EL1);
  ("SPSR_EL2", SPSR_EL2);
  ("SPSR_EL3", SPSR_EL3);
  ("ID_AA64MMFR0_EL1", ID_AA64MMFR0_EL1);
  ("ID_AA64MMFR1_EL1", ID_AA64MMFR1_EL1);
  ("ID_AA64MMFR2_EL1", ID_AA64MMFR2_EL1);
  ("ID_AA64MMFR3_EL1", ID_AA64MMFR3_EL1);
  ("ID_AA64MMFR4_EL1", ID_AA64MMFR4_EL1);
  ("TCR_EL1", TCR_EL1);
  ("TCR_EL2", TCR_EL2);
  ("TCR_EL3", TCR_EL3);
  ("VTCR_EL2", VTCR_EL2);
  ("SCTLR_EL1", SCTLR_EL1);
  ("SCTLR_EL2", SCTLR_EL2);
  ("SCTLR_EL3", SCTLR_EL3)
].

Instance Decidable_eq_register_bitvector_64 : EqDecision register_bitvector_64 := register_bitvector_64_eq_dec.
Instance Countable_register_bitvector_64 : Countable register_bitvector_64. refine {|
  encode x := encode (num_of_register_bitvector_64 x);
  decode x := register_bitvector_64_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_bitvector_64_num_of_roundtrip.
  reflexivity.
Defined.


Variant register : Type -> Type :=
  | R_ProcState :> register_ProcState -> register ProcState
  | R_bitvector_64 :> register_bitvector_64 -> register ((mword 64))
.
Add Keep Equalities register.

Module GRegister.
  Inductive greg := GReg [T : Type] (r : register T).

  (* The injection tactic can do too much, so prove a one-step lemma. *)
  Lemma greg_inj {T} {r r' : register T} : GReg r = GReg r' -> r = r'.
  Proof.
    intro e. injection e as e'.
    apply Eqdep.EqdepTheory.inj_pair2 in e'.
    assumption.
  Qed.

  Definition greg_proj1 (r : greg) : Type := match r with @GReg T _ => T end.
  Definition greg_proj2 (r : greg) : register (greg_proj1 r) := match r with @GReg _ r => r end.

  Definition greg_encode (r : greg) : positive :=
    match r with
    | GReg (R_ProcState r) => encode (0, encode r)
    | GReg (R_bitvector_64 r) => encode (1, encode r)
    end.
  Definition greg_type_encode (r : greg) : positive :=
    match r with
    | GReg (R_ProcState _r) => 1
    | GReg (R_bitvector_64 _r) => 2
    end.
  Definition greg_decode (x : positive) : option greg :=
    match decode x with
    | Some (0, y) => r ← decode y; mret (GReg (R_ProcState r))
    | Some (1, y) => r ← decode y; mret (GReg (R_bitvector_64 r))
    | _ => None
    end.
  Lemma greg_decode_encode r : greg_decode (greg_encode r) = Some r.
  Proof.
    destruct r as [T r']; destruct r';
    unfold greg_decode, greg_encode;
    rewrite !decode_encode;
    reflexivity.
  Qed.
  Lemma greg_encode_inj r r' : greg_encode r = greg_encode r' -> r = r'.
  Proof.
    intro H.
    enough (Some r = Some r') by congruence.
    rewrite <- (greg_decode_encode r).
    rewrite <- (greg_decode_encode r').
    congruence.
  Qed.
  #[export] Instance Decidable_eq_greg : EqDecision greg.
  refine (fun r r' => match Pos.eq_dec (greg_encode r) (greg_encode r') with
  | left e => left (greg_encode_inj _ _ e)
  | right ne => right _
  end).
  congruence.
  Defined.
  #[export] Instance Countable_greg : Countable greg := {|
    encode := greg_encode;
    decode := greg_decode;
    decode_encode := greg_decode_encode;
  |}.
End GRegister.

Require Import Eqdep.

Instance Decidable_eq_register {T} : EqDecision (register T).
refine (fun r r' => match GRegister.Decidable_eq_greg (GRegister.GReg r) (GRegister.GReg r') with
| left e => left _
| right ne => right _
end).
* by apply GRegister.greg_inj in e.
* intros e; subst; congruence.
Defined.

Definition register_transport {T T'} {P : Type -> Type} {r : register T} {r' : register T'} : GRegister.GReg r = GRegister.GReg r' -> P T -> P T'.
refine (
  match r, r' with
  | R_ProcState r, R_ProcState r' => fun _ x => x
  | R_bitvector_64 r, R_bitvector_64 r' => fun _ x => x
  | _, _ => fun e _ => _
  end
).
  all:
  enough (H : GRegister.greg_type_encode (GRegister.GReg r0) = GRegister.greg_type_encode (GRegister.GReg r1));
  [ simpl in H; congruence
  | rewrite e; reflexivity].
Defined.

Lemma register_transport_sound {T P} {r r' : register T} (e : GRegister.GReg r = GRegister.GReg r') (p : P T) :
  register_transport e p = p.
Proof.
  pose proof (e' := GRegister.greg_inj e).
  subst r'.
  destruct r; reflexivity.
Qed.

Definition register_beq {T T'} (r : register T) (r' : register T') : bool :=
  match r, r' with
  | R_ProcState r, R_ProcState r' => register_ProcState_beq r r'
  | R_bitvector_64 r, R_bitvector_64 r' => register_bitvector_64_beq r r'
  | _, _ => false
  end.

Lemma register_beq_refl {T} (r : register T) : register_beq r r = true.
destruct r; simpl; autorewrite with register_beq_refls; reflexivity.
Qed.

Definition register_eq_cast {T T'} (P : Type -> Type) (r : register T) (r' : register T') : P T -> option (P T') :=
  match r, r' with
  | R_ProcState r, R_ProcState r' => fun p => if register_ProcState_beq r r' then Some p else None
  | R_bitvector_64 r, R_bitvector_64 r' => fun p => if register_bitvector_64_beq r r' then Some p else None
  | _, _ => fun _ => None
  end.

Definition register_list : list (string * GRegister.greg) := List.concat [
  List.map (fun '(s, r) => (s, GRegister.GReg (R_ProcState r))) register_ProcState_list;
  List.map (fun '(s, r) => (s, GRegister.GReg (R_bitvector_64 r))) register_bitvector_64_list
].

Definition string_of_register {T} (r : register T) : string :=
  match List.find (fun '(_s, GRegister.GReg r') => register_beq r r') register_list with
  | Some (s, _r) => s
  | None => "<impossible>"
  end.

Definition register_of_string (s : string) : option GRegister.greg :=
  match List.find (fun '(s', _r) => String.eqb s s') register_list with
  | Some (_s, r) => Some r
  | None => None
  end.

Lemma string_of_register_roundtrip {T} (r : register T) :
  register_of_string (string_of_register r) = Some (GRegister.GReg r).
case r; intro r'; destruct r'; reflexivity.
Qed.

Lemma register_string_eq {T T'} (r : register T) (r' : register T') :
  register_beq r r' = String.eqb (string_of_register r) (string_of_register r').
destruct (Bool.reflect_dec _ _ (String.eqb_spec (string_of_register r) (string_of_register r'))) as [H|H].
* rewrite H, String.eqb_refl.
  specialize (string_of_register_roundtrip r) as H1.
  specialize (string_of_register_roundtrip r') as H2.
  rewrite H in H1.
  rewrite H2 in H1.
  assert (E : @GRegister.GReg T' r' = @GRegister.GReg T r). { congruence. }
  set (f := fun (r r' : GRegister.greg) => register_beq (GRegister.greg_proj2 r) (GRegister.greg_proj2 r')).
  change (register_beq r r') with (f (GRegister.GReg r) (GRegister.GReg r')).
  rewrite <- E.
  unfold f.
  apply register_beq_refl.
* apply String.eqb_neq in H as H'.
  rewrite H'.
  apply Bool.not_true_is_false.
  contradict H.
  destruct r,r'; simpl in H; try discriminate; autorewrite with register_beq_iffs in H; subst; reflexivity.
Qed.
#[export] Hint Extern 1 (register _) => assumption : typeclass_instances.
#[export] Instance Decidable_eq_register_values {T : Type} `(r : register T) : EqDecision T | 100 :=
match r with
  | R_ProcState _ => _
  | R_bitvector_64 _ => _
end.
#[export] Instance Inhabited_register_values {T : Type} `(r : register T) : Inhabited T | 100 :=
  match r with
  | R_ProcState _ => _
  | R_bitvector_64 _ => _
end.
#[export] Instance Countable_register_values {T : Type} `(r : register T) : Countable T | 100.
refine {|
  encode := match r in register T return T -> _ with
  | R_ProcState _ => encode
  | R_bitvector_64 _ => encode
  end;
  decode := match r in register T return _ -> option T with
  | R_ProcState _ => decode
  | R_bitvector_64 _ => decode
  end;
|}.
abstract (destruct r; apply decode_encode).
Defined.

Definition PSTATE_ref : register_ref register _ :=
  Build_register_ref register _ "PSTATE" PSTATE.
Instance dummy_register_ProcState : Inhabited (register_ref register _) := populate PSTATE_ref.

Definition _PC_ref : register_ref register _ :=
  Build_register_ref register _ "_PC" _PC.
Definition R30_ref : register_ref register _ :=
  Build_register_ref register _ "R30" R30.
Definition R29_ref : register_ref register _ :=
  Build_register_ref register _ "R29" R29.
Definition R28_ref : register_ref register _ :=
  Build_register_ref register _ "R28" R28.
Definition R27_ref : register_ref register _ :=
  Build_register_ref register _ "R27" R27.
Definition R26_ref : register_ref register _ :=
  Build_register_ref register _ "R26" R26.
Definition R25_ref : register_ref register _ :=
  Build_register_ref register _ "R25" R25.
Definition R24_ref : register_ref register _ :=
  Build_register_ref register _ "R24" R24.
Definition R23_ref : register_ref register _ :=
  Build_register_ref register _ "R23" R23.
Definition R22_ref : register_ref register _ :=
  Build_register_ref register _ "R22" R22.
Definition R21_ref : register_ref register _ :=
  Build_register_ref register _ "R21" R21.
Definition R20_ref : register_ref register _ :=
  Build_register_ref register _ "R20" R20.
Definition R19_ref : register_ref register _ :=
  Build_register_ref register _ "R19" R19.
Definition R18_ref : register_ref register _ :=
  Build_register_ref register _ "R18" R18.
Definition R17_ref : register_ref register _ :=
  Build_register_ref register _ "R17" R17.
Definition R16_ref : register_ref register _ :=
  Build_register_ref register _ "R16" R16.
Definition R15_ref : register_ref register _ :=
  Build_register_ref register _ "R15" R15.
Definition R14_ref : register_ref register _ :=
  Build_register_ref register _ "R14" R14.
Definition R13_ref : register_ref register _ :=
  Build_register_ref register _ "R13" R13.
Definition R12_ref : register_ref register _ :=
  Build_register_ref register _ "R12" R12.
Definition R11_ref : register_ref register _ :=
  Build_register_ref register _ "R11" R11.
Definition R10_ref : register_ref register _ :=
  Build_register_ref register _ "R10" R10.
Definition R9_ref : register_ref register _ :=
  Build_register_ref register _ "R9" R9.
Definition R8_ref : register_ref register _ :=
  Build_register_ref register _ "R8" R8.
Definition R7_ref : register_ref register _ :=
  Build_register_ref register _ "R7" R7.
Definition R6_ref : register_ref register _ :=
  Build_register_ref register _ "R6" R6.
Definition R5_ref : register_ref register _ :=
  Build_register_ref register _ "R5" R5.
Definition R4_ref : register_ref register _ :=
  Build_register_ref register _ "R4" R4.
Definition R3_ref : register_ref register _ :=
  Build_register_ref register _ "R3" R3.
Definition R2_ref : register_ref register _ :=
  Build_register_ref register _ "R2" R2.
Definition R1_ref : register_ref register _ :=
  Build_register_ref register _ "R1" R1.
Definition R0_ref : register_ref register _ :=
  Build_register_ref register _ "R0" R0.
Definition SP_EL0_ref : register_ref register _ :=
  Build_register_ref register _ "SP_EL0" SP_EL0.
Definition SP_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "SP_EL1" SP_EL1.
Definition SP_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "SP_EL2" SP_EL2.
Definition SP_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "SP_EL3" SP_EL3.
Definition ELR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "ELR_EL1" ELR_EL1.
Definition ELR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "ELR_EL2" ELR_EL2.
Definition ELR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "ELR_EL3" ELR_EL3.
Definition ESR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "ESR_EL1" ESR_EL1.
Definition ESR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "ESR_EL2" ESR_EL2.
Definition ESR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "ESR_EL3" ESR_EL3.
Definition FAR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "FAR_EL1" FAR_EL1.
Definition FAR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "FAR_EL2" FAR_EL2.
Definition FAR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "FAR_EL3" FAR_EL3.
Definition PAR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "PAR_EL1" PAR_EL1.
Definition TTBR0_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "TTBR0_EL1" TTBR0_EL1.
Definition TTBR1_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "TTBR1_EL1" TTBR1_EL1.
Definition TTBR0_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "TTBR0_EL2" TTBR0_EL2.
Definition TTBR1_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "TTBR1_EL2" TTBR1_EL2.
Definition TTBR0_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "TTBR0_EL3" TTBR0_EL3.
Definition VTTBR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "VTTBR_EL2" VTTBR_EL2.
Definition VBAR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "VBAR_EL1" VBAR_EL1.
Definition VBAR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "VBAR_EL2" VBAR_EL2.
Definition VBAR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "VBAR_EL3" VBAR_EL3.
Definition SPSR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "SPSR_EL1" SPSR_EL1.
Definition SPSR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "SPSR_EL2" SPSR_EL2.
Definition SPSR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "SPSR_EL3" SPSR_EL3.
Definition ID_AA64MMFR0_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "ID_AA64MMFR0_EL1" ID_AA64MMFR0_EL1.
Definition ID_AA64MMFR1_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "ID_AA64MMFR1_EL1" ID_AA64MMFR1_EL1.
Definition ID_AA64MMFR2_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "ID_AA64MMFR2_EL1" ID_AA64MMFR2_EL1.
Definition ID_AA64MMFR3_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "ID_AA64MMFR3_EL1" ID_AA64MMFR3_EL1.
Definition ID_AA64MMFR4_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "ID_AA64MMFR4_EL1" ID_AA64MMFR4_EL1.
Definition TCR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "TCR_EL1" TCR_EL1.
Definition TCR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "TCR_EL2" TCR_EL2.
Definition TCR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "TCR_EL3" TCR_EL3.
Definition VTCR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "VTCR_EL2" VTCR_EL2.
Definition SCTLR_EL1_ref : register_ref register _ :=
  Build_register_ref register _ "SCTLR_EL1" SCTLR_EL1.
Definition SCTLR_EL2_ref : register_ref register _ :=
  Build_register_ref register _ "SCTLR_EL2" SCTLR_EL2.
Definition SCTLR_EL3_ref : register_ref register _ :=
  Build_register_ref register _ "SCTLR_EL3" SCTLR_EL3.
Instance dummy_register_bitvector_64 : Inhabited (register_ref register _) := populate _PC_ref.


(* Definitions to support the lifting to the sequential monad *)
Record regstate := {
  ProcState_s : register_ProcState -> ProcState;
  bitvector_64_s : register_bitvector_64 -> mword 64;
}.
#[export] Instance eta_regstate : Settable _ := settable! Build_regstate <ProcState_s; bitvector_64_s>.

Definition init_regstate : regstate := Build_regstate
  inhabitant
  inhabitant
.

Definition register_lookup {T : Type} (reg : register T) (rs : regstate) : T :=
  match reg with
  | R_ProcState r => rs.(ProcState_s) r
  | R_bitvector_64 r => rs.(bitvector_64_s) r
  end.

Definition register_set {T : Type} (reg : register T) : T -> regstate -> regstate :=
  match reg with
  | R_ProcState r => fun v rs => rs <|ProcState_s := fun r' => if register_ProcState_beq r' r then v else rs.(ProcState_s) r'|>
  | R_bitvector_64 r => fun v rs => rs <|bitvector_64_s := fun r' => if register_bitvector_64_beq r' r then v else rs.(bitvector_64_s) r'|>
  end.

Lemma register_lookup_set {T} (r : register T) regs v: register_lookup r (register_set r v regs) = v.
destruct regs, r; simpl; autorewrite with register_beq_refls; reflexivity.
Qed.

Lemma irrelevant_register_set {T T'} (r : register T) (r' : register T') regs v:
  register_beq r r' = false ->
  register_lookup r (register_set r' v regs) = register_lookup r regs.
destruct regs, r, r'; simpl; intro EQ; rewrite ?EQ; reflexivity.
Qed.

Arguments register_set : simpl never.
Arguments register_lookup : simpl never.

Definition register_accessors : register_accessors regstate register := (@register_lookup, @register_set).


(* Instantiate library definitions with types. *)

Definition read_reg {A E} := @read_reg register A E.
Definition write_reg {A E} := @write_reg register A E.

Module Arch <: Arch.
  Definition reg : Type -> Type := register.
  Definition reg_eq := @Decidable_eq_register.
  Include GRegister.
  Definition greg_eq := @Decidable_eq_greg.
  Definition greg_cnt := @Countable_greg.
  Definition regval_inhabited := @Inhabited_register_values.
  Definition regval_eq := @Decidable_eq_register_values.
  Definition regval_cnt := @Countable_register_values.
  Definition regval_transport A B := @register_transport A B (fun x => x).
  Definition regval_transport_sound A := @register_transport_sound A (fun x => x).
  Definition addr_size : N := Z.to_N (addr_size).
  Definition addr_space : Type := addr_space.
  Definition addr_space_eq : EqDecision addr_space := _.
  Definition addr_space_countable : Countable addr_space := _.
  Definition mem_acc : Type := AccessDescriptor.
  Definition mem_acc_eq : EqDecision mem_acc := _.
  Definition mem_acc_countable : Countable mem_acc := _.
  Definition CHERI : bool := (false).
  Definition cap_size_log : N := 0.
  Definition mem_acc_is_explicit := mem_acc_is_explicit.
  Definition mem_acc_is_ifetch := mem_acc_is_ifetch.
  Definition mem_acc_is_ttw := mem_acc_is_ttw.
  Definition mem_acc_is_relaxed := mem_acc_is_relaxed.
  Definition mem_acc_is_rel_acq_rcpc := mem_acc_is_rel_acq_rcpc.
  Definition mem_acc_is_rel_acq_rcsc := mem_acc_is_rel_acq_rcsc.
  Definition mem_acc_is_standalone := mem_acc_is_standalone.
  Definition mem_acc_is_exclusive := mem_acc_is_exclusive.
  Definition mem_acc_is_atomic_rmw := mem_acc_is_atomic_rmw.
  Definition trans_start : Type := TranslationStartInfo.
  Definition trans_start_eq : EqDecision trans_start := _.
  Definition trans_start_countable : Countable trans_start := _.
  Definition trans_end : Type := AddressDescriptor.
  Definition trans_end_eq : EqDecision trans_end := _.
  Definition trans_end_countable : Countable trans_end := _.
  Definition abort : Type := abort.
  Definition abort_eq : EqDecision abort := _.
  Definition abort_countable : Countable abort := _.
  Definition barrier : Type := Barrier.
  Definition barrier_eq : EqDecision barrier := _.
  Definition barrier_countable : Countable barrier := _.
  Definition cache_op : Type := CacheRecord.
  Definition cache_op_eq : EqDecision cache_op := _.
  Definition cache_op_countable : Countable cache_op := _.
  Definition tlbi : Type := TLBIInfo.
  Definition tlbi_eq : EqDecision tlbi := _.
  Definition tlbi_countable : Countable tlbi := _.
  Definition exn : Type := (option FaultRecord).
  Definition exn_eq : EqDecision exn := _.
  Definition exn_countable : Countable exn := _.
  Definition sys_reg_id : Type := unit.
  Definition sys_reg_id_eq : EqDecision sys_reg_id := _.
  Definition sys_reg_id_countable : Countable sys_reg_id := _.
End Arch.

Module Interface := Interface Arch.
Module Defs := Defs Arch Interface.

Definition M := Defs.monad unit.
Definition MR r := Defs.monad (r + unit)%type.
Definition returnM {A:Type} : A -> M A := Defs.returnm (E := unit).
Definition returnR {A:Type} (R:Type) : A -> MR R A := Defs.returnm (E := R + unit)%type.