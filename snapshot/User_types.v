(*Generated by Sail from User.*)


From stdpp Require Import base countable.
Require Eqdep.
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import SailStdpp.ConcurrencyInterfaceTypes.
Require Import SailStdpp.ConcurrencyInterface.
Require Import SailStdpp.ConcurrencyInterfaceBuiltins.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.

Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.

Definition bits (n : Z) : Type := mword n.

Definition reg_index : Type := Z.

Inductive ast :=
| LoadRegister : (reg_index * reg_index * reg_index) -> ast
| StoreRegister : (reg_index * reg_index * reg_index) -> ast
| ExclusiveOr : (reg_index * reg_index * reg_index) -> ast
| DataMemoryBarrier : unit -> ast
| CompareAndBranch : (reg_index * bits 64) -> ast.
Arguments ast : clear implicits.

Definition sail_ast_encode (x : ast) := match x with
  | LoadRegister x' => encode (0, encode x')
  | StoreRegister x' => encode (1, encode x')
  | ExclusiveOr x' => encode (2, encode x')
  | DataMemoryBarrier x' => encode (3, encode x')
  | CompareAndBranch x' => encode (4, encode x') end.
Definition sail_ast_decode x : option ast := match decode x with
  | Some (0, x') => LoadRegister <$> decode x'
  | Some (1, x') => StoreRegister <$> decode x'
  | Some (2, x') => ExclusiveOr <$> decode x'
  | Some (3, x') => DataMemoryBarrier <$> decode x'
  | Some (4, x') => CompareAndBranch <$> decode x'
  | _ => None end.
Lemma sail_ast_decode_encode : forall (x : ast), sail_ast_decode (sail_ast_encode x)  = Some x.
Proof.
  unfold sail_ast_decode, sail_ast_encode;
  intros [x|x|x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_ast : EqDecision ast := decode_encode_eq_dec sail_ast_encode sail_ast_decode
  sail_ast_decode_encode .

#[export]
Instance Countable_ast : Countable ast := {|
  encode := sail_ast_encode;
  decode := sail_ast_decode;
  decode_encode := sail_ast_decode_encode
|}.
#[export]
Instance dummy_ast : Inhabited (ast) := { inhabitant := LoadRegister inhabitant }.

Inductive arm_acc_type :=
| SAcc_ASIMD : bool -> arm_acc_type
| SAcc_SVE : bool -> arm_acc_type
| SAcc_SME : bool -> arm_acc_type
| SAcc_IC : unit -> arm_acc_type
| SAcc_DC : unit -> arm_acc_type
| SAcc_DCZero : unit -> arm_acc_type
| SAcc_AT : unit -> arm_acc_type
| SAcc_NV2 : unit -> arm_acc_type
| SAcc_SPE : unit -> arm_acc_type
| SAcc_GCS : unit -> arm_acc_type
| SAcc_GPTW : unit -> arm_acc_type.
Arguments arm_acc_type : clear implicits.

Definition sail_arm_acc_type_encode (x : arm_acc_type) := match x with
  | SAcc_ASIMD x' => encode (0, encode x')
  | SAcc_SVE x' => encode (1, encode x')
  | SAcc_SME x' => encode (2, encode x')
  | SAcc_IC x' => encode (3, encode x')
  | SAcc_DC x' => encode (4, encode x')
  | SAcc_DCZero x' => encode (5, encode x')
  | SAcc_AT x' => encode (6, encode x')
  | SAcc_NV2 x' => encode (7, encode x')
  | SAcc_SPE x' => encode (8, encode x')
  | SAcc_GCS x' => encode (9, encode x')
  | SAcc_GPTW x' => encode (10, encode x') end.
Definition sail_arm_acc_type_decode x : option arm_acc_type := match decode x with
  | Some (0, x') => SAcc_ASIMD <$> decode x'
  | Some (1, x') => SAcc_SVE <$> decode x'
  | Some (2, x') => SAcc_SME <$> decode x'
  | Some (3, x') => SAcc_IC <$> decode x'
  | Some (4, x') => SAcc_DC <$> decode x'
  | Some (5, x') => SAcc_DCZero <$> decode x'
  | Some (6, x') => SAcc_AT <$> decode x'
  | Some (7, x') => SAcc_NV2 <$> decode x'
  | Some (8, x') => SAcc_SPE <$> decode x'
  | Some (9, x') => SAcc_GCS <$> decode x'
  | Some (10, x') => SAcc_GPTW <$> decode x'
  | _ => None end.
Lemma sail_arm_acc_type_decode_encode : forall (x : arm_acc_type), sail_arm_acc_type_decode
  (sail_arm_acc_type_encode x)  = Some x.
Proof.
  unfold sail_arm_acc_type_decode, sail_arm_acc_type_encode;
  intros [x|x|x|x|x|x|x|x|x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_arm_acc_type : EqDecision arm_acc_type := decode_encode_eq_dec
  sail_arm_acc_type_encode sail_arm_acc_type_decode sail_arm_acc_type_decode_encode .

#[export]
Instance Countable_arm_acc_type : Countable arm_acc_type := {|
  encode := sail_arm_acc_type_encode;
  decode := sail_arm_acc_type_decode;
  decode_encode := sail_arm_acc_type_decode_encode
|}.
#[export]
Instance dummy_arm_acc_type : Inhabited (arm_acc_type) := { inhabitant := SAcc_ASIMD inhabitant }.

Definition trans_info : Type := unit.

Definition addrsize : Z := 64.
#[export] Hint Unfold addrsize : sail.

Inductive MBReqDomain :=
  | MBReqDomain_Nonshareable
  | MBReqDomain_InnerShareable
  | MBReqDomain_OuterShareable
  | MBReqDomain_FullSystem.
Definition num_of_MBReqDomain (arg_ : MBReqDomain) : Z :=
   match arg_ with
   | MBReqDomain_Nonshareable => 0
   | MBReqDomain_InnerShareable => 1
   | MBReqDomain_OuterShareable => 2
   | MBReqDomain_FullSystem => 3
   end.

Definition MBReqDomain_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : MBReqDomain :=
   let l__37 := arg_ in
   if Z.eqb l__37 0 then MBReqDomain_Nonshareable
   else if Z.eqb l__37 1 then MBReqDomain_InnerShareable
   else if Z.eqb l__37 2 then MBReqDomain_OuterShareable
   else MBReqDomain_FullSystem.

Lemma MBReqDomain_num_of_roundtrip (x : MBReqDomain) : MBReqDomain_of_num (num_of_MBReqDomain x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MBReqDomain_injective (x y : MBReqDomain) : num_of_MBReqDomain x = num_of_MBReqDomain y -> x = y.
  intro.
  rewrite <- (MBReqDomain_num_of_roundtrip x).
  rewrite <- (MBReqDomain_num_of_roundtrip y).
  congruence.
Qed.
Definition MBReqDomain_eq_dec (x y : MBReqDomain) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MBReqDomain x) (num_of_MBReqDomain y) with
  | left e => left (num_of_MBReqDomain_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MBReqDomain_beq (x y : MBReqDomain) : bool :=
  Z.eqb (num_of_MBReqDomain x) (num_of_MBReqDomain y).
Lemma MBReqDomain_beq_iff x y : MBReqDomain_beq x y = true <-> x = y.
  unfold MBReqDomain_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MBReqDomain_injective | congruence].
Qed.
Lemma MBReqDomain_beq_refl x : MBReqDomain_beq x x = true.
apply MBReqDomain_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MBReqDomain : EqDecision MBReqDomain := MBReqDomain_eq_dec.
#[export]
Instance Countable_MBReqDomain : Countable MBReqDomain.
refine {|
  encode x := encode (num_of_MBReqDomain x);
  decode x := z ← decode x; mret (MBReqDomain_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MBReqDomain_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MBReqDomain : Inhabited MBReqDomain := { inhabitant := MBReqDomain_Nonshareable }.


Inductive MBReqTypes := MBReqTypes_Reads | MBReqTypes_Writes | MBReqTypes_All.
Definition num_of_MBReqTypes (arg_ : MBReqTypes) : Z :=
   match arg_ with | MBReqTypes_Reads => 0 | MBReqTypes_Writes => 1 | MBReqTypes_All => 2 end.

Definition MBReqTypes_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : MBReqTypes :=
   let l__35 := arg_ in
   if Z.eqb l__35 0 then MBReqTypes_Reads
   else if Z.eqb l__35 1 then MBReqTypes_Writes
   else MBReqTypes_All.

Lemma MBReqTypes_num_of_roundtrip (x : MBReqTypes) : MBReqTypes_of_num (num_of_MBReqTypes x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MBReqTypes_injective (x y : MBReqTypes) : num_of_MBReqTypes x = num_of_MBReqTypes y -> x = y.
  intro.
  rewrite <- (MBReqTypes_num_of_roundtrip x).
  rewrite <- (MBReqTypes_num_of_roundtrip y).
  congruence.
Qed.
Definition MBReqTypes_eq_dec (x y : MBReqTypes) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MBReqTypes x) (num_of_MBReqTypes y) with
  | left e => left (num_of_MBReqTypes_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MBReqTypes_beq (x y : MBReqTypes) : bool :=
  Z.eqb (num_of_MBReqTypes x) (num_of_MBReqTypes y).
Lemma MBReqTypes_beq_iff x y : MBReqTypes_beq x y = true <-> x = y.
  unfold MBReqTypes_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MBReqTypes_injective | congruence].
Qed.
Lemma MBReqTypes_beq_refl x : MBReqTypes_beq x x = true.
apply MBReqTypes_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MBReqTypes : EqDecision MBReqTypes := MBReqTypes_eq_dec.
#[export]
Instance Countable_MBReqTypes : Countable MBReqTypes.
refine {|
  encode x := encode (num_of_MBReqTypes x);
  decode x := z ← decode x; mret (MBReqTypes_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MBReqTypes_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MBReqTypes : Inhabited MBReqTypes := { inhabitant := MBReqTypes_Reads }.


Record DxB := {
  DxB_domain : MBReqDomain;
  DxB_types : MBReqTypes;
  DxB_nXS : bool;
}.
Arguments DxB : clear implicits.
#[export]
Instance Decidable_eq_DxB : EqDecision DxB.
   intros [x0 x1 x2].
   intros [y0 y1 y2].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_DxB : Countable DxB.
refine {|
  encode x := encode (DxB_domain x, DxB_types x, DxB_nXS x);
  decode x := '(x0, x1, x2) ← decode x;
              mret (Build_DxB x0 x1 x2)
|}.
abstract (
  intros [x0 x1 x2];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_DxB : Settable _ := settable! Build_DxB <DxB_domain; DxB_types; DxB_nXS>.
#[export]
Instance dummy_DxB : Inhabited (DxB) := {
  inhabitant := {| DxB_domain := inhabitant; DxB_types := inhabitant; DxB_nXS := inhabitant
|} }.


Inductive Barrier :=
| Barrier_DSB : DxB -> Barrier
| Barrier_DMB : DxB -> Barrier
| Barrier_ISB : unit -> Barrier
| Barrier_SSBB : unit -> Barrier
| Barrier_PSSBB : unit -> Barrier
| Barrier_SB : unit -> Barrier.
Arguments Barrier : clear implicits.

Definition sail_Barrier_encode (x : Barrier) := match x with
  | Barrier_DSB x' => encode (0, encode x')
  | Barrier_DMB x' => encode (1, encode x')
  | Barrier_ISB x' => encode (2, encode x')
  | Barrier_SSBB x' => encode (3, encode x')
  | Barrier_PSSBB x' => encode (4, encode x')
  | Barrier_SB x' => encode (5, encode x') end.
Definition sail_Barrier_decode x : option Barrier := match decode x with
  | Some (0, x') => Barrier_DSB <$> decode x'
  | Some (1, x') => Barrier_DMB <$> decode x'
  | Some (2, x') => Barrier_ISB <$> decode x'
  | Some (3, x') => Barrier_SSBB <$> decode x'
  | Some (4, x') => Barrier_PSSBB <$> decode x'
  | Some (5, x') => Barrier_SB <$> decode x'
  | _ => None end.
Lemma sail_Barrier_decode_encode : forall (x : Barrier), sail_Barrier_decode (sail_Barrier_encode x)
   = Some x.
Proof.
  unfold sail_Barrier_decode, sail_Barrier_encode;
  intros [x|x|x|x|x|x]; rewrite !decode_encode; reflexivity.
Qed.

#[export]
Instance Decidable_eq_Barrier : EqDecision Barrier := decode_encode_eq_dec sail_Barrier_encode
  sail_Barrier_decode sail_Barrier_decode_encode .

#[export]
Instance Countable_Barrier : Countable Barrier := {|
  encode := sail_Barrier_encode;
  decode := sail_Barrier_decode;
  decode_encode := sail_Barrier_decode_encode
|}.
#[export]
Instance dummy_Barrier : Inhabited (Barrier) := { inhabitant := Barrier_DSB inhabitant }.

Definition MAIRType : Type := mword 64.

Definition S1PIRType : Type := mword 64.

Definition S2PIRType : Type := mword 64.

Inductive SecurityState := SS_NonSecure | SS_Root | SS_Realm | SS_Secure.
Definition num_of_SecurityState (arg_ : SecurityState) : Z :=
   match arg_ with | SS_NonSecure => 0 | SS_Root => 1 | SS_Realm => 2 | SS_Secure => 3 end.

Definition SecurityState_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : SecurityState :=
   let l__130 := arg_ in
   if Z.eqb l__130 0 then SS_NonSecure
   else if Z.eqb l__130 1 then SS_Root
   else if Z.eqb l__130 2 then SS_Realm
   else SS_Secure.

Lemma SecurityState_num_of_roundtrip (x : SecurityState) : SecurityState_of_num (num_of_SecurityState x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_SecurityState_injective (x y : SecurityState) : num_of_SecurityState x = num_of_SecurityState y -> x = y.
  intro.
  rewrite <- (SecurityState_num_of_roundtrip x).
  rewrite <- (SecurityState_num_of_roundtrip y).
  congruence.
Qed.
Definition SecurityState_eq_dec (x y : SecurityState) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_SecurityState x) (num_of_SecurityState y) with
  | left e => left (num_of_SecurityState_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition SecurityState_beq (x y : SecurityState) : bool :=
  Z.eqb (num_of_SecurityState x) (num_of_SecurityState y).
Lemma SecurityState_beq_iff x y : SecurityState_beq x y = true <-> x = y.
  unfold SecurityState_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_SecurityState_injective | congruence].
Qed.
Lemma SecurityState_beq_refl x : SecurityState_beq x x = true.
apply SecurityState_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_SecurityState : EqDecision SecurityState := SecurityState_eq_dec.
#[export]
Instance Countable_SecurityState : Countable SecurityState.
refine {|
  encode x := encode (num_of_SecurityState x);
  decode x := z ← decode x; mret (SecurityState_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite SecurityState_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_SecurityState : Inhabited SecurityState := { inhabitant := SS_NonSecure }.


Definition PARTIDtype : Type := bits 16.

Definition PMGtype : Type := bits 8.

Inductive PARTIDspaceType := PIdSpace_Secure | PIdSpace_Root | PIdSpace_Realm | PIdSpace_NonSecure.
Definition num_of_PARTIDspaceType (arg_ : PARTIDspaceType) : Z :=
   match arg_ with
   | PIdSpace_Secure => 0
   | PIdSpace_Root => 1
   | PIdSpace_Realm => 2
   | PIdSpace_NonSecure => 3
   end.

Definition PARTIDspaceType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : PARTIDspaceType :=
   let l__127 := arg_ in
   if Z.eqb l__127 0 then PIdSpace_Secure
   else if Z.eqb l__127 1 then PIdSpace_Root
   else if Z.eqb l__127 2 then PIdSpace_Realm
   else PIdSpace_NonSecure.

Lemma PARTIDspaceType_num_of_roundtrip (x : PARTIDspaceType) : PARTIDspaceType_of_num (num_of_PARTIDspaceType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_PARTIDspaceType_injective (x y : PARTIDspaceType) : num_of_PARTIDspaceType x = num_of_PARTIDspaceType y -> x = y.
  intro.
  rewrite <- (PARTIDspaceType_num_of_roundtrip x).
  rewrite <- (PARTIDspaceType_num_of_roundtrip y).
  congruence.
Qed.
Definition PARTIDspaceType_eq_dec (x y : PARTIDspaceType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_PARTIDspaceType x) (num_of_PARTIDspaceType y) with
  | left e => left (num_of_PARTIDspaceType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition PARTIDspaceType_beq (x y : PARTIDspaceType) : bool :=
  Z.eqb (num_of_PARTIDspaceType x) (num_of_PARTIDspaceType y).
Lemma PARTIDspaceType_beq_iff x y : PARTIDspaceType_beq x y = true <-> x = y.
  unfold PARTIDspaceType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_PARTIDspaceType_injective | congruence].
Qed.
Lemma PARTIDspaceType_beq_refl x : PARTIDspaceType_beq x x = true.
apply PARTIDspaceType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_PARTIDspaceType : EqDecision PARTIDspaceType := PARTIDspaceType_eq_dec.
#[export]
Instance Countable_PARTIDspaceType : Countable PARTIDspaceType.
refine {|
  encode x := encode (num_of_PARTIDspaceType x);
  decode x := z ← decode x; mret (PARTIDspaceType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite PARTIDspaceType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_PARTIDspaceType : Inhabited PARTIDspaceType := { inhabitant := PIdSpace_Secure }.


Record MPAMinfo := {
  MPAMinfo_mpam_sp : PARTIDspaceType;
  MPAMinfo_partid : PARTIDtype;
  MPAMinfo_pmg : PMGtype;
}.
Arguments MPAMinfo : clear implicits.
#[export]
Instance Decidable_eq_MPAMinfo : EqDecision MPAMinfo.
   intros [x0 x1 x2].
   intros [y0 y1 y2].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_MPAMinfo : Countable MPAMinfo.
refine {|
  encode x := encode (MPAMinfo_mpam_sp x, MPAMinfo_partid x, MPAMinfo_pmg x);
  decode x := '(x0, x1, x2) ← decode x;
              mret (Build_MPAMinfo x0 x1 x2)
|}.
abstract (
  intros [x0 x1 x2];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_MPAMinfo : Settable _ := settable! Build_MPAMinfo <MPAMinfo_mpam_sp; MPAMinfo_partid; MPAMinfo_pmg>.
#[export]
Instance dummy_MPAMinfo : Inhabited (MPAMinfo) := {
  inhabitant := {|
    MPAMinfo_mpam_sp := inhabitant;
    MPAMinfo_partid := inhabitant;
    MPAMinfo_pmg := inhabitant
|} }.


Inductive AccessType :=
  | AccessType_IFETCH
  | AccessType_GPR
  | AccessType_ASIMD
  | AccessType_SVE
  | AccessType_SME
  | AccessType_IC
  | AccessType_DC
  | AccessType_DCZero
  | AccessType_AT
  | AccessType_NV2
  | AccessType_SPE
  | AccessType_GCS
  | AccessType_GPTW
  | AccessType_TTW.
Definition num_of_AccessType (arg_ : AccessType) : Z :=
   match arg_ with
   | AccessType_IFETCH => 0
   | AccessType_GPR => 1
   | AccessType_ASIMD => 2
   | AccessType_SVE => 3
   | AccessType_SME => 4
   | AccessType_IC => 5
   | AccessType_DC => 6
   | AccessType_DCZero => 7
   | AccessType_AT => 8
   | AccessType_NV2 => 9
   | AccessType_SPE => 10
   | AccessType_GCS => 11
   | AccessType_GPTW => 12
   | AccessType_TTW => 13
   end.

Definition AccessType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 13)*) : AccessType :=
   let l__114 := arg_ in
   if Z.eqb l__114 0 then AccessType_IFETCH
   else if Z.eqb l__114 1 then AccessType_GPR
   else if Z.eqb l__114 2 then AccessType_ASIMD
   else if Z.eqb l__114 3 then AccessType_SVE
   else if Z.eqb l__114 4 then AccessType_SME
   else if Z.eqb l__114 5 then AccessType_IC
   else if Z.eqb l__114 6 then AccessType_DC
   else if Z.eqb l__114 7 then AccessType_DCZero
   else if Z.eqb l__114 8 then AccessType_AT
   else if Z.eqb l__114 9 then AccessType_NV2
   else if Z.eqb l__114 10 then AccessType_SPE
   else if Z.eqb l__114 11 then AccessType_GCS
   else if Z.eqb l__114 12 then AccessType_GPTW
   else AccessType_TTW.

Lemma AccessType_num_of_roundtrip (x : AccessType) : AccessType_of_num (num_of_AccessType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_AccessType_injective (x y : AccessType) : num_of_AccessType x = num_of_AccessType y -> x = y.
  intro.
  rewrite <- (AccessType_num_of_roundtrip x).
  rewrite <- (AccessType_num_of_roundtrip y).
  congruence.
Qed.
Definition AccessType_eq_dec (x y : AccessType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_AccessType x) (num_of_AccessType y) with
  | left e => left (num_of_AccessType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition AccessType_beq (x y : AccessType) : bool :=
  Z.eqb (num_of_AccessType x) (num_of_AccessType y).
Lemma AccessType_beq_iff x y : AccessType_beq x y = true <-> x = y.
  unfold AccessType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_AccessType_injective | congruence].
Qed.
Lemma AccessType_beq_refl x : AccessType_beq x x = true.
apply AccessType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_AccessType : EqDecision AccessType := AccessType_eq_dec.
#[export]
Instance Countable_AccessType : Countable AccessType.
refine {|
  encode x := encode (num_of_AccessType x);
  decode x := z ← decode x; mret (AccessType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite AccessType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_AccessType : Inhabited AccessType := { inhabitant := AccessType_IFETCH }.


Inductive VARange := VARange_LOWER | VARange_UPPER.
Definition num_of_VARange (arg_ : VARange) : Z :=
   match arg_ with | VARange_LOWER => 0 | VARange_UPPER => 1 end.

Definition VARange_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : VARange :=
   let l__113 := arg_ in
   if Z.eqb l__113 0 then VARange_LOWER
   else VARange_UPPER.

Lemma VARange_num_of_roundtrip (x : VARange) : VARange_of_num (num_of_VARange x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_VARange_injective (x y : VARange) : num_of_VARange x = num_of_VARange y -> x = y.
  intro.
  rewrite <- (VARange_num_of_roundtrip x).
  rewrite <- (VARange_num_of_roundtrip y).
  congruence.
Qed.
Definition VARange_eq_dec (x y : VARange) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_VARange x) (num_of_VARange y) with
  | left e => left (num_of_VARange_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition VARange_beq (x y : VARange) : bool :=
  Z.eqb (num_of_VARange x) (num_of_VARange y).
Lemma VARange_beq_iff x y : VARange_beq x y = true <-> x = y.
  unfold VARange_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_VARange_injective | congruence].
Qed.
Lemma VARange_beq_refl x : VARange_beq x x = true.
apply VARange_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_VARange : EqDecision VARange := VARange_eq_dec.
#[export]
Instance Countable_VARange : Countable VARange.
refine {|
  encode x := encode (num_of_VARange x);
  decode x := z ← decode x; mret (VARange_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite VARange_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_VARange : Inhabited VARange := { inhabitant := VARange_LOWER }.


Inductive MemAtomicOp :=
  | MemAtomicOp_GCSSS1
  | MemAtomicOp_ADD
  | MemAtomicOp_BIC
  | MemAtomicOp_EOR
  | MemAtomicOp_ORR
  | MemAtomicOp_SMAX
  | MemAtomicOp_SMIN
  | MemAtomicOp_UMAX
  | MemAtomicOp_UMIN
  | MemAtomicOp_SWP
  | MemAtomicOp_CAS.
Definition num_of_MemAtomicOp (arg_ : MemAtomicOp) : Z :=
   match arg_ with
   | MemAtomicOp_GCSSS1 => 0
   | MemAtomicOp_ADD => 1
   | MemAtomicOp_BIC => 2
   | MemAtomicOp_EOR => 3
   | MemAtomicOp_ORR => 4
   | MemAtomicOp_SMAX => 5
   | MemAtomicOp_SMIN => 6
   | MemAtomicOp_UMAX => 7
   | MemAtomicOp_UMIN => 8
   | MemAtomicOp_SWP => 9
   | MemAtomicOp_CAS => 10
   end.

Definition MemAtomicOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 10)*) : MemAtomicOp :=
   let l__103 := arg_ in
   if Z.eqb l__103 0 then MemAtomicOp_GCSSS1
   else if Z.eqb l__103 1 then MemAtomicOp_ADD
   else if Z.eqb l__103 2 then MemAtomicOp_BIC
   else if Z.eqb l__103 3 then MemAtomicOp_EOR
   else if Z.eqb l__103 4 then MemAtomicOp_ORR
   else if Z.eqb l__103 5 then MemAtomicOp_SMAX
   else if Z.eqb l__103 6 then MemAtomicOp_SMIN
   else if Z.eqb l__103 7 then MemAtomicOp_UMAX
   else if Z.eqb l__103 8 then MemAtomicOp_UMIN
   else if Z.eqb l__103 9 then MemAtomicOp_SWP
   else MemAtomicOp_CAS.

Lemma MemAtomicOp_num_of_roundtrip (x : MemAtomicOp) : MemAtomicOp_of_num (num_of_MemAtomicOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MemAtomicOp_injective (x y : MemAtomicOp) : num_of_MemAtomicOp x = num_of_MemAtomicOp y -> x = y.
  intro.
  rewrite <- (MemAtomicOp_num_of_roundtrip x).
  rewrite <- (MemAtomicOp_num_of_roundtrip y).
  congruence.
Qed.
Definition MemAtomicOp_eq_dec (x y : MemAtomicOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MemAtomicOp x) (num_of_MemAtomicOp y) with
  | left e => left (num_of_MemAtomicOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MemAtomicOp_beq (x y : MemAtomicOp) : bool :=
  Z.eqb (num_of_MemAtomicOp x) (num_of_MemAtomicOp y).
Lemma MemAtomicOp_beq_iff x y : MemAtomicOp_beq x y = true <-> x = y.
  unfold MemAtomicOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MemAtomicOp_injective | congruence].
Qed.
Lemma MemAtomicOp_beq_refl x : MemAtomicOp_beq x x = true.
apply MemAtomicOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MemAtomicOp : EqDecision MemAtomicOp := MemAtomicOp_eq_dec.
#[export]
Instance Countable_MemAtomicOp : Countable MemAtomicOp.
refine {|
  encode x := encode (num_of_MemAtomicOp x);
  decode x := z ← decode x; mret (MemAtomicOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MemAtomicOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MemAtomicOp : Inhabited MemAtomicOp := { inhabitant := MemAtomicOp_GCSSS1 }.


Inductive CacheOp := CacheOp_Clean | CacheOp_Invalidate | CacheOp_CleanInvalidate.
Definition num_of_CacheOp (arg_ : CacheOp) : Z :=
   match arg_ with | CacheOp_Clean => 0 | CacheOp_Invalidate => 1 | CacheOp_CleanInvalidate => 2 end.

Definition CacheOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : CacheOp :=
   let l__101 := arg_ in
   if Z.eqb l__101 0 then CacheOp_Clean
   else if Z.eqb l__101 1 then CacheOp_Invalidate
   else CacheOp_CleanInvalidate.

Lemma CacheOp_num_of_roundtrip (x : CacheOp) : CacheOp_of_num (num_of_CacheOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_CacheOp_injective (x y : CacheOp) : num_of_CacheOp x = num_of_CacheOp y -> x = y.
  intro.
  rewrite <- (CacheOp_num_of_roundtrip x).
  rewrite <- (CacheOp_num_of_roundtrip y).
  congruence.
Qed.
Definition CacheOp_eq_dec (x y : CacheOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_CacheOp x) (num_of_CacheOp y) with
  | left e => left (num_of_CacheOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition CacheOp_beq (x y : CacheOp) : bool :=
  Z.eqb (num_of_CacheOp x) (num_of_CacheOp y).
Lemma CacheOp_beq_iff x y : CacheOp_beq x y = true <-> x = y.
  unfold CacheOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_CacheOp_injective | congruence].
Qed.
Lemma CacheOp_beq_refl x : CacheOp_beq x x = true.
apply CacheOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_CacheOp : EqDecision CacheOp := CacheOp_eq_dec.
#[export]
Instance Countable_CacheOp : Countable CacheOp.
refine {|
  encode x := encode (num_of_CacheOp x);
  decode x := z ← decode x; mret (CacheOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite CacheOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_CacheOp : Inhabited CacheOp := { inhabitant := CacheOp_Clean }.


Inductive CacheOpScope :=
  | CacheOpScope_SetWay
  | CacheOpScope_PoU
  | CacheOpScope_PoC
  | CacheOpScope_PoE
  | CacheOpScope_PoP
  | CacheOpScope_PoDP
  | CacheOpScope_PoPA
  | CacheOpScope_ALLU
  | CacheOpScope_ALLUIS.
Definition num_of_CacheOpScope (arg_ : CacheOpScope) : Z :=
   match arg_ with
   | CacheOpScope_SetWay => 0
   | CacheOpScope_PoU => 1
   | CacheOpScope_PoC => 2
   | CacheOpScope_PoE => 3
   | CacheOpScope_PoP => 4
   | CacheOpScope_PoDP => 5
   | CacheOpScope_PoPA => 6
   | CacheOpScope_ALLU => 7
   | CacheOpScope_ALLUIS => 8
   end.

Definition CacheOpScope_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 8)*) : CacheOpScope :=
   let l__93 := arg_ in
   if Z.eqb l__93 0 then CacheOpScope_SetWay
   else if Z.eqb l__93 1 then CacheOpScope_PoU
   else if Z.eqb l__93 2 then CacheOpScope_PoC
   else if Z.eqb l__93 3 then CacheOpScope_PoE
   else if Z.eqb l__93 4 then CacheOpScope_PoP
   else if Z.eqb l__93 5 then CacheOpScope_PoDP
   else if Z.eqb l__93 6 then CacheOpScope_PoPA
   else if Z.eqb l__93 7 then CacheOpScope_ALLU
   else CacheOpScope_ALLUIS.

Lemma CacheOpScope_num_of_roundtrip (x : CacheOpScope) : CacheOpScope_of_num (num_of_CacheOpScope x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_CacheOpScope_injective (x y : CacheOpScope) : num_of_CacheOpScope x = num_of_CacheOpScope y -> x = y.
  intro.
  rewrite <- (CacheOpScope_num_of_roundtrip x).
  rewrite <- (CacheOpScope_num_of_roundtrip y).
  congruence.
Qed.
Definition CacheOpScope_eq_dec (x y : CacheOpScope) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_CacheOpScope x) (num_of_CacheOpScope y) with
  | left e => left (num_of_CacheOpScope_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition CacheOpScope_beq (x y : CacheOpScope) : bool :=
  Z.eqb (num_of_CacheOpScope x) (num_of_CacheOpScope y).
Lemma CacheOpScope_beq_iff x y : CacheOpScope_beq x y = true <-> x = y.
  unfold CacheOpScope_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_CacheOpScope_injective | congruence].
Qed.
Lemma CacheOpScope_beq_refl x : CacheOpScope_beq x x = true.
apply CacheOpScope_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_CacheOpScope : EqDecision CacheOpScope := CacheOpScope_eq_dec.
#[export]
Instance Countable_CacheOpScope : Countable CacheOpScope.
refine {|
  encode x := encode (num_of_CacheOpScope x);
  decode x := z ← decode x; mret (CacheOpScope_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite CacheOpScope_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_CacheOpScope : Inhabited CacheOpScope := { inhabitant := CacheOpScope_SetWay }.


Inductive CacheType := CacheType_Data | CacheType_Tag | CacheType_Data_Tag | CacheType_Instruction.
Definition num_of_CacheType (arg_ : CacheType) : Z :=
   match arg_ with
   | CacheType_Data => 0
   | CacheType_Tag => 1
   | CacheType_Data_Tag => 2
   | CacheType_Instruction => 3
   end.

Definition CacheType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : CacheType :=
   let l__90 := arg_ in
   if Z.eqb l__90 0 then CacheType_Data
   else if Z.eqb l__90 1 then CacheType_Tag
   else if Z.eqb l__90 2 then CacheType_Data_Tag
   else CacheType_Instruction.

Lemma CacheType_num_of_roundtrip (x : CacheType) : CacheType_of_num (num_of_CacheType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_CacheType_injective (x y : CacheType) : num_of_CacheType x = num_of_CacheType y -> x = y.
  intro.
  rewrite <- (CacheType_num_of_roundtrip x).
  rewrite <- (CacheType_num_of_roundtrip y).
  congruence.
Qed.
Definition CacheType_eq_dec (x y : CacheType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_CacheType x) (num_of_CacheType y) with
  | left e => left (num_of_CacheType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition CacheType_beq (x y : CacheType) : bool :=
  Z.eqb (num_of_CacheType x) (num_of_CacheType y).
Lemma CacheType_beq_iff x y : CacheType_beq x y = true <-> x = y.
  unfold CacheType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_CacheType_injective | congruence].
Qed.
Lemma CacheType_beq_refl x : CacheType_beq x x = true.
apply CacheType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_CacheType : EqDecision CacheType := CacheType_eq_dec.
#[export]
Instance Countable_CacheType : Countable CacheType.
refine {|
  encode x := encode (num_of_CacheType x);
  decode x := z ← decode x; mret (CacheType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite CacheType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_CacheType : Inhabited CacheType := { inhabitant := CacheType_Data }.


Inductive CachePASpace :=
  | CPAS_NonSecure
  | CPAS_Any
  | CPAS_RealmNonSecure
  | CPAS_Realm
  | CPAS_Root
  | CPAS_SecureNonSecure
  | CPAS_Secure.
Definition num_of_CachePASpace (arg_ : CachePASpace) : Z :=
   match arg_ with
   | CPAS_NonSecure => 0
   | CPAS_Any => 1
   | CPAS_RealmNonSecure => 2
   | CPAS_Realm => 3
   | CPAS_Root => 4
   | CPAS_SecureNonSecure => 5
   | CPAS_Secure => 6
   end.

Definition CachePASpace_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 6)*) : CachePASpace :=
   let l__84 := arg_ in
   if Z.eqb l__84 0 then CPAS_NonSecure
   else if Z.eqb l__84 1 then CPAS_Any
   else if Z.eqb l__84 2 then CPAS_RealmNonSecure
   else if Z.eqb l__84 3 then CPAS_Realm
   else if Z.eqb l__84 4 then CPAS_Root
   else if Z.eqb l__84 5 then CPAS_SecureNonSecure
   else CPAS_Secure.

Lemma CachePASpace_num_of_roundtrip (x : CachePASpace) : CachePASpace_of_num (num_of_CachePASpace x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_CachePASpace_injective (x y : CachePASpace) : num_of_CachePASpace x = num_of_CachePASpace y -> x = y.
  intro.
  rewrite <- (CachePASpace_num_of_roundtrip x).
  rewrite <- (CachePASpace_num_of_roundtrip y).
  congruence.
Qed.
Definition CachePASpace_eq_dec (x y : CachePASpace) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_CachePASpace x) (num_of_CachePASpace y) with
  | left e => left (num_of_CachePASpace_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition CachePASpace_beq (x y : CachePASpace) : bool :=
  Z.eqb (num_of_CachePASpace x) (num_of_CachePASpace y).
Lemma CachePASpace_beq_iff x y : CachePASpace_beq x y = true <-> x = y.
  unfold CachePASpace_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_CachePASpace_injective | congruence].
Qed.
Lemma CachePASpace_beq_refl x : CachePASpace_beq x x = true.
apply CachePASpace_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_CachePASpace : EqDecision CachePASpace := CachePASpace_eq_dec.
#[export]
Instance Countable_CachePASpace : Countable CachePASpace.
refine {|
  encode x := encode (num_of_CachePASpace x);
  decode x := z ← decode x; mret (CachePASpace_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite CachePASpace_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_CachePASpace : Inhabited CachePASpace := { inhabitant := CPAS_NonSecure }.


Record AccessDescriptor := {
  AccessDescriptor_acctype : AccessType;
  AccessDescriptor_el : bits 2;
  AccessDescriptor_ss : SecurityState;
  AccessDescriptor_acqsc : bool;
  AccessDescriptor_acqpc : bool;
  AccessDescriptor_relsc : bool;
  AccessDescriptor_limitedordered : bool;
  AccessDescriptor_exclusive : bool;
  AccessDescriptor_atomicop : bool;
  AccessDescriptor_modop : MemAtomicOp;
  AccessDescriptor_nontemporal : bool;
  AccessDescriptor_read : bool;
  AccessDescriptor_write : bool;
  AccessDescriptor_cacheop : CacheOp;
  AccessDescriptor_opscope : CacheOpScope;
  AccessDescriptor_cachetype : CacheType;
  AccessDescriptor_pan : bool;
  AccessDescriptor_transactional : bool;
  AccessDescriptor_nonfault : bool;
  AccessDescriptor_firstfault : bool;
  AccessDescriptor_first : bool;
  AccessDescriptor_contiguous : bool;
  AccessDescriptor_streamingsve : bool;
  AccessDescriptor_ls64 : bool;
  AccessDescriptor_mops : bool;
  AccessDescriptor_rcw : bool;
  AccessDescriptor_rcws : bool;
  AccessDescriptor_toplevel : bool;
  AccessDescriptor_varange : VARange;
  AccessDescriptor_a32lsmd : bool;
  AccessDescriptor_tagchecked : bool;
  AccessDescriptor_tagaccess : bool;
  AccessDescriptor_mpam : MPAMinfo;
}.
Arguments AccessDescriptor : clear implicits.
#[export]
Instance Decidable_eq_AccessDescriptor : EqDecision AccessDescriptor.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16 y17 y18 y19 y20 y21 y22 y23 y24 y25 y26 y27 y28 y29 y30 y31 y32].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
  cmp_record_field x15 y15.
  cmp_record_field x16 y16.
  cmp_record_field x17 y17.
  cmp_record_field x18 y18.
  cmp_record_field x19 y19.
  cmp_record_field x20 y20.
  cmp_record_field x21 y21.
  cmp_record_field x22 y22.
  cmp_record_field x23 y23.
  cmp_record_field x24 y24.
  cmp_record_field x25 y25.
  cmp_record_field x26 y26.
  cmp_record_field x27 y27.
  cmp_record_field x28 y28.
  cmp_record_field x29 y29.
  cmp_record_field x30 y30.
  cmp_record_field x31 y31.
  cmp_record_field x32 y32.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_AccessDescriptor : Countable AccessDescriptor.
refine {|
  encode x := encode (AccessDescriptor_acctype x, AccessDescriptor_el x, AccessDescriptor_ss x, AccessDescriptor_acqsc x, AccessDescriptor_acqpc x, AccessDescriptor_relsc x, AccessDescriptor_limitedordered x, AccessDescriptor_exclusive x, AccessDescriptor_atomicop x, AccessDescriptor_modop x, AccessDescriptor_nontemporal x, AccessDescriptor_read x, AccessDescriptor_write x, AccessDescriptor_cacheop x, AccessDescriptor_opscope x, AccessDescriptor_cachetype x, AccessDescriptor_pan x, AccessDescriptor_transactional x, AccessDescriptor_nonfault x, AccessDescriptor_firstfault x, AccessDescriptor_first x, AccessDescriptor_contiguous x, AccessDescriptor_streamingsve x, AccessDescriptor_ls64 x, AccessDescriptor_mops x, AccessDescriptor_rcw x, AccessDescriptor_rcws x, AccessDescriptor_toplevel x, AccessDescriptor_varange x, AccessDescriptor_a32lsmd x, AccessDescriptor_tagchecked x, AccessDescriptor_tagaccess x, AccessDescriptor_mpam x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32) ← decode x;
              mret (Build_AccessDescriptor x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_AccessDescriptor : Settable _ := settable! Build_AccessDescriptor <AccessDescriptor_acctype; AccessDescriptor_el; AccessDescriptor_ss; AccessDescriptor_acqsc; AccessDescriptor_acqpc; AccessDescriptor_relsc; AccessDescriptor_limitedordered; AccessDescriptor_exclusive; AccessDescriptor_atomicop; AccessDescriptor_modop; AccessDescriptor_nontemporal; AccessDescriptor_read; AccessDescriptor_write; AccessDescriptor_cacheop; AccessDescriptor_opscope; AccessDescriptor_cachetype; AccessDescriptor_pan; AccessDescriptor_transactional; AccessDescriptor_nonfault; AccessDescriptor_firstfault; AccessDescriptor_first; AccessDescriptor_contiguous; AccessDescriptor_streamingsve; AccessDescriptor_ls64; AccessDescriptor_mops; AccessDescriptor_rcw; AccessDescriptor_rcws; AccessDescriptor_toplevel; AccessDescriptor_varange; AccessDescriptor_a32lsmd; AccessDescriptor_tagchecked; AccessDescriptor_tagaccess; AccessDescriptor_mpam>.
#[export]
Instance dummy_AccessDescriptor : Inhabited (AccessDescriptor) := {
  inhabitant := {|
    AccessDescriptor_acctype := inhabitant;
    AccessDescriptor_el := inhabitant;
    AccessDescriptor_ss := inhabitant;
    AccessDescriptor_acqsc := inhabitant;
    AccessDescriptor_acqpc := inhabitant;
    AccessDescriptor_relsc := inhabitant;
    AccessDescriptor_limitedordered := inhabitant;
    AccessDescriptor_exclusive := inhabitant;
    AccessDescriptor_atomicop := inhabitant;
    AccessDescriptor_modop := inhabitant;
    AccessDescriptor_nontemporal := inhabitant;
    AccessDescriptor_read := inhabitant;
    AccessDescriptor_write := inhabitant;
    AccessDescriptor_cacheop := inhabitant;
    AccessDescriptor_opscope := inhabitant;
    AccessDescriptor_cachetype := inhabitant;
    AccessDescriptor_pan := inhabitant;
    AccessDescriptor_transactional := inhabitant;
    AccessDescriptor_nonfault := inhabitant;
    AccessDescriptor_firstfault := inhabitant;
    AccessDescriptor_first := inhabitant;
    AccessDescriptor_contiguous := inhabitant;
    AccessDescriptor_streamingsve := inhabitant;
    AccessDescriptor_ls64 := inhabitant;
    AccessDescriptor_mops := inhabitant;
    AccessDescriptor_rcw := inhabitant;
    AccessDescriptor_rcws := inhabitant;
    AccessDescriptor_toplevel := inhabitant;
    AccessDescriptor_varange := inhabitant;
    AccessDescriptor_a32lsmd := inhabitant;
    AccessDescriptor_tagchecked := inhabitant;
    AccessDescriptor_tagaccess := inhabitant;
    AccessDescriptor_mpam := inhabitant
|} }.


Inductive MemType := MemType_Normal | MemType_Device.
Definition num_of_MemType (arg_ : MemType) : Z :=
   match arg_ with | MemType_Normal => 0 | MemType_Device => 1 end.

Definition MemType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : MemType :=
   let l__83 := arg_ in
   if Z.eqb l__83 0 then MemType_Normal
   else MemType_Device.

Lemma MemType_num_of_roundtrip (x : MemType) : MemType_of_num (num_of_MemType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MemType_injective (x y : MemType) : num_of_MemType x = num_of_MemType y -> x = y.
  intro.
  rewrite <- (MemType_num_of_roundtrip x).
  rewrite <- (MemType_num_of_roundtrip y).
  congruence.
Qed.
Definition MemType_eq_dec (x y : MemType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MemType x) (num_of_MemType y) with
  | left e => left (num_of_MemType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MemType_beq (x y : MemType) : bool :=
  Z.eqb (num_of_MemType x) (num_of_MemType y).
Lemma MemType_beq_iff x y : MemType_beq x y = true <-> x = y.
  unfold MemType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MemType_injective | congruence].
Qed.
Lemma MemType_beq_refl x : MemType_beq x x = true.
apply MemType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MemType : EqDecision MemType := MemType_eq_dec.
#[export]
Instance Countable_MemType : Countable MemType.
refine {|
  encode x := encode (num_of_MemType x);
  decode x := z ← decode x; mret (MemType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MemType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MemType : Inhabited MemType := { inhabitant := MemType_Normal }.


Inductive DeviceType := DeviceType_GRE | DeviceType_nGRE | DeviceType_nGnRE | DeviceType_nGnRnE.
Definition num_of_DeviceType (arg_ : DeviceType) : Z :=
   match arg_ with
   | DeviceType_GRE => 0
   | DeviceType_nGRE => 1
   | DeviceType_nGnRE => 2
   | DeviceType_nGnRnE => 3
   end.

Definition DeviceType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : DeviceType :=
   let l__80 := arg_ in
   if Z.eqb l__80 0 then DeviceType_GRE
   else if Z.eqb l__80 1 then DeviceType_nGRE
   else if Z.eqb l__80 2 then DeviceType_nGnRE
   else DeviceType_nGnRnE.

Lemma DeviceType_num_of_roundtrip (x : DeviceType) : DeviceType_of_num (num_of_DeviceType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_DeviceType_injective (x y : DeviceType) : num_of_DeviceType x = num_of_DeviceType y -> x = y.
  intro.
  rewrite <- (DeviceType_num_of_roundtrip x).
  rewrite <- (DeviceType_num_of_roundtrip y).
  congruence.
Qed.
Definition DeviceType_eq_dec (x y : DeviceType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_DeviceType x) (num_of_DeviceType y) with
  | left e => left (num_of_DeviceType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition DeviceType_beq (x y : DeviceType) : bool :=
  Z.eqb (num_of_DeviceType x) (num_of_DeviceType y).
Lemma DeviceType_beq_iff x y : DeviceType_beq x y = true <-> x = y.
  unfold DeviceType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_DeviceType_injective | congruence].
Qed.
Lemma DeviceType_beq_refl x : DeviceType_beq x x = true.
apply DeviceType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_DeviceType : EqDecision DeviceType := DeviceType_eq_dec.
#[export]
Instance Countable_DeviceType : Countable DeviceType.
refine {|
  encode x := encode (num_of_DeviceType x);
  decode x := z ← decode x; mret (DeviceType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite DeviceType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_DeviceType : Inhabited DeviceType := { inhabitant := DeviceType_GRE }.


Record MemAttrHints := {
  MemAttrHints_attrs : bits 2;
  MemAttrHints_hints : bits 2;
  MemAttrHints_transient : bool;
}.
Arguments MemAttrHints : clear implicits.
#[export]
Instance Decidable_eq_MemAttrHints : EqDecision MemAttrHints.
   intros [x0 x1 x2].
   intros [y0 y1 y2].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_MemAttrHints : Countable MemAttrHints.
refine {|
  encode x := encode (MemAttrHints_attrs x, MemAttrHints_hints x, MemAttrHints_transient x);
  decode x := '(x0, x1, x2) ← decode x;
              mret (Build_MemAttrHints x0 x1 x2)
|}.
abstract (
  intros [x0 x1 x2];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_MemAttrHints : Settable _ := settable! Build_MemAttrHints <MemAttrHints_attrs; MemAttrHints_hints; MemAttrHints_transient>.
#[export]
Instance dummy_MemAttrHints : Inhabited (MemAttrHints) := {
  inhabitant := {|
    MemAttrHints_attrs := inhabitant;
    MemAttrHints_hints := inhabitant;
    MemAttrHints_transient := inhabitant
|} }.


Inductive Shareability := Shareability_NSH | Shareability_ISH | Shareability_OSH.
Definition num_of_Shareability (arg_ : Shareability) : Z :=
   match arg_ with | Shareability_NSH => 0 | Shareability_ISH => 1 | Shareability_OSH => 2 end.

Definition Shareability_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : Shareability :=
   let l__78 := arg_ in
   if Z.eqb l__78 0 then Shareability_NSH
   else if Z.eqb l__78 1 then Shareability_ISH
   else Shareability_OSH.

Lemma Shareability_num_of_roundtrip (x : Shareability) : Shareability_of_num (num_of_Shareability x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_Shareability_injective (x y : Shareability) : num_of_Shareability x = num_of_Shareability y -> x = y.
  intro.
  rewrite <- (Shareability_num_of_roundtrip x).
  rewrite <- (Shareability_num_of_roundtrip y).
  congruence.
Qed.
Definition Shareability_eq_dec (x y : Shareability) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_Shareability x) (num_of_Shareability y) with
  | left e => left (num_of_Shareability_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition Shareability_beq (x y : Shareability) : bool :=
  Z.eqb (num_of_Shareability x) (num_of_Shareability y).
Lemma Shareability_beq_iff x y : Shareability_beq x y = true <-> x = y.
  unfold Shareability_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_Shareability_injective | congruence].
Qed.
Lemma Shareability_beq_refl x : Shareability_beq x x = true.
apply Shareability_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_Shareability : EqDecision Shareability := Shareability_eq_dec.
#[export]
Instance Countable_Shareability : Countable Shareability.
refine {|
  encode x := encode (num_of_Shareability x);
  decode x := z ← decode x; mret (Shareability_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite Shareability_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_Shareability : Inhabited Shareability := { inhabitant := Shareability_NSH }.


Inductive MemTagType := MemTag_Untagged | MemTag_AllocationTagged | MemTag_CanonicallyTagged.
Definition num_of_MemTagType (arg_ : MemTagType) : Z :=
   match arg_ with
   | MemTag_Untagged => 0
   | MemTag_AllocationTagged => 1
   | MemTag_CanonicallyTagged => 2
   end.

Definition MemTagType_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : MemTagType :=
   let l__76 := arg_ in
   if Z.eqb l__76 0 then MemTag_Untagged
   else if Z.eqb l__76 1 then MemTag_AllocationTagged
   else MemTag_CanonicallyTagged.

Lemma MemTagType_num_of_roundtrip (x : MemTagType) : MemTagType_of_num (num_of_MemTagType x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_MemTagType_injective (x y : MemTagType) : num_of_MemTagType x = num_of_MemTagType y -> x = y.
  intro.
  rewrite <- (MemTagType_num_of_roundtrip x).
  rewrite <- (MemTagType_num_of_roundtrip y).
  congruence.
Qed.
Definition MemTagType_eq_dec (x y : MemTagType) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_MemTagType x) (num_of_MemTagType y) with
  | left e => left (num_of_MemTagType_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition MemTagType_beq (x y : MemTagType) : bool :=
  Z.eqb (num_of_MemTagType x) (num_of_MemTagType y).
Lemma MemTagType_beq_iff x y : MemTagType_beq x y = true <-> x = y.
  unfold MemTagType_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_MemTagType_injective | congruence].
Qed.
Lemma MemTagType_beq_refl x : MemTagType_beq x x = true.
apply MemTagType_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_MemTagType : EqDecision MemTagType := MemTagType_eq_dec.
#[export]
Instance Countable_MemTagType : Countable MemTagType.
refine {|
  encode x := encode (num_of_MemTagType x);
  decode x := z ← decode x; mret (MemTagType_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite MemTagType_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_MemTagType : Inhabited MemTagType := { inhabitant := MemTag_Untagged }.


Record MemoryAttributes := {
  MemoryAttributes_memtype : MemType;
  MemoryAttributes_device : DeviceType;
  MemoryAttributes_inner : MemAttrHints;
  MemoryAttributes_outer : MemAttrHints;
  MemoryAttributes_shareability : Shareability;
  MemoryAttributes_tags : MemTagType;
  MemoryAttributes_notagaccess : bool;
  MemoryAttributes_xs : bits 1;
}.
Arguments MemoryAttributes : clear implicits.
#[export]
Instance Decidable_eq_MemoryAttributes : EqDecision MemoryAttributes.
   intros [x0 x1 x2 x3 x4 x5 x6 x7].
   intros [y0 y1 y2 y3 y4 y5 y6 y7].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_MemoryAttributes : Countable MemoryAttributes.
refine {|
  encode x := encode (MemoryAttributes_memtype x, MemoryAttributes_device x, MemoryAttributes_inner x, MemoryAttributes_outer x, MemoryAttributes_shareability x, MemoryAttributes_tags x, MemoryAttributes_notagaccess x, MemoryAttributes_xs x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7) ← decode x;
              mret (Build_MemoryAttributes x0 x1 x2 x3 x4 x5 x6 x7)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_MemoryAttributes : Settable _ := settable! Build_MemoryAttributes <MemoryAttributes_memtype; MemoryAttributes_device; MemoryAttributes_inner; MemoryAttributes_outer; MemoryAttributes_shareability; MemoryAttributes_tags; MemoryAttributes_notagaccess; MemoryAttributes_xs>.
#[export]
Instance dummy_MemoryAttributes : Inhabited (MemoryAttributes) := {
  inhabitant := {|
    MemoryAttributes_memtype := inhabitant;
    MemoryAttributes_device := inhabitant;
    MemoryAttributes_inner := inhabitant;
    MemoryAttributes_outer := inhabitant;
    MemoryAttributes_shareability := inhabitant;
    MemoryAttributes_tags := inhabitant;
    MemoryAttributes_notagaccess := inhabitant;
    MemoryAttributes_xs := inhabitant
|} }.


Inductive PASpace := PAS_NonSecure | PAS_Secure | PAS_Root | PAS_Realm.
Definition num_of_PASpace (arg_ : PASpace) : Z :=
   match arg_ with | PAS_NonSecure => 0 | PAS_Secure => 1 | PAS_Root => 2 | PAS_Realm => 3 end.

Definition PASpace_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : PASpace :=
   let l__73 := arg_ in
   if Z.eqb l__73 0 then PAS_NonSecure
   else if Z.eqb l__73 1 then PAS_Secure
   else if Z.eqb l__73 2 then PAS_Root
   else PAS_Realm.

Lemma PASpace_num_of_roundtrip (x : PASpace) : PASpace_of_num (num_of_PASpace x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_PASpace_injective (x y : PASpace) : num_of_PASpace x = num_of_PASpace y -> x = y.
  intro.
  rewrite <- (PASpace_num_of_roundtrip x).
  rewrite <- (PASpace_num_of_roundtrip y).
  congruence.
Qed.
Definition PASpace_eq_dec (x y : PASpace) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_PASpace x) (num_of_PASpace y) with
  | left e => left (num_of_PASpace_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition PASpace_beq (x y : PASpace) : bool :=
  Z.eqb (num_of_PASpace x) (num_of_PASpace y).
Lemma PASpace_beq_iff x y : PASpace_beq x y = true <-> x = y.
  unfold PASpace_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_PASpace_injective | congruence].
Qed.
Lemma PASpace_beq_refl x : PASpace_beq x x = true.
apply PASpace_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_PASpace : EqDecision PASpace := PASpace_eq_dec.
#[export]
Instance Countable_PASpace : Countable PASpace.
refine {|
  encode x := encode (num_of_PASpace x);
  decode x := z ← decode x; mret (PASpace_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite PASpace_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_PASpace : Inhabited PASpace := { inhabitant := PAS_NonSecure }.


Record FullAddress := {
  FullAddress_paspace : PASpace;
  FullAddress_address : bits 56;
}.
Arguments FullAddress : clear implicits.
#[export]
Instance Decidable_eq_FullAddress : EqDecision FullAddress.
   intros [x0 x1].
   intros [y0 y1].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_FullAddress : Countable FullAddress.
refine {|
  encode x := encode (FullAddress_paspace x, FullAddress_address x);
  decode x := '(x0, x1) ← decode x;
              mret (Build_FullAddress x0 x1)
|}.
abstract (
  intros [x0 x1];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_FullAddress : Settable _ := settable! Build_FullAddress <FullAddress_paspace; FullAddress_address>.
#[export]
Instance dummy_FullAddress : Inhabited (FullAddress) := {
  inhabitant := {| FullAddress_paspace := inhabitant; FullAddress_address := inhabitant
|} }.


Inductive GPCF := GPCF_None | GPCF_AddressSize | GPCF_Walk | GPCF_EABT | GPCF_Fail.
Definition num_of_GPCF (arg_ : GPCF) : Z :=
   match arg_ with
   | GPCF_None => 0
   | GPCF_AddressSize => 1
   | GPCF_Walk => 2
   | GPCF_EABT => 3
   | GPCF_Fail => 4
   end.

Definition GPCF_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 4)*) : GPCF :=
   let l__69 := arg_ in
   if Z.eqb l__69 0 then GPCF_None
   else if Z.eqb l__69 1 then GPCF_AddressSize
   else if Z.eqb l__69 2 then GPCF_Walk
   else if Z.eqb l__69 3 then GPCF_EABT
   else GPCF_Fail.

Lemma GPCF_num_of_roundtrip (x : GPCF) : GPCF_of_num (num_of_GPCF x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_GPCF_injective (x y : GPCF) : num_of_GPCF x = num_of_GPCF y -> x = y.
  intro.
  rewrite <- (GPCF_num_of_roundtrip x).
  rewrite <- (GPCF_num_of_roundtrip y).
  congruence.
Qed.
Definition GPCF_eq_dec (x y : GPCF) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_GPCF x) (num_of_GPCF y) with
  | left e => left (num_of_GPCF_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition GPCF_beq (x y : GPCF) : bool :=
  Z.eqb (num_of_GPCF x) (num_of_GPCF y).
Lemma GPCF_beq_iff x y : GPCF_beq x y = true <-> x = y.
  unfold GPCF_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_GPCF_injective | congruence].
Qed.
Lemma GPCF_beq_refl x : GPCF_beq x x = true.
apply GPCF_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_GPCF : EqDecision GPCF := GPCF_eq_dec.
#[export]
Instance Countable_GPCF : Countable GPCF.
refine {|
  encode x := encode (num_of_GPCF x);
  decode x := z ← decode x; mret (GPCF_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite GPCF_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_GPCF : Inhabited GPCF := { inhabitant := GPCF_None }.


Record GPCFRecord := {
  GPCFRecord_gpf : GPCF;
  GPCFRecord_level : Z;
}.
Arguments GPCFRecord : clear implicits.
#[export]
Instance Decidable_eq_GPCFRecord : EqDecision GPCFRecord.
   intros [x0 x1].
   intros [y0 y1].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_GPCFRecord : Countable GPCFRecord.
refine {|
  encode x := encode (GPCFRecord_gpf x, GPCFRecord_level x);
  decode x := '(x0, x1) ← decode x;
              mret (Build_GPCFRecord x0 x1)
|}.
abstract (
  intros [x0 x1];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_GPCFRecord : Settable _ := settable! Build_GPCFRecord <GPCFRecord_gpf; GPCFRecord_level>.
#[export]
Instance dummy_GPCFRecord : Inhabited (GPCFRecord) := {
  inhabitant := {| GPCFRecord_gpf := inhabitant; GPCFRecord_level := inhabitant
|} }.


Inductive Fault :=
  | Fault_None
  | Fault_AccessFlag
  | Fault_Alignment
  | Fault_Background
  | Fault_Domain
  | Fault_Permission
  | Fault_Translation
  | Fault_AddressSize
  | Fault_SyncExternal
  | Fault_SyncExternalOnWalk
  | Fault_SyncParity
  | Fault_SyncParityOnWalk
  | Fault_GPCFOnWalk
  | Fault_GPCFOnOutput
  | Fault_AsyncParity
  | Fault_AsyncExternal
  | Fault_TagCheck
  | Fault_Debug
  | Fault_TLBConflict
  | Fault_BranchTarget
  | Fault_HWUpdateAccessFlag
  | Fault_Lockdown
  | Fault_Exclusive
  | Fault_ICacheMaint.
Definition num_of_Fault (arg_ : Fault) : Z :=
   match arg_ with
   | Fault_None => 0
   | Fault_AccessFlag => 1
   | Fault_Alignment => 2
   | Fault_Background => 3
   | Fault_Domain => 4
   | Fault_Permission => 5
   | Fault_Translation => 6
   | Fault_AddressSize => 7
   | Fault_SyncExternal => 8
   | Fault_SyncExternalOnWalk => 9
   | Fault_SyncParity => 10
   | Fault_SyncParityOnWalk => 11
   | Fault_GPCFOnWalk => 12
   | Fault_GPCFOnOutput => 13
   | Fault_AsyncParity => 14
   | Fault_AsyncExternal => 15
   | Fault_TagCheck => 16
   | Fault_Debug => 17
   | Fault_TLBConflict => 18
   | Fault_BranchTarget => 19
   | Fault_HWUpdateAccessFlag => 20
   | Fault_Lockdown => 21
   | Fault_Exclusive => 22
   | Fault_ICacheMaint => 23
   end.

Definition Fault_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 23)*) : Fault :=
   let l__46 := arg_ in
   if Z.eqb l__46 0 then Fault_None
   else if Z.eqb l__46 1 then Fault_AccessFlag
   else if Z.eqb l__46 2 then Fault_Alignment
   else if Z.eqb l__46 3 then Fault_Background
   else if Z.eqb l__46 4 then Fault_Domain
   else if Z.eqb l__46 5 then Fault_Permission
   else if Z.eqb l__46 6 then Fault_Translation
   else if Z.eqb l__46 7 then Fault_AddressSize
   else if Z.eqb l__46 8 then Fault_SyncExternal
   else if Z.eqb l__46 9 then Fault_SyncExternalOnWalk
   else if Z.eqb l__46 10 then Fault_SyncParity
   else if Z.eqb l__46 11 then Fault_SyncParityOnWalk
   else if Z.eqb l__46 12 then Fault_GPCFOnWalk
   else if Z.eqb l__46 13 then Fault_GPCFOnOutput
   else if Z.eqb l__46 14 then Fault_AsyncParity
   else if Z.eqb l__46 15 then Fault_AsyncExternal
   else if Z.eqb l__46 16 then Fault_TagCheck
   else if Z.eqb l__46 17 then Fault_Debug
   else if Z.eqb l__46 18 then Fault_TLBConflict
   else if Z.eqb l__46 19 then Fault_BranchTarget
   else if Z.eqb l__46 20 then Fault_HWUpdateAccessFlag
   else if Z.eqb l__46 21 then Fault_Lockdown
   else if Z.eqb l__46 22 then Fault_Exclusive
   else Fault_ICacheMaint.

Lemma Fault_num_of_roundtrip (x : Fault) : Fault_of_num (num_of_Fault x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_Fault_injective (x y : Fault) : num_of_Fault x = num_of_Fault y -> x = y.
  intro.
  rewrite <- (Fault_num_of_roundtrip x).
  rewrite <- (Fault_num_of_roundtrip y).
  congruence.
Qed.
Definition Fault_eq_dec (x y : Fault) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_Fault x) (num_of_Fault y) with
  | left e => left (num_of_Fault_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition Fault_beq (x y : Fault) : bool :=
  Z.eqb (num_of_Fault x) (num_of_Fault y).
Lemma Fault_beq_iff x y : Fault_beq x y = true <-> x = y.
  unfold Fault_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_Fault_injective | congruence].
Qed.
Lemma Fault_beq_refl x : Fault_beq x x = true.
apply Fault_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_Fault : EqDecision Fault := Fault_eq_dec.
#[export]
Instance Countable_Fault : Countable Fault.
refine {|
  encode x := encode (num_of_Fault x);
  decode x := z ← decode x; mret (Fault_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite Fault_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_Fault : Inhabited Fault := { inhabitant := Fault_None }.


Inductive ErrorState :=
  | ErrorState_UC
  | ErrorState_UEU
  | ErrorState_UEO
  | ErrorState_UER
  | ErrorState_CE
  | ErrorState_Uncategorized
  | ErrorState_IMPDEF.
Definition num_of_ErrorState (arg_ : ErrorState) : Z :=
   match arg_ with
   | ErrorState_UC => 0
   | ErrorState_UEU => 1
   | ErrorState_UEO => 2
   | ErrorState_UER => 3
   | ErrorState_CE => 4
   | ErrorState_Uncategorized => 5
   | ErrorState_IMPDEF => 6
   end.

Definition ErrorState_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 6)*) : ErrorState :=
   let l__40 := arg_ in
   if Z.eqb l__40 0 then ErrorState_UC
   else if Z.eqb l__40 1 then ErrorState_UEU
   else if Z.eqb l__40 2 then ErrorState_UEO
   else if Z.eqb l__40 3 then ErrorState_UER
   else if Z.eqb l__40 4 then ErrorState_CE
   else if Z.eqb l__40 5 then ErrorState_Uncategorized
   else ErrorState_IMPDEF.

Lemma ErrorState_num_of_roundtrip (x : ErrorState) : ErrorState_of_num (num_of_ErrorState x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_ErrorState_injective (x y : ErrorState) : num_of_ErrorState x = num_of_ErrorState y -> x = y.
  intro.
  rewrite <- (ErrorState_num_of_roundtrip x).
  rewrite <- (ErrorState_num_of_roundtrip y).
  congruence.
Qed.
Definition ErrorState_eq_dec (x y : ErrorState) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_ErrorState x) (num_of_ErrorState y) with
  | left e => left (num_of_ErrorState_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition ErrorState_beq (x y : ErrorState) : bool :=
  Z.eqb (num_of_ErrorState x) (num_of_ErrorState y).
Lemma ErrorState_beq_iff x y : ErrorState_beq x y = true <-> x = y.
  unfold ErrorState_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_ErrorState_injective | congruence].
Qed.
Lemma ErrorState_beq_refl x : ErrorState_beq x x = true.
apply ErrorState_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_ErrorState : EqDecision ErrorState := ErrorState_eq_dec.
#[export]
Instance Countable_ErrorState : Countable ErrorState.
refine {|
  encode x := encode (num_of_ErrorState x);
  decode x := z ← decode x; mret (ErrorState_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite ErrorState_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_ErrorState : Inhabited ErrorState := { inhabitant := ErrorState_UC }.


Record FaultRecord := {
  FaultRecord_statuscode : Fault;
  FaultRecord_access : AccessDescriptor;
  FaultRecord_ipaddress : FullAddress;
  FaultRecord_gpcf : GPCFRecord;
  FaultRecord_paddress : FullAddress;
  FaultRecord_gpcfs2walk : bool;
  FaultRecord_s2fs1walk : bool;
  FaultRecord_write : bool;
  FaultRecord_s1tagnotdata : bool;
  FaultRecord_tagaccess : bool;
  FaultRecord_level : Z;
  FaultRecord_extflag : bits 1;
  FaultRecord_secondstage : bool;
  FaultRecord_assuredonly : bool;
  FaultRecord_toplevel : bool;
  FaultRecord_overlay : bool;
  FaultRecord_dirtybit : bool;
  FaultRecord_domain : bits 4;
  FaultRecord_merrorstate : ErrorState;
  FaultRecord_debugmoe : bits 4;
}.
Arguments FaultRecord : clear implicits.
#[export]
Instance Decidable_eq_FaultRecord : EqDecision FaultRecord.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16 y17 y18 y19].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
  cmp_record_field x15 y15.
  cmp_record_field x16 y16.
  cmp_record_field x17 y17.
  cmp_record_field x18 y18.
  cmp_record_field x19 y19.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_FaultRecord : Countable FaultRecord.
refine {|
  encode x := encode (FaultRecord_statuscode x, FaultRecord_access x, FaultRecord_ipaddress x, FaultRecord_gpcf x, FaultRecord_paddress x, FaultRecord_gpcfs2walk x, FaultRecord_s2fs1walk x, FaultRecord_write x, FaultRecord_s1tagnotdata x, FaultRecord_tagaccess x, FaultRecord_level x, FaultRecord_extflag x, FaultRecord_secondstage x, FaultRecord_assuredonly x, FaultRecord_toplevel x, FaultRecord_overlay x, FaultRecord_dirtybit x, FaultRecord_domain x, FaultRecord_merrorstate x, FaultRecord_debugmoe x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19) ← decode x;
              mret (Build_FaultRecord x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_FaultRecord : Settable _ := settable! Build_FaultRecord <FaultRecord_statuscode; FaultRecord_access; FaultRecord_ipaddress; FaultRecord_gpcf; FaultRecord_paddress; FaultRecord_gpcfs2walk; FaultRecord_s2fs1walk; FaultRecord_write; FaultRecord_s1tagnotdata; FaultRecord_tagaccess; FaultRecord_level; FaultRecord_extflag; FaultRecord_secondstage; FaultRecord_assuredonly; FaultRecord_toplevel; FaultRecord_overlay; FaultRecord_dirtybit; FaultRecord_domain; FaultRecord_merrorstate; FaultRecord_debugmoe>.
#[export]
Instance dummy_FaultRecord : Inhabited (FaultRecord) := {
  inhabitant := {|
    FaultRecord_statuscode := inhabitant;
    FaultRecord_access := inhabitant;
    FaultRecord_ipaddress := inhabitant;
    FaultRecord_gpcf := inhabitant;
    FaultRecord_paddress := inhabitant;
    FaultRecord_gpcfs2walk := inhabitant;
    FaultRecord_s2fs1walk := inhabitant;
    FaultRecord_write := inhabitant;
    FaultRecord_s1tagnotdata := inhabitant;
    FaultRecord_tagaccess := inhabitant;
    FaultRecord_level := inhabitant;
    FaultRecord_extflag := inhabitant;
    FaultRecord_secondstage := inhabitant;
    FaultRecord_assuredonly := inhabitant;
    FaultRecord_toplevel := inhabitant;
    FaultRecord_overlay := inhabitant;
    FaultRecord_dirtybit := inhabitant;
    FaultRecord_domain := inhabitant;
    FaultRecord_merrorstate := inhabitant;
    FaultRecord_debugmoe := inhabitant
|} }.


Record CacheRecord := {
  CacheRecord_acctype : AccessType;
  CacheRecord_cacheop : CacheOp;
  CacheRecord_opscope : CacheOpScope;
  CacheRecord_cachetype : CacheType;
  CacheRecord_regval : bits 64;
  CacheRecord_paddress : FullAddress;
  CacheRecord_vaddress : bits 64;
  CacheRecord_setnum : Z;
  CacheRecord_waynum : Z;
  CacheRecord_level : Z;
  CacheRecord_shareability : Shareability;
  CacheRecord_translated : bool;
  CacheRecord_is_vmid_valid : bool;
  CacheRecord_vmid : bits 16;
  CacheRecord_is_asid_valid : bool;
  CacheRecord_asid : bits 16;
  CacheRecord_security : SecurityState;
  CacheRecord_cpas : CachePASpace;
}.
Arguments CacheRecord : clear implicits.
#[export]
Instance Decidable_eq_CacheRecord : EqDecision CacheRecord.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16 y17].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
  cmp_record_field x15 y15.
  cmp_record_field x16 y16.
  cmp_record_field x17 y17.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_CacheRecord : Countable CacheRecord.
refine {|
  encode x := encode (CacheRecord_acctype x, CacheRecord_cacheop x, CacheRecord_opscope x, CacheRecord_cachetype x, CacheRecord_regval x, CacheRecord_paddress x, CacheRecord_vaddress x, CacheRecord_setnum x, CacheRecord_waynum x, CacheRecord_level x, CacheRecord_shareability x, CacheRecord_translated x, CacheRecord_is_vmid_valid x, CacheRecord_vmid x, CacheRecord_is_asid_valid x, CacheRecord_asid x, CacheRecord_security x, CacheRecord_cpas x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17) ← decode x;
              mret (Build_CacheRecord x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_CacheRecord : Settable _ := settable! Build_CacheRecord <CacheRecord_acctype; CacheRecord_cacheop; CacheRecord_opscope; CacheRecord_cachetype; CacheRecord_regval; CacheRecord_paddress; CacheRecord_vaddress; CacheRecord_setnum; CacheRecord_waynum; CacheRecord_level; CacheRecord_shareability; CacheRecord_translated; CacheRecord_is_vmid_valid; CacheRecord_vmid; CacheRecord_is_asid_valid; CacheRecord_asid; CacheRecord_security; CacheRecord_cpas>.
#[export]
Instance dummy_CacheRecord : Inhabited (CacheRecord) := {
  inhabitant := {|
    CacheRecord_acctype := inhabitant;
    CacheRecord_cacheop := inhabitant;
    CacheRecord_opscope := inhabitant;
    CacheRecord_cachetype := inhabitant;
    CacheRecord_regval := inhabitant;
    CacheRecord_paddress := inhabitant;
    CacheRecord_vaddress := inhabitant;
    CacheRecord_setnum := inhabitant;
    CacheRecord_waynum := inhabitant;
    CacheRecord_level := inhabitant;
    CacheRecord_shareability := inhabitant;
    CacheRecord_translated := inhabitant;
    CacheRecord_is_vmid_valid := inhabitant;
    CacheRecord_vmid := inhabitant;
    CacheRecord_is_asid_valid := inhabitant;
    CacheRecord_asid := inhabitant;
    CacheRecord_security := inhabitant;
    CacheRecord_cpas := inhabitant
|} }.


Inductive Regime := Regime_EL3 | Regime_EL30 | Regime_EL2 | Regime_EL20 | Regime_EL10.
Definition num_of_Regime (arg_ : Regime) : Z :=
   match arg_ with
   | Regime_EL3 => 0
   | Regime_EL30 => 1
   | Regime_EL2 => 2
   | Regime_EL20 => 3
   | Regime_EL10 => 4
   end.

Definition Regime_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 4)*) : Regime :=
   let l__31 := arg_ in
   if Z.eqb l__31 0 then Regime_EL3
   else if Z.eqb l__31 1 then Regime_EL30
   else if Z.eqb l__31 2 then Regime_EL2
   else if Z.eqb l__31 3 then Regime_EL20
   else Regime_EL10.

Lemma Regime_num_of_roundtrip (x : Regime) : Regime_of_num (num_of_Regime x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_Regime_injective (x y : Regime) : num_of_Regime x = num_of_Regime y -> x = y.
  intro.
  rewrite <- (Regime_num_of_roundtrip x).
  rewrite <- (Regime_num_of_roundtrip y).
  congruence.
Qed.
Definition Regime_eq_dec (x y : Regime) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_Regime x) (num_of_Regime y) with
  | left e => left (num_of_Regime_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition Regime_beq (x y : Regime) : bool :=
  Z.eqb (num_of_Regime x) (num_of_Regime y).
Lemma Regime_beq_iff x y : Regime_beq x y = true <-> x = y.
  unfold Regime_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_Regime_injective | congruence].
Qed.
Lemma Regime_beq_refl x : Regime_beq x x = true.
apply Regime_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_Regime : EqDecision Regime := Regime_eq_dec.
#[export]
Instance Countable_Regime : Countable Regime.
refine {|
  encode x := encode (num_of_Regime x);
  decode x := z ← decode x; mret (Regime_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite Regime_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_Regime : Inhabited Regime := { inhabitant := Regime_EL3 }.


Inductive TGx := TGx_4KB | TGx_16KB | TGx_64KB.
Definition num_of_TGx (arg_ : TGx) : Z :=
   match arg_ with | TGx_4KB => 0 | TGx_16KB => 1 | TGx_64KB => 2 end.

Definition TGx_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : TGx :=
   let l__29 := arg_ in
   if Z.eqb l__29 0 then TGx_4KB
   else if Z.eqb l__29 1 then TGx_16KB
   else TGx_64KB.

Lemma TGx_num_of_roundtrip (x : TGx) : TGx_of_num (num_of_TGx x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_TGx_injective (x y : TGx) : num_of_TGx x = num_of_TGx y -> x = y.
  intro.
  rewrite <- (TGx_num_of_roundtrip x).
  rewrite <- (TGx_num_of_roundtrip y).
  congruence.
Qed.
Definition TGx_eq_dec (x y : TGx) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_TGx x) (num_of_TGx y) with
  | left e => left (num_of_TGx_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition TGx_beq (x y : TGx) : bool :=
  Z.eqb (num_of_TGx x) (num_of_TGx y).
Lemma TGx_beq_iff x y : TGx_beq x y = true <-> x = y.
  unfold TGx_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_TGx_injective | congruence].
Qed.
Lemma TGx_beq_refl x : TGx_beq x x = true.
apply TGx_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_TGx : EqDecision TGx := TGx_eq_dec.
#[export]
Instance Countable_TGx : Countable TGx.
refine {|
  encode x := encode (num_of_TGx x);
  decode x := z ← decode x; mret (TGx_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite TGx_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_TGx : Inhabited TGx := { inhabitant := TGx_4KB }.


Record S1TTWParams := {
  S1TTWParams_ha : bits 1;
  S1TTWParams_hd : bits 1;
  S1TTWParams_tbi : bits 1;
  S1TTWParams_tbid : bits 1;
  S1TTWParams_nfd : bits 1;
  S1TTWParams_e0pd : bits 1;
  S1TTWParams_d128 : bits 1;
  S1TTWParams_aie : bits 1;
  S1TTWParams_mair2 : MAIRType;
  S1TTWParams_ds : bits 1;
  S1TTWParams_ps : bits 3;
  S1TTWParams_txsz : bits 6;
  S1TTWParams_epan : bits 1;
  S1TTWParams_dct : bits 1;
  S1TTWParams_nv1 : bits 1;
  S1TTWParams_cmow : bits 1;
  S1TTWParams_pnch : bits 1;
  S1TTWParams_disch : bits 1;
  S1TTWParams_haft : bits 1;
  S1TTWParams_mtx : bits 1;
  S1TTWParams_skl : bits 2;
  S1TTWParams_pie : bits 1;
  S1TTWParams_pir : S1PIRType;
  S1TTWParams_pire0 : S1PIRType;
  S1TTWParams_emec : bits 1;
  S1TTWParams_amec : bits 1;
  S1TTWParams_t0sz : bits 3;
  S1TTWParams_t1sz : bits 3;
  S1TTWParams_uwxn : bits 1;
  S1TTWParams_tgx : TGx;
  S1TTWParams_irgn : bits 2;
  S1TTWParams_orgn : bits 2;
  S1TTWParams_sh : bits 2;
  S1TTWParams_hpd : bits 1;
  S1TTWParams_ee : bits 1;
  S1TTWParams_wxn : bits 1;
  S1TTWParams_ntlsmd : bits 1;
  S1TTWParams_dc : bits 1;
  S1TTWParams_sif : bits 1;
  S1TTWParams_mair : MAIRType;
}.
Arguments S1TTWParams : clear implicits.
#[export]
Instance Decidable_eq_S1TTWParams : EqDecision S1TTWParams.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16 y17 y18 y19 y20 y21 y22 y23 y24 y25 y26 y27 y28 y29 y30 y31 y32 y33 y34 y35 y36 y37 y38 y39].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
  cmp_record_field x15 y15.
  cmp_record_field x16 y16.
  cmp_record_field x17 y17.
  cmp_record_field x18 y18.
  cmp_record_field x19 y19.
  cmp_record_field x20 y20.
  cmp_record_field x21 y21.
  cmp_record_field x22 y22.
  cmp_record_field x23 y23.
  cmp_record_field x24 y24.
  cmp_record_field x25 y25.
  cmp_record_field x26 y26.
  cmp_record_field x27 y27.
  cmp_record_field x28 y28.
  cmp_record_field x29 y29.
  cmp_record_field x30 y30.
  cmp_record_field x31 y31.
  cmp_record_field x32 y32.
  cmp_record_field x33 y33.
  cmp_record_field x34 y34.
  cmp_record_field x35 y35.
  cmp_record_field x36 y36.
  cmp_record_field x37 y37.
  cmp_record_field x38 y38.
  cmp_record_field x39 y39.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_S1TTWParams : Countable S1TTWParams.
refine {|
  encode x := encode (S1TTWParams_ha x, S1TTWParams_hd x, S1TTWParams_tbi x, S1TTWParams_tbid x, S1TTWParams_nfd x, S1TTWParams_e0pd x, S1TTWParams_d128 x, S1TTWParams_aie x, S1TTWParams_mair2 x, S1TTWParams_ds x, S1TTWParams_ps x, S1TTWParams_txsz x, S1TTWParams_epan x, S1TTWParams_dct x, S1TTWParams_nv1 x, S1TTWParams_cmow x, S1TTWParams_pnch x, S1TTWParams_disch x, S1TTWParams_haft x, S1TTWParams_mtx x, S1TTWParams_skl x, S1TTWParams_pie x, S1TTWParams_pir x, S1TTWParams_pire0 x, S1TTWParams_emec x, S1TTWParams_amec x, S1TTWParams_t0sz x, S1TTWParams_t1sz x, S1TTWParams_uwxn x, S1TTWParams_tgx x, S1TTWParams_irgn x, S1TTWParams_orgn x, S1TTWParams_sh x, S1TTWParams_hpd x, S1TTWParams_ee x, S1TTWParams_wxn x, S1TTWParams_ntlsmd x, S1TTWParams_dc x, S1TTWParams_sif x, S1TTWParams_mair x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39) ← decode x;
              mret (Build_S1TTWParams x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_S1TTWParams : Settable _ := settable! Build_S1TTWParams <S1TTWParams_ha; S1TTWParams_hd; S1TTWParams_tbi; S1TTWParams_tbid; S1TTWParams_nfd; S1TTWParams_e0pd; S1TTWParams_d128; S1TTWParams_aie; S1TTWParams_mair2; S1TTWParams_ds; S1TTWParams_ps; S1TTWParams_txsz; S1TTWParams_epan; S1TTWParams_dct; S1TTWParams_nv1; S1TTWParams_cmow; S1TTWParams_pnch; S1TTWParams_disch; S1TTWParams_haft; S1TTWParams_mtx; S1TTWParams_skl; S1TTWParams_pie; S1TTWParams_pir; S1TTWParams_pire0; S1TTWParams_emec; S1TTWParams_amec; S1TTWParams_t0sz; S1TTWParams_t1sz; S1TTWParams_uwxn; S1TTWParams_tgx; S1TTWParams_irgn; S1TTWParams_orgn; S1TTWParams_sh; S1TTWParams_hpd; S1TTWParams_ee; S1TTWParams_wxn; S1TTWParams_ntlsmd; S1TTWParams_dc; S1TTWParams_sif; S1TTWParams_mair>.
#[export]
Instance dummy_S1TTWParams : Inhabited (S1TTWParams) := {
  inhabitant := {|
    S1TTWParams_ha := inhabitant;
    S1TTWParams_hd := inhabitant;
    S1TTWParams_tbi := inhabitant;
    S1TTWParams_tbid := inhabitant;
    S1TTWParams_nfd := inhabitant;
    S1TTWParams_e0pd := inhabitant;
    S1TTWParams_d128 := inhabitant;
    S1TTWParams_aie := inhabitant;
    S1TTWParams_mair2 := inhabitant;
    S1TTWParams_ds := inhabitant;
    S1TTWParams_ps := inhabitant;
    S1TTWParams_txsz := inhabitant;
    S1TTWParams_epan := inhabitant;
    S1TTWParams_dct := inhabitant;
    S1TTWParams_nv1 := inhabitant;
    S1TTWParams_cmow := inhabitant;
    S1TTWParams_pnch := inhabitant;
    S1TTWParams_disch := inhabitant;
    S1TTWParams_haft := inhabitant;
    S1TTWParams_mtx := inhabitant;
    S1TTWParams_skl := inhabitant;
    S1TTWParams_pie := inhabitant;
    S1TTWParams_pir := inhabitant;
    S1TTWParams_pire0 := inhabitant;
    S1TTWParams_emec := inhabitant;
    S1TTWParams_amec := inhabitant;
    S1TTWParams_t0sz := inhabitant;
    S1TTWParams_t1sz := inhabitant;
    S1TTWParams_uwxn := inhabitant;
    S1TTWParams_tgx := inhabitant;
    S1TTWParams_irgn := inhabitant;
    S1TTWParams_orgn := inhabitant;
    S1TTWParams_sh := inhabitant;
    S1TTWParams_hpd := inhabitant;
    S1TTWParams_ee := inhabitant;
    S1TTWParams_wxn := inhabitant;
    S1TTWParams_ntlsmd := inhabitant;
    S1TTWParams_dc := inhabitant;
    S1TTWParams_sif := inhabitant;
    S1TTWParams_mair := inhabitant
|} }.


Record S2TTWParams := {
  S2TTWParams_ha : bits 1;
  S2TTWParams_hd : bits 1;
  S2TTWParams_sl2 : bits 1;
  S2TTWParams_ds : bits 1;
  S2TTWParams_d128 : bits 1;
  S2TTWParams_sw : bits 1;
  S2TTWParams_nsw : bits 1;
  S2TTWParams_sa : bits 1;
  S2TTWParams_nsa : bits 1;
  S2TTWParams_ps : bits 3;
  S2TTWParams_txsz : bits 6;
  S2TTWParams_fwb : bits 1;
  S2TTWParams_cmow : bits 1;
  S2TTWParams_skl : bits 2;
  S2TTWParams_s2pie : bits 1;
  S2TTWParams_s2pir : S2PIRType;
  S2TTWParams_tl0 : bits 1;
  S2TTWParams_tl1 : bits 1;
  S2TTWParams_assuredonly : bits 1;
  S2TTWParams_haft : bits 1;
  S2TTWParams_emec : bits 1;
  S2TTWParams_s : bits 1;
  S2TTWParams_t0sz : bits 4;
  S2TTWParams_tgx : TGx;
  S2TTWParams_sl0 : bits 2;
  S2TTWParams_irgn : bits 2;
  S2TTWParams_orgn : bits 2;
  S2TTWParams_sh : bits 2;
  S2TTWParams_ee : bits 1;
  S2TTWParams_ptw : bits 1;
  S2TTWParams_vm : bits 1;
}.
Arguments S2TTWParams : clear implicits.
#[export]
Instance Decidable_eq_S2TTWParams : EqDecision S2TTWParams.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16 y17 y18 y19 y20 y21 y22 y23 y24 y25 y26 y27 y28 y29 y30].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
  cmp_record_field x15 y15.
  cmp_record_field x16 y16.
  cmp_record_field x17 y17.
  cmp_record_field x18 y18.
  cmp_record_field x19 y19.
  cmp_record_field x20 y20.
  cmp_record_field x21 y21.
  cmp_record_field x22 y22.
  cmp_record_field x23 y23.
  cmp_record_field x24 y24.
  cmp_record_field x25 y25.
  cmp_record_field x26 y26.
  cmp_record_field x27 y27.
  cmp_record_field x28 y28.
  cmp_record_field x29 y29.
  cmp_record_field x30 y30.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_S2TTWParams : Countable S2TTWParams.
refine {|
  encode x := encode (S2TTWParams_ha x, S2TTWParams_hd x, S2TTWParams_sl2 x, S2TTWParams_ds x, S2TTWParams_d128 x, S2TTWParams_sw x, S2TTWParams_nsw x, S2TTWParams_sa x, S2TTWParams_nsa x, S2TTWParams_ps x, S2TTWParams_txsz x, S2TTWParams_fwb x, S2TTWParams_cmow x, S2TTWParams_skl x, S2TTWParams_s2pie x, S2TTWParams_s2pir x, S2TTWParams_tl0 x, S2TTWParams_tl1 x, S2TTWParams_assuredonly x, S2TTWParams_haft x, S2TTWParams_emec x, S2TTWParams_s x, S2TTWParams_t0sz x, S2TTWParams_tgx x, S2TTWParams_sl0 x, S2TTWParams_irgn x, S2TTWParams_orgn x, S2TTWParams_sh x, S2TTWParams_ee x, S2TTWParams_ptw x, S2TTWParams_vm x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30) ← decode x;
              mret (Build_S2TTWParams x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_S2TTWParams : Settable _ := settable! Build_S2TTWParams <S2TTWParams_ha; S2TTWParams_hd; S2TTWParams_sl2; S2TTWParams_ds; S2TTWParams_d128; S2TTWParams_sw; S2TTWParams_nsw; S2TTWParams_sa; S2TTWParams_nsa; S2TTWParams_ps; S2TTWParams_txsz; S2TTWParams_fwb; S2TTWParams_cmow; S2TTWParams_skl; S2TTWParams_s2pie; S2TTWParams_s2pir; S2TTWParams_tl0; S2TTWParams_tl1; S2TTWParams_assuredonly; S2TTWParams_haft; S2TTWParams_emec; S2TTWParams_s; S2TTWParams_t0sz; S2TTWParams_tgx; S2TTWParams_sl0; S2TTWParams_irgn; S2TTWParams_orgn; S2TTWParams_sh; S2TTWParams_ee; S2TTWParams_ptw; S2TTWParams_vm>.
#[export]
Instance dummy_S2TTWParams : Inhabited (S2TTWParams) := {
  inhabitant := {|
    S2TTWParams_ha := inhabitant;
    S2TTWParams_hd := inhabitant;
    S2TTWParams_sl2 := inhabitant;
    S2TTWParams_ds := inhabitant;
    S2TTWParams_d128 := inhabitant;
    S2TTWParams_sw := inhabitant;
    S2TTWParams_nsw := inhabitant;
    S2TTWParams_sa := inhabitant;
    S2TTWParams_nsa := inhabitant;
    S2TTWParams_ps := inhabitant;
    S2TTWParams_txsz := inhabitant;
    S2TTWParams_fwb := inhabitant;
    S2TTWParams_cmow := inhabitant;
    S2TTWParams_skl := inhabitant;
    S2TTWParams_s2pie := inhabitant;
    S2TTWParams_s2pir := inhabitant;
    S2TTWParams_tl0 := inhabitant;
    S2TTWParams_tl1 := inhabitant;
    S2TTWParams_assuredonly := inhabitant;
    S2TTWParams_haft := inhabitant;
    S2TTWParams_emec := inhabitant;
    S2TTWParams_s := inhabitant;
    S2TTWParams_t0sz := inhabitant;
    S2TTWParams_tgx := inhabitant;
    S2TTWParams_sl0 := inhabitant;
    S2TTWParams_irgn := inhabitant;
    S2TTWParams_orgn := inhabitant;
    S2TTWParams_sh := inhabitant;
    S2TTWParams_ee := inhabitant;
    S2TTWParams_ptw := inhabitant;
    S2TTWParams_vm := inhabitant
|} }.


Record TLBContext := {
  TLBContext_ss : SecurityState;
  TLBContext_regime : Regime;
  TLBContext_vmid : bits 16;
  TLBContext_asid : bits 16;
  TLBContext_nG : bits 1;
  TLBContext_ipaspace : PASpace;
  TLBContext_includes_s1_name : bool;
  TLBContext_includes_s2_name : bool;
  TLBContext_includes_gpt_name : bool;
  TLBContext_ia : bits 64;
  TLBContext_tg : TGx;
  TLBContext_cnp : bits 1;
  TLBContext_level : Z;
  TLBContext_isd128 : bool;
  TLBContext_xs : bits 1;
}.
Arguments TLBContext : clear implicits.
#[export]
Instance Decidable_eq_TLBContext : EqDecision TLBContext.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_TLBContext : Countable TLBContext.
refine {|
  encode x := encode (TLBContext_ss x, TLBContext_regime x, TLBContext_vmid x, TLBContext_asid x, TLBContext_nG x, TLBContext_ipaspace x, TLBContext_includes_s1_name x, TLBContext_includes_s2_name x, TLBContext_includes_gpt_name x, TLBContext_ia x, TLBContext_tg x, TLBContext_cnp x, TLBContext_level x, TLBContext_isd128 x, TLBContext_xs x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14) ← decode x;
              mret (Build_TLBContext x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_TLBContext : Settable _ := settable! Build_TLBContext <TLBContext_ss; TLBContext_regime; TLBContext_vmid; TLBContext_asid; TLBContext_nG; TLBContext_ipaspace; TLBContext_includes_s1_name; TLBContext_includes_s2_name; TLBContext_includes_gpt_name; TLBContext_ia; TLBContext_tg; TLBContext_cnp; TLBContext_level; TLBContext_isd128; TLBContext_xs>.
#[export]
Instance dummy_TLBContext : Inhabited (TLBContext) := {
  inhabitant := {|
    TLBContext_ss := inhabitant;
    TLBContext_regime := inhabitant;
    TLBContext_vmid := inhabitant;
    TLBContext_asid := inhabitant;
    TLBContext_nG := inhabitant;
    TLBContext_ipaspace := inhabitant;
    TLBContext_includes_s1_name := inhabitant;
    TLBContext_includes_s2_name := inhabitant;
    TLBContext_includes_gpt_name := inhabitant;
    TLBContext_ia := inhabitant;
    TLBContext_tg := inhabitant;
    TLBContext_cnp := inhabitant;
    TLBContext_level := inhabitant;
    TLBContext_isd128 := inhabitant;
    TLBContext_xs := inhabitant
|} }.


Record AddressDescriptor := {
  AddressDescriptor_fault : FaultRecord;
  AddressDescriptor_memattrs : MemoryAttributes;
  AddressDescriptor_paddress : FullAddress;
  AddressDescriptor_tlbcontext : TLBContext;
  AddressDescriptor_s1assured : bool;
  AddressDescriptor_s2fs1mro : bool;
  AddressDescriptor_mecid : bits 16;
  AddressDescriptor_vaddress : bits 64;
}.
Arguments AddressDescriptor : clear implicits.
#[export]
Instance Decidable_eq_AddressDescriptor : EqDecision AddressDescriptor.
   intros [x0 x1 x2 x3 x4 x5 x6 x7].
   intros [y0 y1 y2 y3 y4 y5 y6 y7].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_AddressDescriptor : Countable AddressDescriptor.
refine {|
  encode x := encode (AddressDescriptor_fault x, AddressDescriptor_memattrs x, AddressDescriptor_paddress x, AddressDescriptor_tlbcontext x, AddressDescriptor_s1assured x, AddressDescriptor_s2fs1mro x, AddressDescriptor_mecid x, AddressDescriptor_vaddress x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7) ← decode x;
              mret (Build_AddressDescriptor x0 x1 x2 x3 x4 x5 x6 x7)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_AddressDescriptor : Settable _ := settable! Build_AddressDescriptor <AddressDescriptor_fault; AddressDescriptor_memattrs; AddressDescriptor_paddress; AddressDescriptor_tlbcontext; AddressDescriptor_s1assured; AddressDescriptor_s2fs1mro; AddressDescriptor_mecid; AddressDescriptor_vaddress>.
#[export]
Instance dummy_AddressDescriptor : Inhabited (AddressDescriptor) := {
  inhabitant := {|
    AddressDescriptor_fault := inhabitant;
    AddressDescriptor_memattrs := inhabitant;
    AddressDescriptor_paddress := inhabitant;
    AddressDescriptor_tlbcontext := inhabitant;
    AddressDescriptor_s1assured := inhabitant;
    AddressDescriptor_s2fs1mro := inhabitant;
    AddressDescriptor_mecid := inhabitant;
    AddressDescriptor_vaddress := inhabitant
|} }.


Record TranslationInfo := {
  TranslationInfo_regime : Regime;
  TranslationInfo_vmid : option (bits 16);
  TranslationInfo_asid : option (bits 16);
  TranslationInfo_va : bits 64;
  TranslationInfo_s1level : option Z;
  TranslationInfo_s2info : option ((bits 64 * Z));
  TranslationInfo_s1params : option S1TTWParams;
  TranslationInfo_s2params : option S2TTWParams;
  TranslationInfo_memattrs : MemoryAttributes;
}.
Arguments TranslationInfo : clear implicits.
#[export]
Instance Decidable_eq_TranslationInfo : EqDecision TranslationInfo.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_TranslationInfo : Countable TranslationInfo.
refine {|
  encode x := encode (TranslationInfo_regime x, TranslationInfo_vmid x, TranslationInfo_asid x, TranslationInfo_va x, TranslationInfo_s1level x, TranslationInfo_s2info x, TranslationInfo_s1params x, TranslationInfo_s2params x, TranslationInfo_memattrs x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8) ← decode x;
              mret (Build_TranslationInfo x0 x1 x2 x3 x4 x5 x6 x7 x8)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_TranslationInfo : Settable _ := settable! Build_TranslationInfo <TranslationInfo_regime; TranslationInfo_vmid; TranslationInfo_asid; TranslationInfo_va; TranslationInfo_s1level; TranslationInfo_s2info; TranslationInfo_s1params; TranslationInfo_s2params; TranslationInfo_memattrs>.
#[export]
Instance dummy_TranslationInfo : Inhabited (TranslationInfo) := {
  inhabitant := {|
    TranslationInfo_regime := inhabitant;
    TranslationInfo_vmid := inhabitant;
    TranslationInfo_asid := inhabitant;
    TranslationInfo_va := inhabitant;
    TranslationInfo_s1level := inhabitant;
    TranslationInfo_s2info := inhabitant;
    TranslationInfo_s1params := inhabitant;
    TranslationInfo_s2params := inhabitant;
    TranslationInfo_memattrs := inhabitant
|} }.


Record TranslationStartInfo := {
  TranslationStartInfo_ss : SecurityState;
  TranslationStartInfo_regime : Regime;
  TranslationStartInfo_vmid : bits 16;
  TranslationStartInfo_asid : bits 16;
  TranslationStartInfo_va : bits 64;
  TranslationStartInfo_cnp : bits 1;
  TranslationStartInfo_accdesc : AccessDescriptor;
  TranslationStartInfo_size : Z;
}.
Arguments TranslationStartInfo : clear implicits.
#[export]
Instance Decidable_eq_TranslationStartInfo : EqDecision TranslationStartInfo.
   intros [x0 x1 x2 x3 x4 x5 x6 x7].
   intros [y0 y1 y2 y3 y4 y5 y6 y7].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_TranslationStartInfo : Countable TranslationStartInfo.
refine {|
  encode x := encode (TranslationStartInfo_ss x, TranslationStartInfo_regime x, TranslationStartInfo_vmid x, TranslationStartInfo_asid x, TranslationStartInfo_va x, TranslationStartInfo_cnp x, TranslationStartInfo_accdesc x, TranslationStartInfo_size x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7) ← decode x;
              mret (Build_TranslationStartInfo x0 x1 x2 x3 x4 x5 x6 x7)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_TranslationStartInfo : Settable _ := settable! Build_TranslationStartInfo <TranslationStartInfo_ss; TranslationStartInfo_regime; TranslationStartInfo_vmid; TranslationStartInfo_asid; TranslationStartInfo_va; TranslationStartInfo_cnp; TranslationStartInfo_accdesc; TranslationStartInfo_size>.
#[export]
Instance dummy_TranslationStartInfo : Inhabited (TranslationStartInfo) := {
  inhabitant := {|
    TranslationStartInfo_ss := inhabitant;
    TranslationStartInfo_regime := inhabitant;
    TranslationStartInfo_vmid := inhabitant;
    TranslationStartInfo_asid := inhabitant;
    TranslationStartInfo_va := inhabitant;
    TranslationStartInfo_cnp := inhabitant;
    TranslationStartInfo_accdesc := inhabitant;
    TranslationStartInfo_size := inhabitant
|} }.


Inductive TLBILevel := TLBILevel_Any | TLBILevel_Last.
Definition num_of_TLBILevel (arg_ : TLBILevel) : Z :=
   match arg_ with | TLBILevel_Any => 0 | TLBILevel_Last => 1 end.

Definition TLBILevel_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : TLBILevel :=
   let l__28 := arg_ in
   if Z.eqb l__28 0 then TLBILevel_Any
   else TLBILevel_Last.

Lemma TLBILevel_num_of_roundtrip (x : TLBILevel) : TLBILevel_of_num (num_of_TLBILevel x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_TLBILevel_injective (x y : TLBILevel) : num_of_TLBILevel x = num_of_TLBILevel y -> x = y.
  intro.
  rewrite <- (TLBILevel_num_of_roundtrip x).
  rewrite <- (TLBILevel_num_of_roundtrip y).
  congruence.
Qed.
Definition TLBILevel_eq_dec (x y : TLBILevel) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_TLBILevel x) (num_of_TLBILevel y) with
  | left e => left (num_of_TLBILevel_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition TLBILevel_beq (x y : TLBILevel) : bool :=
  Z.eqb (num_of_TLBILevel x) (num_of_TLBILevel y).
Lemma TLBILevel_beq_iff x y : TLBILevel_beq x y = true <-> x = y.
  unfold TLBILevel_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_TLBILevel_injective | congruence].
Qed.
Lemma TLBILevel_beq_refl x : TLBILevel_beq x x = true.
apply TLBILevel_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_TLBILevel : EqDecision TLBILevel := TLBILevel_eq_dec.
#[export]
Instance Countable_TLBILevel : Countable TLBILevel.
refine {|
  encode x := encode (num_of_TLBILevel x);
  decode x := z ← decode x; mret (TLBILevel_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite TLBILevel_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_TLBILevel : Inhabited TLBILevel := { inhabitant := TLBILevel_Any }.


Inductive TLBIOp :=
  | TLBIOp_DALL
  | TLBIOp_DASID
  | TLBIOp_DVA
  | TLBIOp_IALL
  | TLBIOp_IASID
  | TLBIOp_IVA
  | TLBIOp_ALL
  | TLBIOp_ASID
  | TLBIOp_IPAS2
  | TLBIPOp_IPAS2
  | TLBIOp_VAA
  | TLBIOp_VA
  | TLBIPOp_VAA
  | TLBIPOp_VA
  | TLBIOp_VMALL
  | TLBIOp_VMALLS12
  | TLBIOp_RIPAS2
  | TLBIPOp_RIPAS2
  | TLBIOp_RVAA
  | TLBIOp_RVA
  | TLBIPOp_RVAA
  | TLBIPOp_RVA
  | TLBIOp_RPA
  | TLBIOp_PAALL.
Definition num_of_TLBIOp (arg_ : TLBIOp) : Z :=
   match arg_ with
   | TLBIOp_DALL => 0
   | TLBIOp_DASID => 1
   | TLBIOp_DVA => 2
   | TLBIOp_IALL => 3
   | TLBIOp_IASID => 4
   | TLBIOp_IVA => 5
   | TLBIOp_ALL => 6
   | TLBIOp_ASID => 7
   | TLBIOp_IPAS2 => 8
   | TLBIPOp_IPAS2 => 9
   | TLBIOp_VAA => 10
   | TLBIOp_VA => 11
   | TLBIPOp_VAA => 12
   | TLBIPOp_VA => 13
   | TLBIOp_VMALL => 14
   | TLBIOp_VMALLS12 => 15
   | TLBIOp_RIPAS2 => 16
   | TLBIPOp_RIPAS2 => 17
   | TLBIOp_RVAA => 18
   | TLBIOp_RVA => 19
   | TLBIPOp_RVAA => 20
   | TLBIPOp_RVA => 21
   | TLBIOp_RPA => 22
   | TLBIOp_PAALL => 23
   end.

Definition TLBIOp_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 23)*) : TLBIOp :=
   let l__5 := arg_ in
   if Z.eqb l__5 0 then TLBIOp_DALL
   else if Z.eqb l__5 1 then TLBIOp_DASID
   else if Z.eqb l__5 2 then TLBIOp_DVA
   else if Z.eqb l__5 3 then TLBIOp_IALL
   else if Z.eqb l__5 4 then TLBIOp_IASID
   else if Z.eqb l__5 5 then TLBIOp_IVA
   else if Z.eqb l__5 6 then TLBIOp_ALL
   else if Z.eqb l__5 7 then TLBIOp_ASID
   else if Z.eqb l__5 8 then TLBIOp_IPAS2
   else if Z.eqb l__5 9 then TLBIPOp_IPAS2
   else if Z.eqb l__5 10 then TLBIOp_VAA
   else if Z.eqb l__5 11 then TLBIOp_VA
   else if Z.eqb l__5 12 then TLBIPOp_VAA
   else if Z.eqb l__5 13 then TLBIPOp_VA
   else if Z.eqb l__5 14 then TLBIOp_VMALL
   else if Z.eqb l__5 15 then TLBIOp_VMALLS12
   else if Z.eqb l__5 16 then TLBIOp_RIPAS2
   else if Z.eqb l__5 17 then TLBIPOp_RIPAS2
   else if Z.eqb l__5 18 then TLBIOp_RVAA
   else if Z.eqb l__5 19 then TLBIOp_RVA
   else if Z.eqb l__5 20 then TLBIPOp_RVAA
   else if Z.eqb l__5 21 then TLBIPOp_RVA
   else if Z.eqb l__5 22 then TLBIOp_RPA
   else TLBIOp_PAALL.

Lemma TLBIOp_num_of_roundtrip (x : TLBIOp) : TLBIOp_of_num (num_of_TLBIOp x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_TLBIOp_injective (x y : TLBIOp) : num_of_TLBIOp x = num_of_TLBIOp y -> x = y.
  intro.
  rewrite <- (TLBIOp_num_of_roundtrip x).
  rewrite <- (TLBIOp_num_of_roundtrip y).
  congruence.
Qed.
Definition TLBIOp_eq_dec (x y : TLBIOp) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_TLBIOp x) (num_of_TLBIOp y) with
  | left e => left (num_of_TLBIOp_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition TLBIOp_beq (x y : TLBIOp) : bool :=
  Z.eqb (num_of_TLBIOp x) (num_of_TLBIOp y).
Lemma TLBIOp_beq_iff x y : TLBIOp_beq x y = true <-> x = y.
  unfold TLBIOp_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_TLBIOp_injective | congruence].
Qed.
Lemma TLBIOp_beq_refl x : TLBIOp_beq x x = true.
apply TLBIOp_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_TLBIOp : EqDecision TLBIOp := TLBIOp_eq_dec.
#[export]
Instance Countable_TLBIOp : Countable TLBIOp.
refine {|
  encode x := encode (num_of_TLBIOp x);
  decode x := z ← decode x; mret (TLBIOp_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite TLBIOp_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_TLBIOp : Inhabited TLBIOp := { inhabitant := TLBIOp_DALL }.


Inductive TLBIMemAttr := TLBI_AllAttr | TLBI_ExcludeXS.
Definition num_of_TLBIMemAttr (arg_ : TLBIMemAttr) : Z :=
   match arg_ with | TLBI_AllAttr => 0 | TLBI_ExcludeXS => 1 end.

Definition TLBIMemAttr_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 1)*) : TLBIMemAttr :=
   let l__4 := arg_ in
   if Z.eqb l__4 0 then TLBI_AllAttr
   else TLBI_ExcludeXS.

Lemma TLBIMemAttr_num_of_roundtrip (x : TLBIMemAttr) : TLBIMemAttr_of_num (num_of_TLBIMemAttr x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_TLBIMemAttr_injective (x y : TLBIMemAttr) : num_of_TLBIMemAttr x = num_of_TLBIMemAttr y -> x = y.
  intro.
  rewrite <- (TLBIMemAttr_num_of_roundtrip x).
  rewrite <- (TLBIMemAttr_num_of_roundtrip y).
  congruence.
Qed.
Definition TLBIMemAttr_eq_dec (x y : TLBIMemAttr) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_TLBIMemAttr x) (num_of_TLBIMemAttr y) with
  | left e => left (num_of_TLBIMemAttr_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition TLBIMemAttr_beq (x y : TLBIMemAttr) : bool :=
  Z.eqb (num_of_TLBIMemAttr x) (num_of_TLBIMemAttr y).
Lemma TLBIMemAttr_beq_iff x y : TLBIMemAttr_beq x y = true <-> x = y.
  unfold TLBIMemAttr_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_TLBIMemAttr_injective | congruence].
Qed.
Lemma TLBIMemAttr_beq_refl x : TLBIMemAttr_beq x x = true.
apply TLBIMemAttr_beq_iff; reflexivity.
Qed.
#[export]
Instance Decidable_eq_TLBIMemAttr : EqDecision TLBIMemAttr := TLBIMemAttr_eq_dec.
#[export]
Instance Countable_TLBIMemAttr : Countable TLBIMemAttr.
refine {|
  encode x := encode (num_of_TLBIMemAttr x);
  decode x := z ← decode x; mret (TLBIMemAttr_of_num z);
|}.
abstract (
  intro s; rewrite decode_encode;
  simpl;
  rewrite TLBIMemAttr_num_of_roundtrip;
  reflexivity).
Defined.
#[export]
Instance dummy_TLBIMemAttr : Inhabited TLBIMemAttr := { inhabitant := TLBI_AllAttr }.


Record TLBIRecord := {
  TLBIRecord_op : TLBIOp;
  TLBIRecord_from_aarch64 : bool;
  TLBIRecord_security : SecurityState;
  TLBIRecord_regime : Regime;
  TLBIRecord_vmid : bits 16;
  TLBIRecord_asid : bits 16;
  TLBIRecord_level : TLBILevel;
  TLBIRecord_attr : TLBIMemAttr;
  TLBIRecord_ipaspace : PASpace;
  TLBIRecord_address : bits 64;
  TLBIRecord_end_address_name : bits 64;
  TLBIRecord_d64 : bool;
  TLBIRecord_d128 : bool;
  TLBIRecord_ttl : bits 4;
  TLBIRecord_tg : bits 2;
}.
Arguments TLBIRecord : clear implicits.
#[export]
Instance Decidable_eq_TLBIRecord : EqDecision TLBIRecord.
   intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14].
   intros [y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
  cmp_record_field x5 y5.
  cmp_record_field x6 y6.
  cmp_record_field x7 y7.
  cmp_record_field x8 y8.
  cmp_record_field x9 y9.
  cmp_record_field x10 y10.
  cmp_record_field x11 y11.
  cmp_record_field x12 y12.
  cmp_record_field x13 y13.
  cmp_record_field x14 y14.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_TLBIRecord : Countable TLBIRecord.
refine {|
  encode x := encode (TLBIRecord_op x, TLBIRecord_from_aarch64 x, TLBIRecord_security x, TLBIRecord_regime x, TLBIRecord_vmid x, TLBIRecord_asid x, TLBIRecord_level x, TLBIRecord_attr x, TLBIRecord_ipaspace x, TLBIRecord_address x, TLBIRecord_end_address_name x, TLBIRecord_d64 x, TLBIRecord_d128 x, TLBIRecord_ttl x, TLBIRecord_tg x);
  decode x := '(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14) ← decode x;
              mret (Build_TLBIRecord x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14)
|}.
abstract (
  intros [x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_TLBIRecord : Settable _ := settable! Build_TLBIRecord <TLBIRecord_op; TLBIRecord_from_aarch64; TLBIRecord_security; TLBIRecord_regime; TLBIRecord_vmid; TLBIRecord_asid; TLBIRecord_level; TLBIRecord_attr; TLBIRecord_ipaspace; TLBIRecord_address; TLBIRecord_end_address_name; TLBIRecord_d64; TLBIRecord_d128; TLBIRecord_ttl; TLBIRecord_tg>.
#[export]
Instance dummy_TLBIRecord : Inhabited (TLBIRecord) := {
  inhabitant := {|
    TLBIRecord_op := inhabitant;
    TLBIRecord_from_aarch64 := inhabitant;
    TLBIRecord_security := inhabitant;
    TLBIRecord_regime := inhabitant;
    TLBIRecord_vmid := inhabitant;
    TLBIRecord_asid := inhabitant;
    TLBIRecord_level := inhabitant;
    TLBIRecord_attr := inhabitant;
    TLBIRecord_ipaspace := inhabitant;
    TLBIRecord_address := inhabitant;
    TLBIRecord_end_address_name := inhabitant;
    TLBIRecord_d64 := inhabitant;
    TLBIRecord_d128 := inhabitant;
    TLBIRecord_ttl := inhabitant;
    TLBIRecord_tg := inhabitant
|} }.


Record TLBIInfo := {
  TLBIInfo_rec : TLBIRecord;
  TLBIInfo_shareability : Shareability;
}.
Arguments TLBIInfo : clear implicits.
#[export]
Instance Decidable_eq_TLBIInfo : EqDecision TLBIInfo.
   intros [x0 x1].
   intros [y0 y1].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_TLBIInfo : Countable TLBIInfo.
refine {|
  encode x := encode (TLBIInfo_rec x, TLBIInfo_shareability x);
  decode x := '(x0, x1) ← decode x;
              mret (Build_TLBIInfo x0 x1)
|}.
abstract (
  intros [x0 x1];
  rewrite decode_encode;
  reflexivity).
Defined.

#[export] Instance eta_TLBIInfo : Settable _ := settable! Build_TLBIInfo <TLBIInfo_rec; TLBIInfo_shareability>.
#[export]
Instance dummy_TLBIInfo : Inhabited (TLBIInfo) := {
  inhabitant := {| TLBIInfo_rec := inhabitant; TLBIInfo_shareability := inhabitant
|} }.


Definition abort : Type := unit.



Variant register_bitvector_64 :=
  | _PC
  | R30
  | R29
  | R28
  | R27
  | R26
  | R25
  | R24
  | R23
  | R22
  | R21
  | R20
  | R19
  | R18
  | R17
  | R16
  | R15
  | R14
  | R13
  | R12
  | R11
  | R10
  | R9
  | R8
  | R7
  | R6
  | R5
  | R4
  | R3
  | R2
  | R1
  | R0
.

Definition num_of_register_bitvector_64 (r : register_bitvector_64) : Z :=
  match r with
  | _PC => 0
  | R30 => 1
  | R29 => 2
  | R28 => 3
  | R27 => 4
  | R26 => 5
  | R25 => 6
  | R24 => 7
  | R23 => 8
  | R22 => 9
  | R21 => 10
  | R20 => 11
  | R19 => 12
  | R18 => 13
  | R17 => 14
  | R16 => 15
  | R15 => 16
  | R14 => 17
  | R13 => 18
  | R12 => 19
  | R11 => 20
  | R10 => 21
  | R9 => 22
  | R8 => 23
  | R7 => 24
  | R6 => 25
  | R5 => 26
  | R4 => 27
  | R3 => 28
  | R2 => 29
  | R1 => 30
  | R0 => 31
  end.
Definition register_bitvector_64_of_num (i : Z) : register_bitvector_64 :=
  match i with
  | 0 => _PC
  | 1 => R30
  | 2 => R29
  | 3 => R28
  | 4 => R27
  | 5 => R26
  | 6 => R25
  | 7 => R24
  | 8 => R23
  | 9 => R22
  | 10 => R21
  | 11 => R20
  | 12 => R19
  | 13 => R18
  | 14 => R17
  | 15 => R16
  | 16 => R15
  | 17 => R14
  | 18 => R13
  | 19 => R12
  | 20 => R11
  | 21 => R10
  | 22 => R9
  | 23 => R8
  | 24 => R7
  | 25 => R6
  | 26 => R5
  | 27 => R4
  | 28 => R3
  | 29 => R2
  | 30 => R1
  | 31 => R0
  | _ => _PC
  end.
Lemma register_bitvector_64_num_of_roundtrip (x : register_bitvector_64) : register_bitvector_64_of_num (num_of_register_bitvector_64 x) = x.
  destruct x; reflexivity.
Qed.
Lemma num_of_register_bitvector_64_injective (x y : register_bitvector_64) : num_of_register_bitvector_64 x = num_of_register_bitvector_64 y -> x = y.
  intro.
  rewrite <- (register_bitvector_64_num_of_roundtrip x).
  rewrite <- (register_bitvector_64_num_of_roundtrip y).
  congruence.
Qed.
Definition register_bitvector_64_eq_dec (x y : register_bitvector_64) : {x = y} + {x <> y}.
  refine (match Z.eq_dec (num_of_register_bitvector_64 x) (num_of_register_bitvector_64 y) with
  | left e => left (num_of_register_bitvector_64_injective x y e)
  | right ne => right _
  end).
  congruence.
Defined.
Definition register_bitvector_64_beq (x y : register_bitvector_64) : bool :=
  Z.eqb (num_of_register_bitvector_64 x) (num_of_register_bitvector_64 y).
Lemma register_bitvector_64_beq_iff x y : register_bitvector_64_beq x y = true <-> x = y.
  unfold register_bitvector_64_beq.
  rewrite Z.eqb_eq.
  split; [apply num_of_register_bitvector_64_injective | congruence].
Qed.
Lemma register_bitvector_64_beq_refl x : register_bitvector_64_beq x x = true.
apply register_bitvector_64_beq_iff; reflexivity.
Qed.
Hint Rewrite register_bitvector_64_beq_iff : register_beq_iffs.
Hint Rewrite register_bitvector_64_beq_refl : register_beq_refls.
Definition register_bitvector_64_list : list (string * register_bitvector_64) := [
  ("_PC", _PC);
  ("R30", R30);
  ("R29", R29);
  ("R28", R28);
  ("R27", R27);
  ("R26", R26);
  ("R25", R25);
  ("R24", R24);
  ("R23", R23);
  ("R22", R22);
  ("R21", R21);
  ("R20", R20);
  ("R19", R19);
  ("R18", R18);
  ("R17", R17);
  ("R16", R16);
  ("R15", R15);
  ("R14", R14);
  ("R13", R13);
  ("R12", R12);
  ("R11", R11);
  ("R10", R10);
  ("R9", R9);
  ("R8", R8);
  ("R7", R7);
  ("R6", R6);
  ("R5", R5);
  ("R4", R4);
  ("R3", R3);
  ("R2", R2);
  ("R1", R1);
  ("R0", R0)
].

Instance Decidable_eq_register_bitvector_64 : EqDecision register_bitvector_64 := register_bitvector_64_eq_dec.
Instance Countable_register_bitvector_64 : Countable register_bitvector_64. refine {|
  encode x := encode (num_of_register_bitvector_64 x);
  decode x := register_bitvector_64_of_num <$> decode x
|}.
  intro s; rewrite decode_encode; simpl.
  rewrite register_bitvector_64_num_of_roundtrip.
  reflexivity.
Defined.


Variant register : Type -> Type :=
  | R_bitvector_64 :> register_bitvector_64 -> register ((mword 64))
.
Add Keep Equalities register.

Module GRegister.
  Inductive greg := GReg [T : Type] (r : register T).

  (* The injection tactic can do too much, so prove a one-step lemma. *)
  Lemma greg_inj {T} {r r' : register T} : GReg r = GReg r' -> r = r'.
  Proof.
    intro e. injection e as e'.
    apply Eqdep.EqdepTheory.inj_pair2 in e'.
    assumption.
  Qed.

  Definition greg_proj1 (r : greg) : Type := match r with @GReg T _ => T end.
  Definition greg_proj2 (r : greg) : register (greg_proj1 r) := match r with @GReg _ r => r end.

  Definition greg_encode (r : greg) : positive :=
    match r with
    | GReg (R_bitvector_64 r) => encode (0, encode r)
    end.
  Definition greg_type_encode (r : greg) : positive :=
    match r with
    | GReg (R_bitvector_64 _r) => 1
    end.
  Definition greg_decode (x : positive) : option greg :=
    match decode x with
    | Some (0, y) => r ← decode y; mret (GReg (R_bitvector_64 r))
    | _ => None
    end.
  Lemma greg_decode_encode r : greg_decode (greg_encode r) = Some r.
  Proof.
    destruct r as [T r']; destruct r';
    unfold greg_decode, greg_encode;
    rewrite !decode_encode;
    reflexivity.
  Qed.
  Lemma greg_encode_inj r r' : greg_encode r = greg_encode r' -> r = r'.
  Proof.
    intro H.
    enough (Some r = Some r') by congruence.
    rewrite <- (greg_decode_encode r).
    rewrite <- (greg_decode_encode r').
    congruence.
  Qed.
  #[export] Instance Decidable_eq_greg : EqDecision greg.
  refine (fun r r' => match Pos.eq_dec (greg_encode r) (greg_encode r') with
  | left e => left (greg_encode_inj _ _ e)
  | right ne => right _
  end).
  congruence.
  Defined.
  #[export] Instance Countable_greg : Countable greg := {|
    encode := greg_encode;
    decode := greg_decode;
    decode_encode := greg_decode_encode;
  |}.
End GRegister.

Require Import Eqdep.

Instance Decidable_eq_register {T} : EqDecision (register T).
refine (fun r r' => match GRegister.Decidable_eq_greg (GRegister.GReg r) (GRegister.GReg r') with
| left e => left _
| right ne => right _
end).
* by apply GRegister.greg_inj in e.
* intros e; subst; congruence.
Defined.

Definition register_transport {T T'} {P : Type -> Type} {r : register T} {r' : register T'} : GRegister.GReg r = GRegister.GReg r' -> P T -> P T'.
refine (
  match r, r' with
  | R_bitvector_64 r, R_bitvector_64 r' => fun _ x => x

  end
).
(* no wildcard case *)
Defined.

Lemma register_transport_sound {T P} {r r' : register T} (e : GRegister.GReg r = GRegister.GReg r') (p : P T) :
  register_transport e p = p.
Proof.
  pose proof (e' := GRegister.greg_inj e).
  subst r'.
  destruct r; reflexivity.
Qed.

Definition register_beq {T T'} (r : register T) (r' : register T') : bool :=
  match r, r' with
  | R_bitvector_64 r, R_bitvector_64 r' => register_bitvector_64_beq r r'

  end.

Lemma register_beq_refl {T} (r : register T) : register_beq r r = true.
destruct r; simpl; autorewrite with register_beq_refls; reflexivity.
Qed.

Definition register_eq_cast {T T'} (P : Type -> Type) (r : register T) (r' : register T') : P T -> option (P T') :=
  match r, r' with
  | R_bitvector_64 r, R_bitvector_64 r' => fun p => if register_bitvector_64_beq r r' then Some p else None

  end.

Definition register_list : list (string * GRegister.greg) := List.concat [
  List.map (fun '(s, r) => (s, GRegister.GReg (R_bitvector_64 r))) register_bitvector_64_list
].

Definition string_of_register {T} (r : register T) : string :=
  match List.find (fun '(_s, GRegister.GReg r') => register_beq r r') register_list with
  | Some (s, _r) => s
  | None => "<impossible>"
  end.

Definition register_of_string (s : string) : option GRegister.greg :=
  match List.find (fun '(s', _r) => String.eqb s s') register_list with
  | Some (_s, r) => Some r
  | None => None
  end.

Lemma string_of_register_roundtrip {T} (r : register T) :
  register_of_string (string_of_register r) = Some (GRegister.GReg r).
case r; intro r'; destruct r'; reflexivity.
Qed.

Lemma register_string_eq {T T'} (r : register T) (r' : register T') :
  register_beq r r' = String.eqb (string_of_register r) (string_of_register r').
destruct (Bool.reflect_dec _ _ (String.eqb_spec (string_of_register r) (string_of_register r'))) as [H|H].
* rewrite H, String.eqb_refl.
  specialize (string_of_register_roundtrip r) as H1.
  specialize (string_of_register_roundtrip r') as H2.
  rewrite H in H1.
  rewrite H2 in H1.
  assert (E : @GRegister.GReg T' r' = @GRegister.GReg T r). { congruence. }
  set (f := fun (r r' : GRegister.greg) => register_beq (GRegister.greg_proj2 r) (GRegister.greg_proj2 r')).
  change (register_beq r r') with (f (GRegister.GReg r) (GRegister.GReg r')).
  rewrite <- E.
  unfold f.
  apply register_beq_refl.
* apply String.eqb_neq in H as H'.
  rewrite H'.
  apply Bool.not_true_is_false.
  contradict H.
  destruct r,r'; simpl in H; try discriminate; autorewrite with register_beq_iffs in H; subst; reflexivity.
Qed.
#[export] Hint Extern 1 (register _) => assumption : typeclass_instances.
#[export] Instance Decidable_eq_register_values {T : Type} `(r : register T) : EqDecision T | 100 :=
match r with
  | R_bitvector_64 _ => _
end.
#[export] Instance Inhabited_register_values {T : Type} `(r : register T) : Inhabited T | 100 :=
  match r with
  | R_bitvector_64 _ => _
end.
#[export] Instance Countable_register_values {T : Type} `(r : register T) : Countable T | 100.
refine {|
  encode := match r in register T return T -> _ with
  | R_bitvector_64 _ => encode
  end;
  decode := match r in register T return _ -> option T with
  | R_bitvector_64 _ => decode
  end;
|}.
abstract (destruct r; apply decode_encode).
Defined.

Definition _PC_ref : register_ref register _ :=
  Build_register_ref register _ "_PC" _PC.
Definition R30_ref : register_ref register _ :=
  Build_register_ref register _ "R30" R30.
Definition R29_ref : register_ref register _ :=
  Build_register_ref register _ "R29" R29.
Definition R28_ref : register_ref register _ :=
  Build_register_ref register _ "R28" R28.
Definition R27_ref : register_ref register _ :=
  Build_register_ref register _ "R27" R27.
Definition R26_ref : register_ref register _ :=
  Build_register_ref register _ "R26" R26.
Definition R25_ref : register_ref register _ :=
  Build_register_ref register _ "R25" R25.
Definition R24_ref : register_ref register _ :=
  Build_register_ref register _ "R24" R24.
Definition R23_ref : register_ref register _ :=
  Build_register_ref register _ "R23" R23.
Definition R22_ref : register_ref register _ :=
  Build_register_ref register _ "R22" R22.
Definition R21_ref : register_ref register _ :=
  Build_register_ref register _ "R21" R21.
Definition R20_ref : register_ref register _ :=
  Build_register_ref register _ "R20" R20.
Definition R19_ref : register_ref register _ :=
  Build_register_ref register _ "R19" R19.
Definition R18_ref : register_ref register _ :=
  Build_register_ref register _ "R18" R18.
Definition R17_ref : register_ref register _ :=
  Build_register_ref register _ "R17" R17.
Definition R16_ref : register_ref register _ :=
  Build_register_ref register _ "R16" R16.
Definition R15_ref : register_ref register _ :=
  Build_register_ref register _ "R15" R15.
Definition R14_ref : register_ref register _ :=
  Build_register_ref register _ "R14" R14.
Definition R13_ref : register_ref register _ :=
  Build_register_ref register _ "R13" R13.
Definition R12_ref : register_ref register _ :=
  Build_register_ref register _ "R12" R12.
Definition R11_ref : register_ref register _ :=
  Build_register_ref register _ "R11" R11.
Definition R10_ref : register_ref register _ :=
  Build_register_ref register _ "R10" R10.
Definition R9_ref : register_ref register _ :=
  Build_register_ref register _ "R9" R9.
Definition R8_ref : register_ref register _ :=
  Build_register_ref register _ "R8" R8.
Definition R7_ref : register_ref register _ :=
  Build_register_ref register _ "R7" R7.
Definition R6_ref : register_ref register _ :=
  Build_register_ref register _ "R6" R6.
Definition R5_ref : register_ref register _ :=
  Build_register_ref register _ "R5" R5.
Definition R4_ref : register_ref register _ :=
  Build_register_ref register _ "R4" R4.
Definition R3_ref : register_ref register _ :=
  Build_register_ref register _ "R3" R3.
Definition R2_ref : register_ref register _ :=
  Build_register_ref register _ "R2" R2.
Definition R1_ref : register_ref register _ :=
  Build_register_ref register _ "R1" R1.
Definition R0_ref : register_ref register _ :=
  Build_register_ref register _ "R0" R0.
Instance dummy_register_bitvector_64 : Inhabited (register_ref register _) := populate _PC_ref.


(* Definitions to support the lifting to the sequential monad *)
Record regstate := {
  bitvector_64_s : register_bitvector_64 -> mword 64;
}.
#[export] Instance eta_regstate : Settable _ := settable! Build_regstate <bitvector_64_s>.

Definition init_regstate : regstate := Build_regstate
  inhabitant
.

Definition register_lookup {T : Type} (reg : register T) (rs : regstate) : T :=
  match reg with
  | R_bitvector_64 r => rs.(bitvector_64_s) r
  end.

Definition register_set {T : Type} (reg : register T) : T -> regstate -> regstate :=
  match reg with
  | R_bitvector_64 r => fun v rs => rs <|bitvector_64_s := fun r' => if register_bitvector_64_beq r' r then v else rs.(bitvector_64_s) r'|>
  end.

Lemma register_lookup_set {T} (r : register T) regs v: register_lookup r (register_set r v regs) = v.
destruct regs, r; simpl; autorewrite with register_beq_refls; reflexivity.
Qed.

Lemma irrelevant_register_set {T T'} (r : register T) (r' : register T') regs v:
  register_beq r r' = false ->
  register_lookup r (register_set r' v regs) = register_lookup r regs.
destruct regs, r, r'; simpl; intro EQ; rewrite ?EQ; reflexivity.
Qed.

Arguments register_set : simpl never.
Arguments register_lookup : simpl never.

Definition register_accessors : register_accessors regstate register := (@register_lookup, @register_set).


(* Instantiate library definitions with types. *)

Definition read_reg {A E} := @read_reg register A E.
Definition write_reg {A E} := @write_reg register A E.

Module Arch <: Arch.
  Definition reg : Type -> Type := register.
  Definition reg_eq := @Decidable_eq_register.
  Include GRegister.
  Definition greg_eq := @Decidable_eq_greg.
  Definition greg_cnt := @Countable_greg.
  Definition regval_inhabited := @Inhabited_register_values.
  Definition regval_eq := @Decidable_eq_register_values.
  Definition regval_cnt := @Countable_register_values.
  Definition regval_transport A B := @register_transport A B (fun x => x).
  Definition regval_transport_sound A := @register_transport_sound A (fun x => x).
  Definition va_size := 64%N.
  Definition pa : Type := mword 64.
  Definition pa_eq : EqDecision pa := _.
  Definition pa_countable : Countable pa := _.
  Definition arch_ak : Type := arm_acc_type.
  Definition arch_ak_eq : EqDecision arch_ak := _.
  Definition translation : Type := unit.
  Definition translation_eq : EqDecision translation := _.
  Definition trans_start := unit.
  Definition trans_start_eq : EqDecision trans_start := _.
  Definition trans_end := unit.
  Definition trans_end_eq : EqDecision trans_end := _.
  Definition abort : Type := unit.
  Definition abort_eq : EqDecision abort := _.
  Definition barrier : Type := Barrier.
  Definition barrier_eq : EqDecision barrier := _.
  Definition cache_op : Type := unit.
  Definition cache_op_eq : EqDecision cache_op := _.
  Definition tlb_op : Type := unit.
  Definition tlb_op_eq : EqDecision tlb_op := _.
  Definition fault : Type := unit.
  Definition fault_eq : EqDecision fault := _.
  Definition sys_reg_id : Type := unit.
  Definition sys_reg_id_eq : EqDecision sys_reg_id := _.
  Definition sys_reg_id_countable : Countable sys_reg_id := _.
End Arch.

Module Interface := Interface Arch.
Module Defs := Defs Arch Interface.

Definition M := Defs.monad unit.
Definition MR r := Defs.monad (r + unit)%type.
Definition returnM {A:Type} : A -> M A := Defs.returnm (E := unit).
Definition returnR {A:Type} (R:Type) : A -> MR R A := Defs.returnm (E := R + unit)%type.