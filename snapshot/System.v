(*Generated by Sail from System.*)
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import SailStdpp.ConcurrencyInterfaceTypesV2.
Require Import SailStdpp.ConcurrencyInterfaceV2.
Require Import SailStdpp.ConcurrencyInterfaceBuiltinsV2.
Require Import System_types.
Import Defs.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition neq_int (x : Z) (y : Z) : bool := negb ((Z.eqb (x) (y))).

Definition neq_bool (x : bool) (y : bool) : bool := negb ((Bool.eqb (x) (y))).

Definition eq_bits_int {n : Z} (x : mword n) (y : Z) (*(n >=? 0) && (y >=? 0)*) : bool :=
   Z.eqb ((uint (x))) (y).

Definition __id (x : Z) : Z := x.

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shl_int (m) (n) else shr_int (m) ((Z.opp (n))).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shr_int (m) (n) else shl_int (m) ((Z.opp (n))).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if andb ((Z.ltb (n) (0))) ((Z.gtb (m) (0))) then Z.sub ((Z.quot ((Z.add (n) (1))) (m))) (1)
   else if andb ((Z.gtb (n) (0))) ((Z.ltb (m) (0))) then Z.sub ((Z.quot ((Z.sub (n) (1))) (m))) (1)
   else Z.quot (n) (m).

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub (n) ((Z.mul (m) ((fdiv_int (n) (m))))).

Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) (*(len >=? 0) && (v0 >=? 0)*) : mword len :=
   if Z.leb (len) v0 then vector_truncate (v) (len) else zero_extend (v) (len).

Definition sail_ones (n : Z) (*n >=? 0*) : mword n := not_vec ((zeros (n))).

Definition slice_mask (n : Z) (i : Z) (l : Z) (*n >=? 0*) : mword n :=
   if Z.geb (l) (n) then shiftl ((sail_ones (n))) (i)
   else
     let one : bits n := sail_mask (n) ((('b"1")  : bits 1)) in
     shiftl ((sub_vec ((shiftl (one) (l))) (one))) (i).

Definition to_bytes_le (n : Z) (b : mword (8 * n)) (*n >? 0*) : vec (mword 8) n :=
   let res := vector_init (n) ((zeros (8))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       vec_update_dec (res) (i)
         ((autocast (T := mword)
           (subrange_vec_dec (b) ((Z.add ((Z.mul (8) (i))) (7))) ((Z.mul (8) (i)))))))).

Definition from_bytes_le (n : Z) (v : vec (mword 8) n) (*n >? 0*) : mword (8 * n) :=
   let res := zeros ((Z.mul (8) (n))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       update_subrange_vec_dec (res) ((Z.add ((Z.mul (8) (i))) (7))) ((Z.mul (8) (i)))
         ((autocast (T := mword)
           (vec_access_dec (v) (i)))))).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.

Definition concat_str_bits {n : Z} (str : string) (x : mword n) : string :=
   String.append (str) ((string_of_bits (x))).

Definition concat_str_dec (str : string) (x : Z) : string := String.append (str) ((dec_str (x))).

Definition undefined_SecurityState '(tt : unit) : M (SecurityState) :=
   (internal_pick ([SS_NonSecure; SS_Root; SS_Realm; SS_Secure]))  : M (SecurityState).

Definition undefined_PARTIDspaceType '(tt : unit) : M (PARTIDspaceType) :=
   (internal_pick ([PIdSpace_Secure; PIdSpace_Root; PIdSpace_Realm; PIdSpace_NonSecure]))
    : M (PARTIDspaceType).

Definition undefined_MPAMinfo '(tt : unit) : M (MPAMinfo) :=
   (undefined_PARTIDspaceType (tt)) >>= fun (w__0 : PARTIDspaceType) =>
   (undefined_bitvector (16)) >>= fun (w__1 : mword 16) =>
   (undefined_bitvector (8)) >>= fun (w__2 : mword 8) =>
   returnM (({| MPAMinfo_mpam_sp := w__0;  MPAMinfo_partid := w__1;  MPAMinfo_pmg := w__2 |})).

Definition undefined_AccessType '(tt : unit) : M (AccessType) :=
   (internal_pick
      ([AccessType_IFETCH;
      AccessType_GPR;
      AccessType_ASIMD;
      AccessType_SVE;
      AccessType_SME;
      AccessType_IC;
      AccessType_DC;
      AccessType_DCZero;
      AccessType_AT;
      AccessType_NV2;
      AccessType_SPE;
      AccessType_GCS;
      AccessType_GPTW;
      AccessType_TTW]))
    : M (AccessType).

Definition undefined_VARange '(tt : unit) : M (VARange) :=
   (internal_pick ([VARange_LOWER; VARange_UPPER]))  : M (VARange).

Definition undefined_MemAtomicOp '(tt : unit) : M (MemAtomicOp) :=
   (internal_pick
      ([MemAtomicOp_GCSSS1;
      MemAtomicOp_ADD;
      MemAtomicOp_BIC;
      MemAtomicOp_EOR;
      MemAtomicOp_ORR;
      MemAtomicOp_SMAX;
      MemAtomicOp_SMIN;
      MemAtomicOp_UMAX;
      MemAtomicOp_UMIN;
      MemAtomicOp_SWP;
      MemAtomicOp_CAS]))
    : M (MemAtomicOp).

Definition undefined_CacheOp '(tt : unit) : M (CacheOp) :=
   (internal_pick ([CacheOp_Clean; CacheOp_Invalidate; CacheOp_CleanInvalidate]))  : M (CacheOp).

Definition undefined_CacheOpScope '(tt : unit) : M (CacheOpScope) :=
   (internal_pick
      ([CacheOpScope_SetWay;
      CacheOpScope_PoU;
      CacheOpScope_PoC;
      CacheOpScope_PoE;
      CacheOpScope_PoP;
      CacheOpScope_PoDP;
      CacheOpScope_PoPA;
      CacheOpScope_ALLU;
      CacheOpScope_ALLUIS]))
    : M (CacheOpScope).

Definition undefined_CacheType '(tt : unit) : M (CacheType) :=
   (internal_pick ([CacheType_Data; CacheType_Tag; CacheType_Data_Tag; CacheType_Instruction]))
    : M (CacheType).

Definition undefined_CachePASpace '(tt : unit) : M (CachePASpace) :=
   (internal_pick
      ([CPAS_NonSecure;
      CPAS_Any;
      CPAS_RealmNonSecure;
      CPAS_Realm;
      CPAS_Root;
      CPAS_SecureNonSecure;
      CPAS_Secure]))
    : M (CachePASpace).

Definition undefined_AccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   (undefined_AccessType (tt)) >>= fun (w__0 : AccessType) =>
   (undefined_bitvector (2)) >>= fun (w__1 : mword 2) =>
   (undefined_SecurityState (tt)) >>= fun (w__2 : SecurityState) =>
   (undefined_bool (tt)) >>= fun (w__3 : bool) =>
   (undefined_bool (tt)) >>= fun (w__4 : bool) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bool (tt)) >>= fun (w__7 : bool) =>
   (undefined_bool (tt)) >>= fun (w__8 : bool) =>
   (undefined_MemAtomicOp (tt)) >>= fun (w__9 : MemAtomicOp) =>
   (undefined_bool (tt)) >>= fun (w__10 : bool) =>
   (undefined_bool (tt)) >>= fun (w__11 : bool) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_CacheOp (tt)) >>= fun (w__13 : CacheOp) =>
   (undefined_CacheOpScope (tt)) >>= fun (w__14 : CacheOpScope) =>
   (undefined_CacheType (tt)) >>= fun (w__15 : CacheType) =>
   (undefined_bool (tt)) >>= fun (w__16 : bool) =>
   (undefined_bool (tt)) >>= fun (w__17 : bool) =>
   (undefined_bool (tt)) >>= fun (w__18 : bool) =>
   (undefined_bool (tt)) >>= fun (w__19 : bool) =>
   (undefined_bool (tt)) >>= fun (w__20 : bool) =>
   (undefined_bool (tt)) >>= fun (w__21 : bool) =>
   (undefined_bool (tt)) >>= fun (w__22 : bool) =>
   (undefined_bool (tt)) >>= fun (w__23 : bool) =>
   (undefined_bool (tt)) >>= fun (w__24 : bool) =>
   (undefined_bool (tt)) >>= fun (w__25 : bool) =>
   (undefined_bool (tt)) >>= fun (w__26 : bool) =>
   (undefined_bool (tt)) >>= fun (w__27 : bool) =>
   (undefined_VARange (tt)) >>= fun (w__28 : VARange) =>
   (undefined_bool (tt)) >>= fun (w__29 : bool) =>
   (undefined_bool (tt)) >>= fun (w__30 : bool) =>
   (undefined_bool (tt)) >>= fun (w__31 : bool) =>
   (undefined_MPAMinfo (tt)) >>= fun (w__32 : MPAMinfo) =>
   returnM (({| AccessDescriptor_acctype := w__0;
                AccessDescriptor_el := w__1;
                AccessDescriptor_ss := w__2;
                AccessDescriptor_acqsc := w__3;
                AccessDescriptor_acqpc := w__4;
                AccessDescriptor_relsc := w__5;
                AccessDescriptor_limitedordered := w__6;
                AccessDescriptor_exclusive := w__7;
                AccessDescriptor_atomicop := w__8;
                AccessDescriptor_modop := w__9;
                AccessDescriptor_nontemporal := w__10;
                AccessDescriptor_read := w__11;
                AccessDescriptor_write := w__12;
                AccessDescriptor_cacheop := w__13;
                AccessDescriptor_opscope := w__14;
                AccessDescriptor_cachetype := w__15;
                AccessDescriptor_pan := w__16;
                AccessDescriptor_transactional := w__17;
                AccessDescriptor_nonfault := w__18;
                AccessDescriptor_firstfault := w__19;
                AccessDescriptor_first := w__20;
                AccessDescriptor_contiguous := w__21;
                AccessDescriptor_streamingsve := w__22;
                AccessDescriptor_ls64 := w__23;
                AccessDescriptor_mops := w__24;
                AccessDescriptor_rcw := w__25;
                AccessDescriptor_rcws := w__26;
                AccessDescriptor_toplevel := w__27;
                AccessDescriptor_varange := w__28;
                AccessDescriptor_a32lsmd := w__29;
                AccessDescriptor_tagchecked := w__30;
                AccessDescriptor_tagaccess := w__31;
                AccessDescriptor_mpam := w__32 |})).

Definition undefined_MemType '(tt : unit) : M (MemType) :=
   (internal_pick ([MemType_Normal; MemType_Device]))  : M (MemType).

Definition undefined_DeviceType '(tt : unit) : M (DeviceType) :=
   (internal_pick ([DeviceType_GRE; DeviceType_nGRE; DeviceType_nGnRE; DeviceType_nGnRnE]))
    : M (DeviceType).

Definition undefined_MemAttrHints '(tt : unit) : M (MemAttrHints) :=
   (undefined_bitvector (2)) >>= fun (w__0 : mword 2) =>
   (undefined_bitvector (2)) >>= fun (w__1 : mword 2) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   returnM (({| MemAttrHints_attrs := w__0;
                MemAttrHints_hints := w__1;
                MemAttrHints_transient := w__2 |})).

Definition undefined_Shareability '(tt : unit) : M (Shareability) :=
   (internal_pick ([Shareability_NSH; Shareability_ISH; Shareability_OSH]))  : M (Shareability).

Definition undefined_MemTagType '(tt : unit) : M (MemTagType) :=
   (internal_pick ([MemTag_Untagged; MemTag_AllocationTagged; MemTag_CanonicallyTagged]))
    : M (MemTagType).

Definition undefined_MemoryAttributes '(tt : unit) : M (MemoryAttributes) :=
   (undefined_MemType (tt)) >>= fun (w__0 : MemType) =>
   (undefined_DeviceType (tt)) >>= fun (w__1 : DeviceType) =>
   (undefined_MemAttrHints (tt)) >>= fun (w__2 : MemAttrHints) =>
   (undefined_MemAttrHints (tt)) >>= fun (w__3 : MemAttrHints) =>
   (undefined_Shareability (tt)) >>= fun (w__4 : Shareability) =>
   (undefined_MemTagType (tt)) >>= fun (w__5 : MemTagType) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bitvector (1)) >>= fun (w__7 : mword 1) =>
   returnM (({| MemoryAttributes_memtype := w__0;
                MemoryAttributes_device := w__1;
                MemoryAttributes_inner := w__2;
                MemoryAttributes_outer := w__3;
                MemoryAttributes_shareability := w__4;
                MemoryAttributes_tags := w__5;
                MemoryAttributes_notagaccess := w__6;
                MemoryAttributes_xs := w__7 |})).

Definition undefined_PASpace '(tt : unit) : M (PASpace) :=
   (internal_pick ([PAS_NonSecure; PAS_Secure; PAS_Root; PAS_Realm]))  : M (PASpace).

Definition undefined_FullAddress '(tt : unit) : M (FullAddress) :=
   (undefined_PASpace (tt)) >>= fun (w__0 : PASpace) =>
   (undefined_bitvector (56)) >>= fun (w__1 : mword 56) =>
   returnM (({| FullAddress_paspace := w__0;  FullAddress_address := w__1 |})).

Definition undefined_GPCF '(tt : unit) : M (GPCF) :=
   (internal_pick ([GPCF_None; GPCF_AddressSize; GPCF_Walk; GPCF_EABT; GPCF_Fail]))  : M (GPCF).

Definition undefined_GPCFRecord '(tt : unit) : M (GPCFRecord) :=
   (undefined_GPCF (tt)) >>= fun (w__0 : GPCF) =>
   (undefined_int (tt)) >>= fun (w__1 : Z) =>
   returnM (({| GPCFRecord_gpf := w__0;  GPCFRecord_level := w__1 |})).

Definition undefined_Fault '(tt : unit) : M (Fault) :=
   (internal_pick
      ([Fault_None;
      Fault_AccessFlag;
      Fault_Alignment;
      Fault_Background;
      Fault_Domain;
      Fault_Permission;
      Fault_Translation;
      Fault_AddressSize;
      Fault_SyncExternal;
      Fault_SyncExternalOnWalk;
      Fault_SyncParity;
      Fault_SyncParityOnWalk;
      Fault_GPCFOnWalk;
      Fault_GPCFOnOutput;
      Fault_AsyncParity;
      Fault_AsyncExternal;
      Fault_TagCheck;
      Fault_Debug;
      Fault_TLBConflict;
      Fault_BranchTarget;
      Fault_HWUpdateAccessFlag;
      Fault_Lockdown;
      Fault_Exclusive;
      Fault_ICacheMaint]))
    : M (Fault).

Definition undefined_ErrorState '(tt : unit) : M (ErrorState) :=
   (internal_pick
      ([ErrorState_UC;
      ErrorState_UEU;
      ErrorState_UEO;
      ErrorState_UER;
      ErrorState_CE;
      ErrorState_Uncategorized;
      ErrorState_IMPDEF]))
    : M (ErrorState).

Definition undefined_FaultRecord '(tt : unit) : M (FaultRecord) :=
   (undefined_Fault (tt)) >>= fun (w__0 : Fault) =>
   (undefined_AccessDescriptor (tt)) >>= fun (w__1 : AccessDescriptor) =>
   (undefined_FullAddress (tt)) >>= fun (w__2 : FullAddress) =>
   (undefined_GPCFRecord (tt)) >>= fun (w__3 : GPCFRecord) =>
   (undefined_FullAddress (tt)) >>= fun (w__4 : FullAddress) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bool (tt)) >>= fun (w__7 : bool) =>
   (undefined_bool (tt)) >>= fun (w__8 : bool) =>
   (undefined_bool (tt)) >>= fun (w__9 : bool) =>
   (undefined_int (tt)) >>= fun (w__10 : Z) =>
   (undefined_bitvector (1)) >>= fun (w__11 : mword 1) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_bool (tt)) >>= fun (w__13 : bool) =>
   (undefined_bool (tt)) >>= fun (w__14 : bool) =>
   (undefined_bool (tt)) >>= fun (w__15 : bool) =>
   (undefined_bool (tt)) >>= fun (w__16 : bool) =>
   (undefined_bitvector (4)) >>= fun (w__17 : mword 4) =>
   (undefined_ErrorState (tt)) >>= fun (w__18 : ErrorState) =>
   (undefined_bitvector (4)) >>= fun (w__19 : mword 4) =>
   returnM (({| FaultRecord_statuscode := w__0;
                FaultRecord_access := w__1;
                FaultRecord_ipaddress := w__2;
                FaultRecord_gpcf := w__3;
                FaultRecord_paddress := w__4;
                FaultRecord_gpcfs2walk := w__5;
                FaultRecord_s2fs1walk := w__6;
                FaultRecord_write := w__7;
                FaultRecord_s1tagnotdata := w__8;
                FaultRecord_tagaccess := w__9;
                FaultRecord_level := w__10;
                FaultRecord_extflag := w__11;
                FaultRecord_secondstage := w__12;
                FaultRecord_assuredonly := w__13;
                FaultRecord_toplevel := w__14;
                FaultRecord_overlay := w__15;
                FaultRecord_dirtybit := w__16;
                FaultRecord_domain := w__17;
                FaultRecord_merrorstate := w__18;
                FaultRecord_debugmoe := w__19 |})).

Definition undefined_MBReqDomain '(tt : unit) : M (MBReqDomain) :=
   (internal_pick
      ([MBReqDomain_Nonshareable;
      MBReqDomain_InnerShareable;
      MBReqDomain_OuterShareable;
      MBReqDomain_FullSystem]))
    : M (MBReqDomain).

Definition undefined_MBReqTypes '(tt : unit) : M (MBReqTypes) :=
   (internal_pick ([MBReqTypes_Reads; MBReqTypes_Writes; MBReqTypes_All]))  : M (MBReqTypes).

Definition undefined_CacheRecord '(tt : unit) : M (CacheRecord) :=
   (undefined_AccessType (tt)) >>= fun (w__0 : AccessType) =>
   (undefined_CacheOp (tt)) >>= fun (w__1 : CacheOp) =>
   (undefined_CacheOpScope (tt)) >>= fun (w__2 : CacheOpScope) =>
   (undefined_CacheType (tt)) >>= fun (w__3 : CacheType) =>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   (undefined_FullAddress (tt)) >>= fun (w__5 : FullAddress) =>
   (undefined_bitvector (64)) >>= fun (w__6 : mword 64) =>
   (undefined_int (tt)) >>= fun (w__7 : Z) =>
   (undefined_int (tt)) >>= fun (w__8 : Z) =>
   (undefined_int (tt)) >>= fun (w__9 : Z) =>
   (undefined_Shareability (tt)) >>= fun (w__10 : Shareability) =>
   (undefined_bool (tt)) >>= fun (w__11 : bool) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_bitvector (16)) >>= fun (w__13 : mword 16) =>
   (undefined_bool (tt)) >>= fun (w__14 : bool) =>
   (undefined_bitvector (16)) >>= fun (w__15 : mword 16) =>
   (undefined_SecurityState (tt)) >>= fun (w__16 : SecurityState) =>
   (undefined_CachePASpace (tt)) >>= fun (w__17 : CachePASpace) =>
   returnM (({| CacheRecord_acctype := w__0;
                CacheRecord_cacheop := w__1;
                CacheRecord_opscope := w__2;
                CacheRecord_cachetype := w__3;
                CacheRecord_regval := w__4;
                CacheRecord_paddress := w__5;
                CacheRecord_vaddress := w__6;
                CacheRecord_setnum := w__7;
                CacheRecord_waynum := w__8;
                CacheRecord_level := w__9;
                CacheRecord_shareability := w__10;
                CacheRecord_translated := w__11;
                CacheRecord_is_vmid_valid := w__12;
                CacheRecord_vmid := w__13;
                CacheRecord_is_asid_valid := w__14;
                CacheRecord_asid := w__15;
                CacheRecord_security := w__16;
                CacheRecord_cpas := w__17 |})).

Definition undefined_Regime '(tt : unit) : M (Regime) :=
   (internal_pick ([Regime_EL3; Regime_EL30; Regime_EL2; Regime_EL20; Regime_EL10]))  : M (Regime).

Definition undefined_TGx '(tt : unit) : M (TGx) :=
   (internal_pick ([TGx_4KB; TGx_16KB; TGx_64KB]))  : M (TGx).

Definition undefined_TLBContext '(tt : unit) : M (TLBContext) :=
   (undefined_SecurityState (tt)) >>= fun (w__0 : SecurityState) =>
   (undefined_Regime (tt)) >>= fun (w__1 : Regime) =>
   (undefined_bitvector (16)) >>= fun (w__2 : mword 16) =>
   (undefined_bitvector (16)) >>= fun (w__3 : mword 16) =>
   (undefined_bitvector (1)) >>= fun (w__4 : mword 1) =>
   (undefined_PASpace (tt)) >>= fun (w__5 : PASpace) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bool (tt)) >>= fun (w__7 : bool) =>
   (undefined_bool (tt)) >>= fun (w__8 : bool) =>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   (undefined_TGx (tt)) >>= fun (w__10 : TGx) =>
   (undefined_bitvector (1)) >>= fun (w__11 : mword 1) =>
   (undefined_int (tt)) >>= fun (w__12 : Z) =>
   (undefined_bool (tt)) >>= fun (w__13 : bool) =>
   (undefined_bitvector (1)) >>= fun (w__14 : mword 1) =>
   returnM (({| TLBContext_ss := w__0;
                TLBContext_regime := w__1;
                TLBContext_vmid := w__2;
                TLBContext_asid := w__3;
                TLBContext_nG := w__4;
                TLBContext_ipaspace := w__5;
                TLBContext_includes_s1_name := w__6;
                TLBContext_includes_s2_name := w__7;
                TLBContext_includes_gpt_name := w__8;
                TLBContext_ia := w__9;
                TLBContext_tg := w__10;
                TLBContext_cnp := w__11;
                TLBContext_level := w__12;
                TLBContext_isd128 := w__13;
                TLBContext_xs := w__14 |})).

Definition undefined_AddressDescriptor '(tt : unit) : M (AddressDescriptor) :=
   (undefined_FaultRecord (tt)) >>= fun (w__0 : FaultRecord) =>
   (undefined_MemoryAttributes (tt)) >>= fun (w__1 : MemoryAttributes) =>
   (undefined_FullAddress (tt)) >>= fun (w__2 : FullAddress) =>
   (undefined_TLBContext (tt)) >>= fun (w__3 : TLBContext) =>
   (undefined_bool (tt)) >>= fun (w__4 : bool) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bitvector (16)) >>= fun (w__6 : mword 16) =>
   (undefined_bitvector (64)) >>= fun (w__7 : mword 64) =>
   returnM (({| AddressDescriptor_fault := w__0;
                AddressDescriptor_memattrs := w__1;
                AddressDescriptor_paddress := w__2;
                AddressDescriptor_tlbcontext := w__3;
                AddressDescriptor_s1assured := w__4;
                AddressDescriptor_s2fs1mro := w__5;
                AddressDescriptor_mecid := w__6;
                AddressDescriptor_vaddress := w__7 |})).

Definition undefined_TranslationStartInfo '(tt : unit) : M (TranslationStartInfo) :=
   (undefined_SecurityState (tt)) >>= fun (w__0 : SecurityState) =>
   (undefined_Regime (tt)) >>= fun (w__1 : Regime) =>
   (undefined_bitvector (16)) >>= fun (w__2 : mword 16) =>
   (undefined_bitvector (16)) >>= fun (w__3 : mword 16) =>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   (undefined_bitvector (1)) >>= fun (w__5 : mword 1) =>
   (undefined_AccessDescriptor (tt)) >>= fun (w__6 : AccessDescriptor) =>
   (undefined_int (tt)) >>= fun (w__7 : Z) =>
   returnM (({| TranslationStartInfo_ss := w__0;
                TranslationStartInfo_regime := w__1;
                TranslationStartInfo_vmid := w__2;
                TranslationStartInfo_asid := w__3;
                TranslationStartInfo_va := w__4;
                TranslationStartInfo_cnp := w__5;
                TranslationStartInfo_accdesc := w__6;
                TranslationStartInfo_size := w__7 |})).

Definition undefined_TLBILevel '(tt : unit) : M (TLBILevel) :=
   (internal_pick ([TLBILevel_Any; TLBILevel_Last]))  : M (TLBILevel).

Definition undefined_TLBIOp '(tt : unit) : M (TLBIOp) :=
   (internal_pick
      ([TLBIOp_DALL;
      TLBIOp_DASID;
      TLBIOp_DVA;
      TLBIOp_IALL;
      TLBIOp_IASID;
      TLBIOp_IVA;
      TLBIOp_ALL;
      TLBIOp_ASID;
      TLBIOp_IPAS2;
      TLBIPOp_IPAS2;
      TLBIOp_VAA;
      TLBIOp_VA;
      TLBIPOp_VAA;
      TLBIPOp_VA;
      TLBIOp_VMALL;
      TLBIOp_VMALLS12;
      TLBIOp_RIPAS2;
      TLBIPOp_RIPAS2;
      TLBIOp_RVAA;
      TLBIOp_RVA;
      TLBIPOp_RVAA;
      TLBIPOp_RVA;
      TLBIOp_RPA;
      TLBIOp_PAALL]))
    : M (TLBIOp).

Definition undefined_TLBIMemAttr '(tt : unit) : M (TLBIMemAttr) :=
   (internal_pick ([TLBI_AllAttr; TLBI_ExcludeXS]))  : M (TLBIMemAttr).

Definition undefined_TLBIRecord '(tt : unit) : M (TLBIRecord) :=
   (undefined_TLBIOp (tt)) >>= fun (w__0 : TLBIOp) =>
   (undefined_bool (tt)) >>= fun (w__1 : bool) =>
   (undefined_SecurityState (tt)) >>= fun (w__2 : SecurityState) =>
   (undefined_Regime (tt)) >>= fun (w__3 : Regime) =>
   (undefined_bitvector (16)) >>= fun (w__4 : mword 16) =>
   (undefined_bitvector (16)) >>= fun (w__5 : mword 16) =>
   (undefined_TLBILevel (tt)) >>= fun (w__6 : TLBILevel) =>
   (undefined_TLBIMemAttr (tt)) >>= fun (w__7 : TLBIMemAttr) =>
   (undefined_PASpace (tt)) >>= fun (w__8 : PASpace) =>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   (undefined_bitvector (64)) >>= fun (w__10 : mword 64) =>
   (undefined_bool (tt)) >>= fun (w__11 : bool) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_bitvector (4)) >>= fun (w__13 : mword 4) =>
   (undefined_bitvector (2)) >>= fun (w__14 : mword 2) =>
   returnM (({| TLBIRecord_op := w__0;
                TLBIRecord_from_aarch64 := w__1;
                TLBIRecord_security := w__2;
                TLBIRecord_regime := w__3;
                TLBIRecord_vmid := w__4;
                TLBIRecord_asid := w__5;
                TLBIRecord_level := w__6;
                TLBIRecord_attr := w__7;
                TLBIRecord_ipaspace := w__8;
                TLBIRecord_address := w__9;
                TLBIRecord_end_address_name := w__10;
                TLBIRecord_d64 := w__11;
                TLBIRecord_d128 := w__12;
                TLBIRecord_ttl := w__13;
                TLBIRecord_tg := w__14 |})).

Definition undefined_TLBIInfo '(tt : unit) : M (TLBIInfo) :=
   (undefined_TLBIRecord (tt)) >>= fun (w__0 : TLBIRecord) =>
   (undefined_Shareability (tt)) >>= fun (w__1 : Shareability) =>
   returnM (({| TLBIInfo_rec := w__0;  TLBIInfo_shareability := w__1 |})).

Definition undefined_DxB '(tt : unit) : M (DxB) :=
   (undefined_MBReqDomain (tt)) >>= fun (w__0 : MBReqDomain) =>
   (undefined_MBReqTypes (tt)) >>= fun (w__1 : MBReqTypes) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   returnM (({| DxB_domain := w__0;  DxB_types := w__1;  DxB_nXS := w__2 |})).

Definition GPRs : vec (register_ref register (bits 64)) 31 :=
vec_of_list_len [R30_ref;R29_ref;R28_ref;R27_ref;R26_ref;R25_ref;R24_ref;R23_ref;R22_ref;R21_ref;
                 R20_ref;R19_ref;R18_ref;R17_ref;R16_ref;R15_ref;R14_ref;R13_ref;R12_ref;R11_ref;
                 R10_ref;R9_ref;R8_ref;R7_ref;R6_ref;R5_ref;R4_ref;R3_ref;R2_ref;R1_ref;R0_ref].
#[export] Hint Unfold GPRs : sail.
Definition wX (n : Z) (value : mword 64) (*(0 <=? n) && (n <=? 31)*) : M (unit) :=
   (if neq_int (n) (31) return M (unit) then
      write_reg_ref (vec_access_dec (GPRs) (n)) value
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition rX (n : Z) (*(0 <=? n) && (n <=? 31)*) : M (mword 64) :=
   (if neq_int (n) (31) return M (mword 64) then
      (reg_deref ((vec_access_dec (GPRs) (n))))
       : M (mword 64)
    else returnM (((Ox"0000000000000000")  : mword 64)))
    : M (mword 64).

Definition rPC '(tt : unit) : M (mword 64) := ((read_reg _PC)  : M (mword 64))  : M (mword 64).

Definition wPC (pc : mword 64) : M (unit) := write_reg _PC pc  : M (unit).

Definition undefined_ProcState '(tt : unit) : M (ProcState) :=
   (undefined_bitvector (1)) >>= fun (w__0 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__1 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__2 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__3 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__4 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__5 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__6 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__7 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__8 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__9 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__10 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__11 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__12 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__13 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__14 : mword 1) =>
   (undefined_bitvector (2)) >>= fun (w__15 : mword 2) =>
   (undefined_bitvector (1)) >>= fun (w__16 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__17 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__18 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__19 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__20 : mword 1) =>
   (undefined_bitvector (2)) >>= fun (w__21 : mword 2) =>
   (undefined_bitvector (1)) >>= fun (w__22 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__23 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__24 : mword 1) =>
   (undefined_bitvector (4)) >>= fun (w__25 : mword 4) =>
   (undefined_bitvector (1)) >>= fun (w__26 : mword 1) =>
   (undefined_bitvector (8)) >>= fun (w__27 : mword 8) =>
   (undefined_bitvector (1)) >>= fun (w__28 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__29 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__30 : mword 1) =>
   (undefined_bitvector (5)) >>= fun (w__31 : mword 5) =>
   returnM (({| ProcState_N := w__0;
                ProcState_Z := w__1;
                ProcState_C := w__2;
                ProcState_V := w__3;
                ProcState_D := w__4;
                ProcState_A := w__5;
                ProcState_I := w__6;
                ProcState_F := w__7;
                ProcState_EXLOCK := w__8;
                ProcState_PAN := w__9;
                ProcState_UAO := w__10;
                ProcState_DIT := w__11;
                ProcState_TCO := w__12;
                ProcState_PM := w__13;
                ProcState_PPEND := w__14;
                ProcState_BTYPE := w__15;
                ProcState_ZA := w__16;
                ProcState_SM := w__17;
                ProcState_ALLINT := w__18;
                ProcState_SS := w__19;
                ProcState_IL := w__20;
                ProcState_EL := w__21;
                ProcState_nRW := w__22;
                ProcState_SP := w__23;
                ProcState_Q := w__24;
                ProcState_GE := w__25;
                ProcState_SSBS := w__26;
                ProcState_IT := w__27;
                ProcState_J := w__28;
                ProcState_T := w__29;
                ProcState_E := w__30;
                ProcState_M := w__31 |})).

Definition is_ok {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => true | Err _ => false end.

Definition is_err {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => false | Err _ => true end.

Definition ok_option {a : Type} {b : Type} (r : result a b) : option a :=
   match r with | Ok x => Some (x) | Err _ => None end.

Definition err_option {a : Type} {b : Type} (r : result a b) : option b :=
   match r with | Ok _ => None | Err err => Some (err) end.

Definition unwrap_or {a : Type} {b : Type} (r : result a b) (y : a) : a :=
   match r with | Ok x => x | Err _ => y end.

Definition sail_instr_announce {n : Z} (_ : mword n) (*n >? 0*) : unit := tt.

Definition sail_branch_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition sail_reset_registers '(tt : unit) : unit := tt.

Definition sail_synchronize_registers '(tt : unit) : unit := tt.

Definition sail_mark_register {a : Type} (_ : register_ref register a) (_ : string) : unit := tt.

Definition sail_mark_register_pair {a : Type} {b : Type}
(_ : register_ref register a) (_ : register_ref register b) (_ : string)
: unit :=
   tt.

Definition sail_ignore_write_to {a : Type} (reg : register_ref register a) : unit :=
   sail_mark_register (reg) ("ignore_write").

Definition sail_pick_dependency {a : Type} (reg : register_ref register a) : unit :=
   sail_mark_register (reg) ("pick").

Definition __monomorphize {n : Z} (bv : mword n) (*n >=? 0*) : mword n := bv.

Definition __monomorphize_int (n : Z) : Z := n.

Definition __monomorphize_bool (b : bool) : bool := b.

Definition __monomorphize_reads : bool := false.
#[export] Hint Unfold __monomorphize_reads : sail.
Definition __monomorphize_writes : bool := false.
#[export] Hint Unfold __monomorphize_writes : sail.
Definition sail_address_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition addr_size' : Z := 56.
#[export] Hint Unfold addr_size' : sail.
Definition mem_acc_is_explicit (acc : AccessDescriptor) : bool :=
   generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR).

Definition mem_acc_is_ifetch (acc : AccessDescriptor) : bool :=
   generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_IFETCH).

Definition mem_acc_is_ttw (acc : AccessDescriptor) : bool :=
   generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_TTW).

Definition mem_acc_is_relaxed (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     ((andb ((negb (acc.(AccessDescriptor_acqpc))))
         ((andb ((negb (acc.(AccessDescriptor_acqsc)))) ((negb (acc.(AccessDescriptor_relsc)))))))).

Definition mem_acc_is_rel_acq_rcpc (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     (acc.(AccessDescriptor_acqpc)).

Definition mem_acc_is_rel_acq_rcsc (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     ((orb (acc.(AccessDescriptor_acqsc)) (acc.(AccessDescriptor_relsc)))).

Definition mem_acc_is_standalone (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     ((andb ((negb (acc.(AccessDescriptor_exclusive)))) ((negb (acc.(AccessDescriptor_atomicop)))))).

Definition mem_acc_is_exclusive (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     (acc.(AccessDescriptor_exclusive)).

Definition mem_acc_is_atomic_rmw (acc : AccessDescriptor) : bool :=
   andb ((generic_eq (acc.(AccessDescriptor_acctype)) (AccessType_GPR)))
     (acc.(AccessDescriptor_atomicop)).

Definition base_AccessDescriptor (acctype : AccessType) : AccessDescriptor :=
   {| AccessDescriptor_acctype := acctype;
      AccessDescriptor_el := zeros (2);
      AccessDescriptor_ss := SS_NonSecure;
      AccessDescriptor_acqsc := false;
      AccessDescriptor_acqpc := false;
      AccessDescriptor_relsc := false;
      AccessDescriptor_limitedordered := false;
      AccessDescriptor_exclusive := false;
      AccessDescriptor_atomicop := false;
      AccessDescriptor_modop := MemAtomicOp_ADD;
      AccessDescriptor_nontemporal := false;
      AccessDescriptor_read := false;
      AccessDescriptor_write := false;
      AccessDescriptor_cacheop := CacheOp_Clean;
      AccessDescriptor_opscope := CacheOpScope_ALLU;
      AccessDescriptor_cachetype := CacheType_Data;
      AccessDescriptor_pan := false;
      AccessDescriptor_transactional := false;
      AccessDescriptor_nonfault := false;
      AccessDescriptor_firstfault := false;
      AccessDescriptor_first := false;
      AccessDescriptor_contiguous := false;
      AccessDescriptor_streamingsve := false;
      AccessDescriptor_ls64 := false;
      AccessDescriptor_mops := false;
      AccessDescriptor_rcw := false;
      AccessDescriptor_rcws := false;
      AccessDescriptor_toplevel := false;
      AccessDescriptor_varange := VARange_LOWER;
      AccessDescriptor_a32lsmd := false;
      AccessDescriptor_tagchecked := false;
      AccessDescriptor_tagaccess := false;
      AccessDescriptor_mpam :=
        {| MPAMinfo_mpam_sp := PIdSpace_NonSecure;
           MPAMinfo_partid := (Ox"0000")  : mword 16;
           MPAMinfo_pmg := (Ox"00")  : mword 8 |} |}.

Definition create_writeAccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   let accdesc := base_AccessDescriptor (AccessType_GPR) in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_write := true|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_read := false|> in
   read_reg PSTATE >>= fun (w__0 : ProcState) =>
   let accdesc := (accdesc <|AccessDescriptor_el := w__0.(ProcState_EL)|>)  : AccessDescriptor in
   returnM (accdesc).

Definition create_readAccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   let accdesc := base_AccessDescriptor (AccessType_GPR) in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_read := true|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_write := false|> in
   read_reg PSTATE >>= fun (w__0 : ProcState) =>
   let accdesc := (accdesc <|AccessDescriptor_el := w__0.(ProcState_EL)|>)  : AccessDescriptor in
   returnM (accdesc).

Definition create_iFetchAccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   let accdesc := base_AccessDescriptor (AccessType_IFETCH) in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_read := true|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_write := false|> in
   read_reg PSTATE >>= fun (w__0 : ProcState) =>
   let accdesc := (accdesc <|AccessDescriptor_el := w__0.(ProcState_EL)|>)  : AccessDescriptor in
   returnM (accdesc).

Definition undefined_DescriptorType '(tt : unit) : M (DescriptorType) :=
   (internal_pick ([DescriptorType_Table; DescriptorType_Leaf; DescriptorType_Invalid]))
    : M (DescriptorType).

Definition base_FullAddress '(tt : unit) : FullAddress :=
   {| FullAddress_paspace := PAS_NonSecure;  FullAddress_address := zeros (56) |}.

Definition base_FaultRecord (accdesc : AccessDescriptor) (level : Z) : FaultRecord :=
   {| FaultRecord_statuscode := Fault_None;
      FaultRecord_access := accdesc;
      FaultRecord_ipaddress := base_FullAddress (tt);
      FaultRecord_gpcf := {| GPCFRecord_gpf := GPCF_None;  GPCFRecord_level := 0 |};
      FaultRecord_paddress := base_FullAddress (tt);
      FaultRecord_gpcfs2walk := false;
      FaultRecord_s2fs1walk := false;
      FaultRecord_write :=
        andb ((negb (accdesc.(AccessDescriptor_read)))) (accdesc.(AccessDescriptor_write));
      FaultRecord_s1tagnotdata := false;
      FaultRecord_tagaccess := false;
      FaultRecord_level := level;
      FaultRecord_extflag := zeros (1);
      FaultRecord_secondstage := false;
      FaultRecord_assuredonly := false;
      FaultRecord_toplevel := false;
      FaultRecord_overlay := false;
      FaultRecord_dirtybit := false;
      FaultRecord_domain := zeros (4);
      FaultRecord_merrorstate := ErrorState_UC;
      FaultRecord_debugmoe := zeros (4) |}.

Definition base_MemoryAttributes '(tt : unit) : MemoryAttributes :=
   {| MemoryAttributes_memtype := MemType_Normal;
      MemoryAttributes_device := DeviceType_GRE;
      MemoryAttributes_inner :=
        {| MemAttrHints_attrs := zeros (2);
           MemAttrHints_hints := zeros (2);
           MemAttrHints_transient := false |};
      MemoryAttributes_outer :=
        {| MemAttrHints_attrs := zeros (2);
           MemAttrHints_hints := zeros (2);
           MemAttrHints_transient := false |};
      MemoryAttributes_shareability := Shareability_ISH;
      MemoryAttributes_tags := MemTag_Untagged;
      MemoryAttributes_notagaccess := false;
      MemoryAttributes_xs := zeros (1) |}.

Definition base_TLBContext '(tt : unit) : TLBContext :=
   {| TLBContext_ss := SS_NonSecure;
      TLBContext_regime := Regime_EL10;
      TLBContext_vmid := zeros (16);
      TLBContext_asid := zeros (16);
      TLBContext_nG := zeros (1);
      TLBContext_ipaspace := PAS_NonSecure;
      TLBContext_includes_s1_name := false;
      TLBContext_includes_s2_name := false;
      TLBContext_includes_gpt_name := false;
      TLBContext_ia := zeros (64);
      TLBContext_tg := TGx_4KB;
      TLBContext_cnp := zeros (1);
      TLBContext_level := 0;
      TLBContext_isd128 := false;
      TLBContext_xs := zeros (1) |}.

Definition base_AddressDescriptor (accdesc : AccessDescriptor) (level : Z) : AddressDescriptor :=
   {| AddressDescriptor_fault := base_FaultRecord (accdesc) (level);
      AddressDescriptor_memattrs := base_MemoryAttributes (tt);
      AddressDescriptor_paddress := base_FullAddress (tt);
      AddressDescriptor_tlbcontext := base_TLBContext (tt);
      AddressDescriptor_s1assured := false;
      AddressDescriptor_s2fs1mro := false;
      AddressDescriptor_mecid := zeros (16);
      AddressDescriptor_vaddress := zeros (64) |}.

Definition addr_space_def := PAS_NonSecure.
#[export] Hint Unfold addr_space_def : sail.
Definition read_memory (N : Z) (addr : mword 56) (accdesc : AccessDescriptor) (*N >? 0*)
: M (mword (N * 8)) :=
   let req : Mem_read_request N 0 addr_size addr_space AccessDescriptor :=
     {| Mem_read_request_access_kind := accdesc;
        Mem_read_request_address := vector_truncate (addr) (addr_size');
        Mem_read_request_address_space := addr_space_def;
        Mem_read_request_size := N;
        Mem_read_request_num_tag := 0 |} in
   (sail_mem_read ((autocast (T := fun _sz => (Mem_read_request _ _ _sz _ _)%type) req))) >>= fun (w__0 : result ((vec (mword 8) N * vec bool 0)) Fault) =>
   (match w__0 with
    | Ok (bytes, _) => returnM ((autocast (T := mword) (from_bytes_le ((__id (N))) (bytes))))
    | Err _e => exit tt  : M (mword (N * 8))
    end)
    : M (mword (N * 8)).

Definition iFetch (addr : mword 56) (accdesc : AccessDescriptor) : M (mword 32) :=
   (read_memory (4) (addr) (accdesc))  : M (mword (4 * 8)).

Definition rMem (addr : mword 56) (accdesc : AccessDescriptor) : M (mword 64) :=
   (read_memory (8) (addr) (accdesc))  : M (mword (8 * 8)).

Definition wMem_Addr (addr : mword 56) : unit :=
   sail_address_announce (64) ((zero_extend (addr) (64))).

Definition wMem (addr : mword 56) (value : mword 64) (accdesc : AccessDescriptor) : M (unit) :=
   let req : Mem_write_request 8 0 addr_size addr_space AccessDescriptor :=
     {| Mem_write_request_access_kind := accdesc;
        Mem_write_request_address := vector_truncate (addr) (addr_size');
        Mem_write_request_address_space := addr_space_def;
        Mem_write_request_size := 8;
        Mem_write_request_num_tag := 0;
        Mem_write_request_value := to_bytes_le (8) (value);
        Mem_write_request_tags := vec_of_list_len [] |} in
   (sail_mem_write ((autocast (T := fun _sz => (Mem_write_request _ _ _sz _ _)%type) req))) >>= fun (w__0 : result unit Fault) =>
   (match w__0 with | Ok _ => returnM (tt) | Err _ => exit tt  : M (unit) end)
    : M (unit).

Definition dataMemoryBarrier (types : MBReqTypes) : M (unit) :=
   (sail_barrier
      ((Barrier_DMB
          (({| DxB_domain := MBReqDomain_FullSystem;
               DxB_types := types;
               DxB_nXS := false |})))))
    : M (unit).

Definition undefined_Permissions '(tt : unit) : M (Permissions) :=
   (undefined_bool (tt)) >>= fun (w__0 : bool) =>
   (undefined_bool (tt)) >>= fun (w__1 : bool) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   (undefined_bool (tt)) >>= fun (w__3 : bool) =>
   returnM (({| Permissions_allow_write := w__0;
                Permissions_allow_unprivileged_data := w__1;
                Permissions_allow_unprivileged_exec := w__2;
                Permissions_allow_privileged_exec := w__3 |})).

Definition base_Permissions '(tt : unit) : Permissions :=
   {| Permissions_allow_write := false;
      Permissions_allow_unprivileged_data := false;
      Permissions_allow_unprivileged_exec := false;
      Permissions_allow_privileged_exec := false |}.

Definition extract_perms (descriptor : mword 64) (is_table : bool) : Permissions :=
   let perms : Permissions := base_Permissions (tt) in
   if is_table then
     let ap_table := subrange_vec_dec (descriptor) (62) (61) in
     let perms : Permissions :=
       perms
       <|Permissions_allow_write :=
         eq_vec ((vec_of_bits [access_vec_dec (ap_table) (1)]  : mword 1)) ((('b"0")  : mword 1))|> in
     let perms : Permissions :=
       perms
       <|Permissions_allow_unprivileged_data :=
         eq_vec ((vec_of_bits [access_vec_dec (ap_table) (0)]  : mword 1)) ((('b"0")  : mword 1))|> in
     let perms : Permissions :=
       perms
       <|Permissions_allow_unprivileged_exec :=
         eq_vec ((vec_of_bits [access_vec_dec (descriptor) (60)]  : mword 1)) ((('b"0")  : mword 1))|> in
     perms
     <|Permissions_allow_privileged_exec :=
       eq_vec ((vec_of_bits [access_vec_dec (descriptor) (59)]  : mword 1)) ((('b"0")  : mword 1))|>
   else
     let ap := subrange_vec_dec (descriptor) (7) (6) in
     let perms : Permissions :=
       perms
       <|Permissions_allow_write :=
         eq_vec ((vec_of_bits [access_vec_dec (ap) (1)]  : mword 1)) ((('b"0")  : mword 1))|> in
     let perms : Permissions :=
       perms
       <|Permissions_allow_unprivileged_data :=
         eq_vec ((vec_of_bits [access_vec_dec (ap) (0)]  : mword 1)) ((('b"1")  : mword 1))|> in
     let perms : Permissions :=
       perms
       <|Permissions_allow_unprivileged_exec :=
         eq_vec ((vec_of_bits [access_vec_dec (descriptor) (54)]  : mword 1)) ((('b"0")  : mword 1))|> in
     perms
     <|Permissions_allow_privileged_exec :=
       eq_vec ((vec_of_bits [access_vec_dec (descriptor) (53)]  : mword 1)) ((('b"0")  : mword 1))|>.

Definition create_AccessDescriptorTTW (toplevel : bool) (varange : VARange) : M (AccessDescriptor) :=
   let accdesc : AccessDescriptor := base_AccessDescriptor (AccessType_TTW) in
   read_reg PSTATE >>= fun (w__0 : ProcState) =>
   let accdesc := (accdesc <|AccessDescriptor_el := w__0.(ProcState_EL)|>)  : AccessDescriptor in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_read := true|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_toplevel := toplevel|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_varange := varange|> in
   returnM (accdesc).

Definition get_VARange (va : mword 64) : VARange :=
   if eq_vec ((vec_of_bits [access_vec_dec (va) (48)]  : mword 1)) ((('b"0")  : mword 1)) then
     VARange_LOWER
   else VARange_UPPER.

Definition va_out_of_range (va : mword 64) : bool :=
   negb
     ((orb ((eq_vec ((subrange_vec_dec (va) (63) (48))) (((Ox"0000")  : mword 16))))
         ((eq_vec ((subrange_vec_dec (va) (63) (48))) (((Ox"FFFF")  : mword 16)))))).

Definition get_translation_base_address (varange : VARange) : M (mword 56) :=
   (match varange with
    | VARange_LOWER => ((read_reg TTBR0_EL1)  : M (mword 64))  : M (mword 64)
    | VARange_UPPER => ((read_reg TTBR1_EL1)  : M (mword 64))  : M (mword 64)
    end) >>= fun (ttbr : bits 64) =>
   let baddr := zeros (56) in
   let baddr : mword 56 :=
     update_subrange_vec_dec (baddr) (47) (5) ((subrange_vec_dec (ttbr) (47) (5))) in
   returnM (baddr).

Definition ASID_read '(tt : unit) : M (mword 16) :=
   ((read_reg TCR_EL1)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   (if eq_vec ((slice (w__0) (22) (1))) ((zeros (1))) return M (mword 16) then
      ((read_reg TTBR0_EL1)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
      returnM ((slice (w__1) (48) (16)))
    else
      ((read_reg TTBR1_EL1)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
      returnM ((slice (w__2) (48) (16))))
    : M (mword 16).

Definition is_fault (addrdesc : AddressDescriptor) : bool :=
   match addrdesc.(AddressDescriptor_fault).(FaultRecord_statuscode) with
   | Fault_None => false
   | _ => true
   end.

Definition check_permission (perms : Permissions) (accdesc : AccessDescriptor) : bool :=
   let at_el0 := eq_vec (accdesc.(AccessDescriptor_el)) ((('b"00")  : mword 2)) in
   if generic_eq (accdesc.(AccessDescriptor_acctype)) (AccessType_IFETCH) then
     if at_el0 then perms.(Permissions_allow_unprivileged_exec)
     else perms.(Permissions_allow_privileged_exec)
   else if andb (accdesc.(AccessDescriptor_write)) ((negb (perms.(Permissions_allow_write)))) then
     false
   else if andb (at_el0) ((negb (perms.(Permissions_allow_unprivileged_data)))) then false
   else true.

Definition get_TTEntryAddress (level : Z) (ia : mword 64) (baseaddress : mword 56)
(*(0 <=? level) && (level <=? 3)*)
: mword 56 :=
   let stride := 9 in
   let lsb := Z.add ((Z.mul ((Z.sub (3) (level))) (stride))) (12) in
   let msb := Z.sub ((Z.add (lsb) (stride))) (1) in
   let index := zero_extend ((concat_vec ((subrange_vec_dec (ia) (msb) (lsb))) ((zeros (3))))) (56) in
   or_vec (baseaddress) (index).

Definition decode_desc_type (descriptor : mword 64) (level : Z) : DescriptorType :=
   if eq_vec ((vec_of_bits [access_vec_dec (descriptor) (0)]  : mword 1)) ((('b"0")  : mword 1))
   then
     DescriptorType_Invalid
   else if eq_vec ((vec_of_bits [access_vec_dec (descriptor) (1)]  : mword 1))
             ((('b"1")
              : mword 1)) then
     if Z.eqb (level) (3) then DescriptorType_Leaf
     else DescriptorType_Table
   else if eq_vec ((vec_of_bits [access_vec_dec (descriptor) (1)]  : mword 1))
             ((('b"0")
              : mword 1)) then
     if orb ((Z.eqb (level) (1))) ((Z.eqb (level) (2))) then DescriptorType_Leaf
     else DescriptorType_Invalid
   else DescriptorType_Invalid.

Definition pgt_walk (va : mword 64) (accdesc : AccessDescriptor)
: M ((AddressDescriptor * mword 56)) :=
   catch_early_return
     (let varange := get_VARange (va) in
     liftR ((get_translation_base_address (varange))) >>= fun baseaddress =>
     let descaddress := get_TTEntryAddress (0) (va) (baseaddress) in
     let accumulated_perms := base_Permissions (tt) in
     (let '(loop_level_lower) := 0 in
     let '(loop_level_upper) := 3 in
     (foreach_ZM_up loop_level_lower loop_level_upper 1 descaddress
       (fun level descaddress =>
         let addrdesc := base_AddressDescriptor (accdesc) (level) in
         let addrdesc : AddressDescriptor :=
           addrdesc
           <|AddressDescriptor_paddress :=
             addrdesc.(AddressDescriptor_paddress)
             <|FullAddress_address := descaddress|>|> in
         let addrdesc : AddressDescriptor := addrdesc <|AddressDescriptor_vaddress := va|> in
         liftR ((create_AccessDescriptorTTW ((Z.eqb (level) (0))) (varange))) >>= fun walkaccess =>
         liftR ((read_memory (8) (descaddress) (walkaccess))) >>= fun descriptor =>
         (match (decode_desc_type (descriptor) (level)) with
          | DescriptorType_Table =>
             let perms := extract_perms (descriptor) (true) in
             (if negb ((check_permission (perms) (accdesc)))
                return
                MR ((AddressDescriptor * mword 56)) (mword 56) then
                let addrdesc : AddressDescriptor :=
                  addrdesc
                  <|AddressDescriptor_fault :=
                    addrdesc.(AddressDescriptor_fault)
                    <|FaultRecord_statuscode := Fault_Permission|>|> in
                let addrdesc : AddressDescriptor :=
                  addrdesc
                  <|AddressDescriptor_fault :=
                    addrdesc.(AddressDescriptor_fault)
                    <|FaultRecord_level := level|>|> in
                let addrdesc : AddressDescriptor :=
                  addrdesc
                  <|AddressDescriptor_fault :=
                    addrdesc.(AddressDescriptor_fault)
                    <|FaultRecord_write := accdesc.(AccessDescriptor_write)|>|> in
                let addrdesc : AddressDescriptor :=
                  addrdesc
                  <|AddressDescriptor_fault :=
                    addrdesc.(AddressDescriptor_fault)
                    <|FaultRecord_access := accdesc|>|> in
                (early_return (addrdesc, zeros (56)) : MR (AddressDescriptor * mword 56) unit) >>
                returnR ((AddressDescriptor * mword 56)) (descaddress)
              else
                let next_baseaddress :=
                  concat_vec (((Ox"00")  : mword 8))
                    ((concat_vec ((subrange_vec_dec (descriptor) (47) (12)))
                        (((Ox"000")
                         : mword 12)))) in
                liftR (assert_exp' (Z.ltb (level) (3)) "Table entry at level 3") >>= fun _ =>
                let descaddress : mword 56 :=
                  get_TTEntryAddress ((Z.add (level) (1))) (va) (next_baseaddress) in
                returnR ((AddressDescriptor * mword 56)) (descaddress))
              : MR ((AddressDescriptor * mword 56)) (mword 56)
          | DescriptorType_Leaf =>
             let offset := Z.add (12) ((Z.mul ((Z.sub (3) (level))) (9))) in
             let out_pa :=
               concat_vec (((Ox"00")  : mword 8))
                 ((concat_vec ((subrange_vec_dec (descriptor) (47) (offset)))
                     ((subrange_vec_dec (va) ((Z.sub (offset) (1))) (0))))) in
             (early_return (walkaddress, autocast (T := mword)
             out_pa) :
               MR (AddressDescriptor * mword 56) unit) >>
             returnR ((AddressDescriptor * mword 56)) (descaddress)
          | DescriptorType_Invalid =>
             let addrdesc : AddressDescriptor :=
               addrdesc
               <|AddressDescriptor_fault :=
                 addrdesc.(AddressDescriptor_fault)
                 <|FaultRecord_statuscode := Fault_Translation|>|> in
             let addrdesc : AddressDescriptor :=
               addrdesc
               <|AddressDescriptor_fault :=
                 addrdesc.(AddressDescriptor_fault)
                 <|FaultRecord_level := level|>|> in
             (early_return (addrdesc, zeros (56)) : MR (AddressDescriptor * mword 56) unit) >>
             returnR ((AddressDescriptor * mword 56)) (descaddress)
          end)
          : MR ((AddressDescriptor * mword 56)) (mword 56)))) >>= fun (descaddress : mword 56) =>
     liftR (exit tt)
      : MR ((AddressDescriptor * mword 56)) ((AddressDescriptor * mword 56))).

Definition handle_fault (addrdesc : AddressDescriptor) : M (unit) :=
   let fault : FaultRecord := addrdesc.(AddressDescriptor_fault) in
   let vaddress := addrdesc.(AddressDescriptor_vaddress) in
   let source_el := fault.(FaultRecord_access).(AccessDescriptor_el) in
   let target_el := ('b"01")  : mword 2 in
   (if eq_vec (source_el) (target_el) return M (mword 12) then
      read_reg PSTATE >>= fun (w__0 : ProcState) =>
      let w__1 : mword 12 :=
        if eq_vec (w__0.(ProcState_SP)) ((('b"0")  : mword 1)) then (Ox"000")  : mword 12
        else (Ox"200")  : mword 12 in
      returnM (w__1)
    else returnM (((Ox"400")  : mword 12))) >>= fun vect_offset =>
   (sail_take_exception ((Some (fault)))) >>
   let ec := ('b"000000")  : mword 6 in
   let il := ('b"1")  : mword 1 in
   (if generic_eq (fault.(FaultRecord_access).(AccessDescriptor_acctype)) (AccessType_IFETCH) then
      let ec : mword 6 :=
        if eq_vec (source_el) (target_el) then ('b"100001")  : mword 6
        else ('b"100000")  : mword 6 in
      returnM (ec)
    else if generic_eq (fault.(FaultRecord_access).(AccessDescriptor_acctype)) (AccessType_GPR) then
      let ec : mword 6 :=
        if eq_vec (source_el) (target_el) then ('b"100101")  : mword 6
        else ('b"100100")  : mword 6 in
      returnM (ec)
    else exit tt >> returnM (ec)) >>= fun (ec : mword 6) =>
   let l__0 := fault.(FaultRecord_level) in
   (if Z.eqb (l__0) (0) then returnM ((('b"00")  : mword 2))
    else if Z.eqb (l__0) (1) then returnM ((('b"01")  : mword 2))
    else if Z.eqb (l__0) (2) then returnM ((('b"10")  : mword 2))
    else if Z.eqb (l__0) (3) then returnM ((('b"11")  : mword 2))
    else exit tt  : M (mword 2)) >>= fun (level_bit : bits 2) =>
   let dfsc : bits 6 :=
     if generic_eq (fault.(FaultRecord_statuscode)) (Fault_Translation) then
       concat_vec (((Ox"1")  : mword 4)) (level_bit)
     else if generic_eq (fault.(FaultRecord_statuscode)) (Fault_Permission) then
       concat_vec (((Ox"3")  : mword 4)) (level_bit)
     else ('b"000000")  : mword 6 in
   let wnr := if fault.(FaultRecord_write) then ('b"1")  : mword 1 else ('b"0")  : mword 1 in
   let iss := zero_extend ((concat_vec (wnr) (dfsc))) (25) in
   write_reg ESR_EL1 (zero_extend ((concat_vec ((concat_vec (ec) (il))) (iss))) (64)) >>
   write_reg FAR_EL1 vaddress >>
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__6 : mword 64) =>
   write_reg ELR_EL1 w__6 >>
   ((read_reg VBAR_EL1)  : M (mword 64)) >>= fun (w__7 : mword 64) =>
   write_reg _PC (concat_vec ((slice (w__7) (12) (52))) (vect_offset))
    : M (unit).

Definition translate_address (va : mword 64) (accdesc : AccessDescriptor) : M (option (mword 56)) :=
   ((read_reg SCTLR_EL1)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   (if eq_vec ((slice (w__0) (0) (1))) ((('b"0")  : mword 1)) then
      returnM ((Some ((vector_truncate (va) (addr_size')))))
    else
      (if generic_eq ((get_VARange (va))) (VARange_LOWER) return M (mword 1) then
         ((read_reg TTBR0_EL1)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
         returnM ((slice (w__1) (0) (1)))
       else
         ((read_reg TTBR1_EL1)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
         returnM ((slice (w__2) (0) (1)))) >>= fun cnp =>
      (ASID_read (tt)) >>= fun (w__3 : mword 16) =>
      let tsi : TranslationStartInfo :=
        {| TranslationStartInfo_ss := SS_NonSecure;
           TranslationStartInfo_regime := Regime_EL10;
           TranslationStartInfo_vmid := (Ox"0000")  : mword 16;
           TranslationStartInfo_asid := w__3;
           TranslationStartInfo_va := va;
           TranslationStartInfo_cnp := cnp;
           TranslationStartInfo_accdesc := accdesc;
           TranslationStartInfo_size := 0 |} in
      (sail_translation_start (tsi)) >>
      (if va_out_of_range (va) then
         let addrdesc := base_AddressDescriptor (accdesc) (0) in
         let addrdesc : AddressDescriptor :=
           addrdesc
           <|AddressDescriptor_fault :=
             addrdesc.(AddressDescriptor_fault)
             <|FaultRecord_statuscode := Fault_Translation|>|> in
         let addrdesc : AddressDescriptor :=
           addrdesc
           <|AddressDescriptor_fault :=
             addrdesc.(AddressDescriptor_fault)
             <|FaultRecord_write := accdesc.(AccessDescriptor_write)|>|> in
         let addrdesc : AddressDescriptor :=
           addrdesc
           <|AddressDescriptor_fault :=
             addrdesc.(AddressDescriptor_fault)
             <|FaultRecord_access := accdesc|>|> in
         returnM ((addrdesc, zeros (56)))
       else (pgt_walk (va) (accdesc))  : M ((AddressDescriptor * mword 56))) >>= fun '((addrdesc, paddress)) =>
      (sail_translation_end (addrdesc)) >>
      (if is_fault (addrdesc) return M (option (mword 56)) then
         (handle_fault (addrdesc)) >> returnM (None)
       else returnM ((Some (paddress))))
       : M (option (mword 56)))
    : M (option (mword 56)).

Definition decodeLoadStoreRegister
(opc : mword 2) (Rm : mword 5) (option_v : mword 3) (S' : bitU) (Rn : mword 5) (Rt : mword 5)
: option ast :=
   let t : reg_index := uint (Rt) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if orb ((neq_vec (option_v) ((('b"011")  : mword 3)))) ((eq_bit (S') (B1))) then None
   else if eq_vec (opc) ((('b"01")  : mword 2)) then Some ((LoadRegister ((t, n, m))))
   else if eq_vec (opc) ((('b"00")  : mword 2)) then Some ((StoreRegister ((t, n, m))))
   else None.

Definition decodeExclusiveOr
(sf : bitU) (shift : mword 2) (N : bitU) (Rm : mword 5) (imm6 : mword 6) (Rn : mword 5)
(Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if andb ((eq_bit (sf) (B0))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))) then None
   else if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
   else Some ((ExclusiveOr ((d, n, m)))).

Definition decodeDataMemoryBarrier (b__0 : mword 4) : option ast :=
   if eq_vec (b__0) (((Ox"F")  : mword 4)) then Some ((DataMemoryBarrier (MBReqTypes_All)))
   else if eq_vec (b__0) (((Ox"E")  : mword 4)) then Some ((DataMemoryBarrier (MBReqTypes_Writes)))
   else if eq_vec (b__0) (((Ox"D")  : mword 4)) then Some ((DataMemoryBarrier (MBReqTypes_Reads)))
   else None.

Definition decodeCompareAndBranch (imm19 : mword 19) (Rt : mword 5) : option ast :=
   let t : reg_index := uint (Rt) in
   let offset : bits 64 := sign_extend ((concat_vec (imm19) ((('b"00")  : mword 2)))) (64) in
   Some ((CompareAndBranch ((t, offset)))).

Definition execute_StoreRegister (t : Z) (n : Z) (m : Z) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   catch_early_return
     (liftR ((rX (n))) >>= fun base_addr =>
     liftR ((rX (m))) >>= fun offset =>
     let addr := add_vec (base_addr) (offset) in
     liftR ((create_writeAccessDescriptor (tt))) >>= fun accdesc =>
     liftR ((translate_address (addr) (accdesc))) >>= fun (w__0 : option (mword 56)) =>
     (match w__0 with
      | Some addr => returnR (unit) (addr)
      | None => (early_return (tt  : unit) : MR unit (mword 56))  : MR (unit) (mword 56)
      end) >>= fun (addr : bits addr_size) =>
     let '(_) := (wMem_Addr (addr))  : unit in
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__2 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__2) (4))) >>
     liftR ((rX (t))) >>= fun data => liftR ((wMem (addr) (data) (accdesc)))  : MR (unit) (unit)).

Definition execute_LoadRegister (t : Z) (n : Z) (m : Z) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   catch_early_return
     (liftR ((rX (n))) >>= fun base_addr =>
     liftR ((rX (m))) >>= fun offset =>
     let addr := add_vec (base_addr) (offset) in
     liftR ((create_readAccessDescriptor (tt))) >>= fun accdesc =>
     liftR ((translate_address (addr) (accdesc))) >>= fun (w__0 : option (mword 56)) =>
     (match w__0 with
      | Some addr => returnR (unit) (addr)
      | None => (early_return (tt  : unit) : MR unit (mword 56))  : MR (unit) (mword 56)
      end) >>= fun (addr : bits addr_size) =>
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__2 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__2) (4))) >>
     liftR ((rMem (addr) (accdesc))) >>= fun data => liftR ((wX (t) (data)))  : MR (unit) (unit)).

Definition execute_ExclusiveOr (d : Z) (n : Z) (m : Z) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (rX (n)) >>= fun operand1 =>
   (rX (m)) >>= fun operand2 => (wX (d) ((xor_vec (operand1) (operand2))))  : M (unit).

Definition execute_DataMemoryBarrier (types : MBReqTypes) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >> (dataMemoryBarrier (types))  : M (unit).

Definition execute_CompareAndBranch (t : Z) (offset : mword 64) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   (rX (t)) >>= fun operand =>
   (if eq_vec (operand) (((Ox"0000000000000000")  : mword 64)) return M (unit) then
      (rPC (tt)) >>= fun base =>
      let addr := add_vec (base) (offset) in
      (wPC (addr))
       : M (unit)
    else
      ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
      write_reg _PC (add_vec_int (w__0) (4))
       : M (unit))
    : M (unit).

Definition execute (merge_var : ast) : M (unit) :=
   (match merge_var with
    | LoadRegister (t, n, m) => (execute_LoadRegister (t) (n) (m))  : M (unit)
    | StoreRegister (t, n, m) => (execute_StoreRegister (t) (n) (m))  : M (unit)
    | ExclusiveOr (d, n, m) => (execute_ExclusiveOr (d) (n) (m))  : M (unit)
    | DataMemoryBarrier types => (execute_DataMemoryBarrier (types))  : M (unit)
    | CompareAndBranch (t, offset) => (execute_CompareAndBranch (t) (offset))  : M (unit)
    end)
    : M (unit).

Definition decode (v__0 : mword 32) : option ast :=
   if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (24))) (((Ox"F8")  : mword 8))))
        ((andb ((eq_vec ((subrange_vec_dec (v__0) (21) (21))) ((('b"1")  : mword 1))))
            ((eq_vec ((subrange_vec_dec (v__0) (11) (10))) ((('b"10")  : mword 2)))))) then
     let S' := access_vec_dec (v__0) (12) in
     let option_v : bits 3 := subrange_vec_dec (v__0) (15) (13) in
     let opc : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     decodeLoadStoreRegister (opc) (Rm) (option_v) (S') (Rn) (Rt)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1001010")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (21) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeExclusiveOr (sf) (shift) (N) (Rm) (imm6) (Rn) (Rd)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (12))) (((Ox"D5033")  : mword 20))))
             ((eq_vec ((subrange_vec_dec (v__0) (7) (0))) (((Ox"BF")  : mword 8)))) then
     let CRm : bits 4 := subrange_vec_dec (v__0) (11) (8) in
     decodeDataMemoryBarrier (CRm)
   else if eq_vec ((subrange_vec_dec (v__0) (31) (24))) (((Ox"B4")  : mword 8)) then
     let imm19 : bits 19 := subrange_vec_dec (v__0) (23) (5) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeCompareAndBranch (imm19) (Rt)
   else None.

Definition fetch_and_execute '(tt : unit) : M (unit) :=
   catch_early_return
     (liftR ((create_iFetchAccessDescriptor (tt))) >>= fun accdesc =>
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__0 : mword 64) =>
     liftR ((translate_address (w__0) (accdesc))) >>= fun (w__1 : option (mword 56)) =>
     (match w__1 with
      | Some addr => returnR (unit) (addr)
      | None => (early_return (tt  : unit) : MR unit (mword 56))  : MR (unit) (mword 56)
      end) >>= fun (addr : bits addr_size) =>
     liftR ((iFetch (addr) (accdesc))) >>= fun machineCode =>
     let instr := decode (machineCode) in
     (match instr with
      | Some instr => liftR ((execute (instr)))  : MR (unit) (unit)
      | None => liftR (assert_exp' false "Unsupported Encoding") >>= fun _ => liftR (exit tt)
      end)
      : MR (unit) (unit)).

Definition initialize_registers '(tt : unit) : M (unit) :=
   (undefined_bitvector (64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC w__0 >>
   (undefined_bitvector (64)) >>= fun (w__1 : mword 64) =>
   write_reg R30 w__1 >>
   (undefined_bitvector (64)) >>= fun (w__2 : mword 64) =>
   write_reg R29 w__2 >>
   (undefined_bitvector (64)) >>= fun (w__3 : mword 64) =>
   write_reg R28 w__3 >>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   write_reg R27 w__4 >>
   (undefined_bitvector (64)) >>= fun (w__5 : mword 64) =>
   write_reg R26 w__5 >>
   (undefined_bitvector (64)) >>= fun (w__6 : mword 64) =>
   write_reg R25 w__6 >>
   (undefined_bitvector (64)) >>= fun (w__7 : mword 64) =>
   write_reg R24 w__7 >>
   (undefined_bitvector (64)) >>= fun (w__8 : mword 64) =>
   write_reg R23 w__8 >>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   write_reg R22 w__9 >>
   (undefined_bitvector (64)) >>= fun (w__10 : mword 64) =>
   write_reg R21 w__10 >>
   (undefined_bitvector (64)) >>= fun (w__11 : mword 64) =>
   write_reg R20 w__11 >>
   (undefined_bitvector (64)) >>= fun (w__12 : mword 64) =>
   write_reg R19 w__12 >>
   (undefined_bitvector (64)) >>= fun (w__13 : mword 64) =>
   write_reg R18 w__13 >>
   (undefined_bitvector (64)) >>= fun (w__14 : mword 64) =>
   write_reg R17 w__14 >>
   (undefined_bitvector (64)) >>= fun (w__15 : mword 64) =>
   write_reg R16 w__15 >>
   (undefined_bitvector (64)) >>= fun (w__16 : mword 64) =>
   write_reg R15 w__16 >>
   (undefined_bitvector (64)) >>= fun (w__17 : mword 64) =>
   write_reg R14 w__17 >>
   (undefined_bitvector (64)) >>= fun (w__18 : mword 64) =>
   write_reg R13 w__18 >>
   (undefined_bitvector (64)) >>= fun (w__19 : mword 64) =>
   write_reg R12 w__19 >>
   (undefined_bitvector (64)) >>= fun (w__20 : mword 64) =>
   write_reg R11 w__20 >>
   (undefined_bitvector (64)) >>= fun (w__21 : mword 64) =>
   write_reg R10 w__21 >>
   (undefined_bitvector (64)) >>= fun (w__22 : mword 64) =>
   write_reg R9 w__22 >>
   (undefined_bitvector (64)) >>= fun (w__23 : mword 64) =>
   write_reg R8 w__23 >>
   (undefined_bitvector (64)) >>= fun (w__24 : mword 64) =>
   write_reg R7 w__24 >>
   (undefined_bitvector (64)) >>= fun (w__25 : mword 64) =>
   write_reg R6 w__25 >>
   (undefined_bitvector (64)) >>= fun (w__26 : mword 64) =>
   write_reg R5 w__26 >>
   (undefined_bitvector (64)) >>= fun (w__27 : mword 64) =>
   write_reg R4 w__27 >>
   (undefined_bitvector (64)) >>= fun (w__28 : mword 64) =>
   write_reg R3 w__28 >>
   (undefined_bitvector (64)) >>= fun (w__29 : mword 64) =>
   write_reg R2 w__29 >>
   (undefined_bitvector (64)) >>= fun (w__30 : mword 64) =>
   write_reg R1 w__30 >>
   (undefined_bitvector (64)) >>= fun (w__31 : mword 64) =>
   write_reg R0 w__31 >>
   (undefined_bitvector (64)) >>= fun (w__32 : mword 64) =>
   write_reg SP_EL0 w__32 >>
   (undefined_bitvector (64)) >>= fun (w__33 : mword 64) =>
   write_reg SP_EL1 w__33 >>
   (undefined_bitvector (64)) >>= fun (w__34 : mword 64) =>
   write_reg SP_EL2 w__34 >>
   (undefined_bitvector (64)) >>= fun (w__35 : mword 64) =>
   write_reg SP_EL3 w__35 >>
   (undefined_bitvector (64)) >>= fun (w__36 : mword 64) =>
   write_reg ELR_EL1 w__36 >>
   (undefined_bitvector (64)) >>= fun (w__37 : mword 64) =>
   write_reg ELR_EL2 w__37 >>
   (undefined_bitvector (64)) >>= fun (w__38 : mword 64) =>
   write_reg ELR_EL3 w__38 >>
   (undefined_ProcState (tt)) >>= fun (w__39 : ProcState) =>
   write_reg PSTATE w__39 >>
   (undefined_bitvector (64)) >>= fun (w__40 : mword 64) =>
   write_reg ESR_EL1 w__40 >>
   (undefined_bitvector (64)) >>= fun (w__41 : mword 64) =>
   write_reg ESR_EL2 w__41 >>
   (undefined_bitvector (64)) >>= fun (w__42 : mword 64) =>
   write_reg ESR_EL3 w__42 >>
   (undefined_bitvector (64)) >>= fun (w__43 : mword 64) =>
   write_reg FAR_EL1 w__43 >>
   (undefined_bitvector (64)) >>= fun (w__44 : mword 64) =>
   write_reg FAR_EL2 w__44 >>
   (undefined_bitvector (64)) >>= fun (w__45 : mword 64) =>
   write_reg FAR_EL3 w__45 >>
   (undefined_bitvector (64)) >>= fun (w__46 : mword 64) =>
   write_reg PAR_EL1 w__46 >>
   (undefined_bitvector (64)) >>= fun (w__47 : mword 64) =>
   write_reg TTBR0_EL1 w__47 >>
   (undefined_bitvector (64)) >>= fun (w__48 : mword 64) =>
   write_reg TTBR1_EL1 w__48 >>
   (undefined_bitvector (64)) >>= fun (w__49 : mword 64) =>
   write_reg TTBR0_EL2 w__49 >>
   (undefined_bitvector (64)) >>= fun (w__50 : mword 64) =>
   write_reg TTBR1_EL2 w__50 >>
   (undefined_bitvector (64)) >>= fun (w__51 : mword 64) =>
   write_reg TTBR0_EL3 w__51 >>
   (undefined_bitvector (64)) >>= fun (w__52 : mword 64) =>
   write_reg VTTBR_EL2 w__52 >>
   (undefined_bitvector (64)) >>= fun (w__53 : mword 64) =>
   write_reg VBAR_EL1 w__53 >>
   (undefined_bitvector (64)) >>= fun (w__54 : mword 64) =>
   write_reg VBAR_EL2 w__54 >>
   (undefined_bitvector (64)) >>= fun (w__55 : mword 64) =>
   write_reg VBAR_EL3 w__55 >>
   (undefined_bitvector (64)) >>= fun (w__56 : mword 64) =>
   write_reg SPSR_EL1 w__56 >>
   (undefined_bitvector (64)) >>= fun (w__57 : mword 64) =>
   write_reg SPSR_EL2 w__57 >>
   (undefined_bitvector (64)) >>= fun (w__58 : mword 64) =>
   write_reg SPSR_EL3 w__58 >>
   (undefined_bitvector (64)) >>= fun (w__59 : mword 64) =>
   write_reg ID_AA64MMFR0_EL1 w__59 >>
   (undefined_bitvector (64)) >>= fun (w__60 : mword 64) =>
   write_reg ID_AA64MMFR1_EL1 w__60 >>
   (undefined_bitvector (64)) >>= fun (w__61 : mword 64) =>
   write_reg ID_AA64MMFR2_EL1 w__61 >>
   (undefined_bitvector (64)) >>= fun (w__62 : mword 64) =>
   write_reg ID_AA64MMFR3_EL1 w__62 >>
   (undefined_bitvector (64)) >>= fun (w__63 : mword 64) =>
   write_reg ID_AA64MMFR4_EL1 w__63 >>
   (undefined_bitvector (64)) >>= fun (w__64 : mword 64) =>
   write_reg TCR_EL1 w__64 >>
   (undefined_bitvector (64)) >>= fun (w__65 : mword 64) =>
   write_reg TCR_EL2 w__65 >>
   (undefined_bitvector (64)) >>= fun (w__66 : mword 64) =>
   write_reg TCR_EL3 w__66 >>
   (undefined_bitvector (64)) >>= fun (w__67 : mword 64) =>
   write_reg VTCR_EL2 w__67 >>
   (undefined_bitvector (64)) >>= fun (w__68 : mword 64) =>
   write_reg SCTLR_EL1 w__68 >>
   (undefined_bitvector (64)) >>= fun (w__69 : mword 64) =>
   write_reg SCTLR_EL2 w__69 >>
   (undefined_bitvector (64)) >>= fun (w__70 : mword 64) => write_reg SCTLR_EL3 w__70  : M (unit).

Definition sail_model_init (_ : unit) : M (unit) := (initialize_registers (tt))  : M (unit).



