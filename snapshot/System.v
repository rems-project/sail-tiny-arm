(*Generated by Sail from System.*)
Require Import SailStdpp.Base.
Require Import SailStdpp.Real.
Require Import SailStdpp.ConcurrencyInterfaceTypesV2.
Require Import SailStdpp.ConcurrencyInterfaceV2.
Require Import SailStdpp.ConcurrencyInterfaceBuiltinsV2.
Require Import System_types.
Import Defs.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition neq_int (x : Z) (y : Z) : bool := negb ((Z.eqb (x) (y))).

Definition neq_bool (x : bool) (y : bool) : bool := negb ((Bool.eqb (x) (y))).

Definition eq_bits_int {n : Z} (x : mword n) (y : Z) (*(n >=? 0) && (y >=? 0)*) : bool :=
   Z.eqb ((uint (x))) (y).

Definition __id (x : Z) : Z := x.

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shl_int (m) (n) else shr_int (m) ((Z.opp (n))).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if Z.geb (n) (0) then shr_int (m) (n) else shl_int (m) ((Z.opp (n))).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if andb ((Z.ltb (n) (0))) ((Z.gtb (m) (0))) then Z.sub ((Z.quot ((Z.add (n) (1))) (m))) (1)
   else if andb ((Z.gtb (n) (0))) ((Z.ltb (m) (0))) then Z.sub ((Z.quot ((Z.sub (n) (1))) (m))) (1)
   else Z.quot (n) (m).

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub (n) ((Z.mul (m) ((fdiv_int (n) (m))))).

Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) (*(len >=? 0) && (v0 >=? 0)*) : mword len :=
   if Z.leb (len) v0 then vector_truncate (v) (len) else zero_extend (v) (len).

Definition sail_ones (n : Z) (*n >=? 0*) : mword n := not_vec ((zeros (n))).

Definition slice_mask (n : Z) (i : Z) (l : Z) (*n >=? 0*) : mword n :=
   if Z.geb (l) (n) then shiftl ((sail_ones (n))) (i)
   else
     let one : bits n := sail_mask (n) ((('b"1")  : bits 1)) in
     shiftl ((sub_vec ((shiftl (one) (l))) (one))) (i).

Definition to_bytes_le (n : Z) (b : mword (8 * n)) (*n >? 0*) : vec (mword 8) n :=
   let res := vector_init (n) ((zeros (8))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       vec_update_dec (res) (i)
         ((autocast (T := mword)
           (subrange_vec_dec (b) ((Z.add ((Z.mul (8) (i))) (7))) ((Z.mul (8) (i)))))))).

Definition from_bytes_le (n : Z) (v : vec (mword 8) n) (*n >? 0*) : mword (8 * n) :=
   let res := zeros ((Z.mul (8) (n))) in
   let '(loop_i_lower) := 0 in
   let '(loop_i_upper) := Z.sub (n) (1) in
   (foreach_Z_up loop_i_lower loop_i_upper 1 res
     (fun i res =>
       update_subrange_vec_dec (res) ((Z.add ((Z.mul (8) (i))) (7))) ((Z.mul (8) (i)))
         ((autocast (T := mword)
           (vec_access_dec (v) (i)))))).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.

Definition concat_str_bits {n : Z} (str : string) (x : mword n) : string :=
   String.append (str) ((string_of_bits (x))).

Definition concat_str_dec (str : string) (x : Z) : string := String.append (str) ((dec_str (x))).

Definition undefined_SecurityState '(tt : unit) : M (SecurityState) :=
   (internal_pick ([SS_NonSecure; SS_Root; SS_Realm; SS_Secure]))  : M (SecurityState).

Definition undefined_PARTIDspaceType '(tt : unit) : M (PARTIDspaceType) :=
   (internal_pick ([PIdSpace_Secure; PIdSpace_Root; PIdSpace_Realm; PIdSpace_NonSecure]))
    : M (PARTIDspaceType).

Definition undefined_MPAMinfo '(tt : unit) : M (MPAMinfo) :=
   (undefined_PARTIDspaceType (tt)) >>= fun (w__0 : PARTIDspaceType) =>
   (undefined_bitvector (16)) >>= fun (w__1 : mword 16) =>
   (undefined_bitvector (8)) >>= fun (w__2 : mword 8) =>
   returnM (({| MPAMinfo_mpam_sp := w__0;  MPAMinfo_partid := w__1;  MPAMinfo_pmg := w__2 |})).

Definition undefined_AccessType '(tt : unit) : M (AccessType) :=
   (internal_pick
      ([AccessType_IFETCH;
      AccessType_GPR;
      AccessType_ASIMD;
      AccessType_SVE;
      AccessType_SME;
      AccessType_IC;
      AccessType_DC;
      AccessType_DCZero;
      AccessType_AT;
      AccessType_NV2;
      AccessType_SPE;
      AccessType_GCS;
      AccessType_GPTW;
      AccessType_TTW]))
    : M (AccessType).

Definition undefined_VARange '(tt : unit) : M (VARange) :=
   (internal_pick ([VARange_LOWER; VARange_UPPER]))  : M (VARange).

Definition undefined_MemAtomicOp '(tt : unit) : M (MemAtomicOp) :=
   (internal_pick
      ([MemAtomicOp_GCSSS1;
      MemAtomicOp_ADD;
      MemAtomicOp_BIC;
      MemAtomicOp_EOR;
      MemAtomicOp_ORR;
      MemAtomicOp_SMAX;
      MemAtomicOp_SMIN;
      MemAtomicOp_UMAX;
      MemAtomicOp_UMIN;
      MemAtomicOp_SWP;
      MemAtomicOp_CAS]))
    : M (MemAtomicOp).

Definition undefined_CacheOp '(tt : unit) : M (CacheOp) :=
   (internal_pick ([CacheOp_Clean; CacheOp_Invalidate; CacheOp_CleanInvalidate]))  : M (CacheOp).

Definition undefined_CacheOpScope '(tt : unit) : M (CacheOpScope) :=
   (internal_pick
      ([CacheOpScope_SetWay;
      CacheOpScope_PoU;
      CacheOpScope_PoC;
      CacheOpScope_PoE;
      CacheOpScope_PoP;
      CacheOpScope_PoDP;
      CacheOpScope_PoPA;
      CacheOpScope_ALLU;
      CacheOpScope_ALLUIS]))
    : M (CacheOpScope).

Definition undefined_CacheType '(tt : unit) : M (CacheType) :=
   (internal_pick ([CacheType_Data; CacheType_Tag; CacheType_Data_Tag; CacheType_Instruction]))
    : M (CacheType).

Definition undefined_CachePASpace '(tt : unit) : M (CachePASpace) :=
   (internal_pick
      ([CPAS_NonSecure;
      CPAS_Any;
      CPAS_RealmNonSecure;
      CPAS_Realm;
      CPAS_Root;
      CPAS_SecureNonSecure;
      CPAS_Secure]))
    : M (CachePASpace).

Definition undefined_AccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   (undefined_AccessType (tt)) >>= fun (w__0 : AccessType) =>
   (undefined_bitvector (2)) >>= fun (w__1 : mword 2) =>
   (undefined_SecurityState (tt)) >>= fun (w__2 : SecurityState) =>
   (undefined_bool (tt)) >>= fun (w__3 : bool) =>
   (undefined_bool (tt)) >>= fun (w__4 : bool) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bool (tt)) >>= fun (w__7 : bool) =>
   (undefined_bool (tt)) >>= fun (w__8 : bool) =>
   (undefined_MemAtomicOp (tt)) >>= fun (w__9 : MemAtomicOp) =>
   (undefined_bool (tt)) >>= fun (w__10 : bool) =>
   (undefined_bool (tt)) >>= fun (w__11 : bool) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_CacheOp (tt)) >>= fun (w__13 : CacheOp) =>
   (undefined_CacheOpScope (tt)) >>= fun (w__14 : CacheOpScope) =>
   (undefined_CacheType (tt)) >>= fun (w__15 : CacheType) =>
   (undefined_bool (tt)) >>= fun (w__16 : bool) =>
   (undefined_bool (tt)) >>= fun (w__17 : bool) =>
   (undefined_bool (tt)) >>= fun (w__18 : bool) =>
   (undefined_bool (tt)) >>= fun (w__19 : bool) =>
   (undefined_bool (tt)) >>= fun (w__20 : bool) =>
   (undefined_bool (tt)) >>= fun (w__21 : bool) =>
   (undefined_bool (tt)) >>= fun (w__22 : bool) =>
   (undefined_bool (tt)) >>= fun (w__23 : bool) =>
   (undefined_bool (tt)) >>= fun (w__24 : bool) =>
   (undefined_bool (tt)) >>= fun (w__25 : bool) =>
   (undefined_bool (tt)) >>= fun (w__26 : bool) =>
   (undefined_bool (tt)) >>= fun (w__27 : bool) =>
   (undefined_VARange (tt)) >>= fun (w__28 : VARange) =>
   (undefined_bool (tt)) >>= fun (w__29 : bool) =>
   (undefined_bool (tt)) >>= fun (w__30 : bool) =>
   (undefined_bool (tt)) >>= fun (w__31 : bool) =>
   (undefined_MPAMinfo (tt)) >>= fun (w__32 : MPAMinfo) =>
   returnM (({| AccessDescriptor_acctype := w__0;
                AccessDescriptor_el := w__1;
                AccessDescriptor_ss := w__2;
                AccessDescriptor_acqsc := w__3;
                AccessDescriptor_acqpc := w__4;
                AccessDescriptor_relsc := w__5;
                AccessDescriptor_limitedordered := w__6;
                AccessDescriptor_exclusive := w__7;
                AccessDescriptor_atomicop := w__8;
                AccessDescriptor_modop := w__9;
                AccessDescriptor_nontemporal := w__10;
                AccessDescriptor_read := w__11;
                AccessDescriptor_write := w__12;
                AccessDescriptor_cacheop := w__13;
                AccessDescriptor_opscope := w__14;
                AccessDescriptor_cachetype := w__15;
                AccessDescriptor_pan := w__16;
                AccessDescriptor_transactional := w__17;
                AccessDescriptor_nonfault := w__18;
                AccessDescriptor_firstfault := w__19;
                AccessDescriptor_first := w__20;
                AccessDescriptor_contiguous := w__21;
                AccessDescriptor_streamingsve := w__22;
                AccessDescriptor_ls64 := w__23;
                AccessDescriptor_mops := w__24;
                AccessDescriptor_rcw := w__25;
                AccessDescriptor_rcws := w__26;
                AccessDescriptor_toplevel := w__27;
                AccessDescriptor_varange := w__28;
                AccessDescriptor_a32lsmd := w__29;
                AccessDescriptor_tagchecked := w__30;
                AccessDescriptor_tagaccess := w__31;
                AccessDescriptor_mpam := w__32 |})).

Definition undefined_MemType '(tt : unit) : M (MemType) :=
   (internal_pick ([MemType_Normal; MemType_Device]))  : M (MemType).

Definition undefined_DeviceType '(tt : unit) : M (DeviceType) :=
   (internal_pick ([DeviceType_GRE; DeviceType_nGRE; DeviceType_nGnRE; DeviceType_nGnRnE]))
    : M (DeviceType).

Definition undefined_MemAttrHints '(tt : unit) : M (MemAttrHints) :=
   (undefined_bitvector (2)) >>= fun (w__0 : mword 2) =>
   (undefined_bitvector (2)) >>= fun (w__1 : mword 2) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   returnM (({| MemAttrHints_attrs := w__0;
                MemAttrHints_hints := w__1;
                MemAttrHints_transient := w__2 |})).

Definition undefined_Shareability '(tt : unit) : M (Shareability) :=
   (internal_pick ([Shareability_NSH; Shareability_ISH; Shareability_OSH]))  : M (Shareability).

Definition undefined_MemoryOrdering '(tt : unit) : M (MemoryOrdering) :=
   (internal_pick ([Ordering_Relaxed; Ordering_Acquire; Ordering_AcquireRCpc; Ordering_Release]))
    : M (MemoryOrdering).

Definition undefined_MemTagType '(tt : unit) : M (MemTagType) :=
   (internal_pick ([MemTag_Untagged; MemTag_AllocationTagged; MemTag_CanonicallyTagged]))
    : M (MemTagType).

Definition undefined_MemoryAttributes '(tt : unit) : M (MemoryAttributes) :=
   (undefined_MemType (tt)) >>= fun (w__0 : MemType) =>
   (undefined_DeviceType (tt)) >>= fun (w__1 : DeviceType) =>
   (undefined_MemAttrHints (tt)) >>= fun (w__2 : MemAttrHints) =>
   (undefined_MemAttrHints (tt)) >>= fun (w__3 : MemAttrHints) =>
   (undefined_Shareability (tt)) >>= fun (w__4 : Shareability) =>
   (undefined_MemTagType (tt)) >>= fun (w__5 : MemTagType) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bitvector (1)) >>= fun (w__7 : mword 1) =>
   returnM (({| MemoryAttributes_memtype := w__0;
                MemoryAttributes_device := w__1;
                MemoryAttributes_inner := w__2;
                MemoryAttributes_outer := w__3;
                MemoryAttributes_shareability := w__4;
                MemoryAttributes_tags := w__5;
                MemoryAttributes_notagaccess := w__6;
                MemoryAttributes_xs := w__7 |})).

Definition undefined_PASpace '(tt : unit) : M (PASpace) :=
   (internal_pick ([PAS_NonSecure; PAS_Secure; PAS_Root; PAS_Realm]))  : M (PASpace).

Definition undefined_FullAddress '(tt : unit) : M (FullAddress) :=
   (undefined_PASpace (tt)) >>= fun (w__0 : PASpace) =>
   (undefined_bitvector (56)) >>= fun (w__1 : mword 56) =>
   returnM (({| FullAddress_paspace := w__0;  FullAddress_address := w__1 |})).

Definition undefined_GPCF '(tt : unit) : M (GPCF) :=
   (internal_pick ([GPCF_None; GPCF_AddressSize; GPCF_Walk; GPCF_EABT; GPCF_Fail]))  : M (GPCF).

Definition undefined_GPCFRecord '(tt : unit) : M (GPCFRecord) :=
   (undefined_GPCF (tt)) >>= fun (w__0 : GPCF) =>
   (undefined_int (tt)) >>= fun (w__1 : Z) =>
   returnM (({| GPCFRecord_gpf := w__0;  GPCFRecord_level := w__1 |})).

Definition undefined_Fault '(tt : unit) : M (Fault) :=
   (internal_pick
      ([Fault_None;
      Fault_AccessFlag;
      Fault_Alignment;
      Fault_Background;
      Fault_Domain;
      Fault_Permission;
      Fault_Translation;
      Fault_AddressSize;
      Fault_SyncExternal;
      Fault_SyncExternalOnWalk;
      Fault_SyncParity;
      Fault_SyncParityOnWalk;
      Fault_GPCFOnWalk;
      Fault_GPCFOnOutput;
      Fault_AsyncParity;
      Fault_AsyncExternal;
      Fault_TagCheck;
      Fault_Debug;
      Fault_TLBConflict;
      Fault_BranchTarget;
      Fault_HWUpdateAccessFlag;
      Fault_Lockdown;
      Fault_Exclusive;
      Fault_ICacheMaint]))
    : M (Fault).

Definition undefined_ErrorState '(tt : unit) : M (ErrorState) :=
   (internal_pick
      ([ErrorState_UC;
      ErrorState_UEU;
      ErrorState_UEO;
      ErrorState_UER;
      ErrorState_CE;
      ErrorState_Uncategorized;
      ErrorState_IMPDEF]))
    : M (ErrorState).

Definition undefined_FaultRecord '(tt : unit) : M (FaultRecord) :=
   (undefined_Fault (tt)) >>= fun (w__0 : Fault) =>
   (undefined_AccessDescriptor (tt)) >>= fun (w__1 : AccessDescriptor) =>
   (undefined_FullAddress (tt)) >>= fun (w__2 : FullAddress) =>
   (undefined_GPCFRecord (tt)) >>= fun (w__3 : GPCFRecord) =>
   (undefined_FullAddress (tt)) >>= fun (w__4 : FullAddress) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bool (tt)) >>= fun (w__7 : bool) =>
   (undefined_bool (tt)) >>= fun (w__8 : bool) =>
   (undefined_bool (tt)) >>= fun (w__9 : bool) =>
   (undefined_int (tt)) >>= fun (w__10 : Z) =>
   (undefined_bitvector (1)) >>= fun (w__11 : mword 1) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_bool (tt)) >>= fun (w__13 : bool) =>
   (undefined_bool (tt)) >>= fun (w__14 : bool) =>
   (undefined_bool (tt)) >>= fun (w__15 : bool) =>
   (undefined_bool (tt)) >>= fun (w__16 : bool) =>
   (undefined_bitvector (4)) >>= fun (w__17 : mword 4) =>
   (undefined_ErrorState (tt)) >>= fun (w__18 : ErrorState) =>
   (undefined_bitvector (4)) >>= fun (w__19 : mword 4) =>
   returnM (({| FaultRecord_statuscode := w__0;
                FaultRecord_access := w__1;
                FaultRecord_ipaddress := w__2;
                FaultRecord_gpcf := w__3;
                FaultRecord_paddress := w__4;
                FaultRecord_gpcfs2walk := w__5;
                FaultRecord_s2fs1walk := w__6;
                FaultRecord_write := w__7;
                FaultRecord_s1tagnotdata := w__8;
                FaultRecord_tagaccess := w__9;
                FaultRecord_level := w__10;
                FaultRecord_extflag := w__11;
                FaultRecord_secondstage := w__12;
                FaultRecord_assuredonly := w__13;
                FaultRecord_toplevel := w__14;
                FaultRecord_overlay := w__15;
                FaultRecord_dirtybit := w__16;
                FaultRecord_domain := w__17;
                FaultRecord_merrorstate := w__18;
                FaultRecord_debugmoe := w__19 |})).

Definition undefined_MBReqDomain '(tt : unit) : M (MBReqDomain) :=
   (internal_pick
      ([MBReqDomain_Nonshareable;
      MBReqDomain_InnerShareable;
      MBReqDomain_OuterShareable;
      MBReqDomain_FullSystem]))
    : M (MBReqDomain).

Definition undefined_MBReqTypes '(tt : unit) : M (MBReqTypes) :=
   (internal_pick ([MBReqTypes_Reads; MBReqTypes_Writes; MBReqTypes_All]))  : M (MBReqTypes).

Definition undefined_CacheRecord '(tt : unit) : M (CacheRecord) :=
   (undefined_AccessType (tt)) >>= fun (w__0 : AccessType) =>
   (undefined_CacheOp (tt)) >>= fun (w__1 : CacheOp) =>
   (undefined_CacheOpScope (tt)) >>= fun (w__2 : CacheOpScope) =>
   (undefined_CacheType (tt)) >>= fun (w__3 : CacheType) =>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   (undefined_FullAddress (tt)) >>= fun (w__5 : FullAddress) =>
   (undefined_bitvector (64)) >>= fun (w__6 : mword 64) =>
   (undefined_int (tt)) >>= fun (w__7 : Z) =>
   (undefined_int (tt)) >>= fun (w__8 : Z) =>
   (undefined_int (tt)) >>= fun (w__9 : Z) =>
   (undefined_Shareability (tt)) >>= fun (w__10 : Shareability) =>
   (undefined_bool (tt)) >>= fun (w__11 : bool) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_bitvector (16)) >>= fun (w__13 : mword 16) =>
   (undefined_bool (tt)) >>= fun (w__14 : bool) =>
   (undefined_bitvector (16)) >>= fun (w__15 : mword 16) =>
   (undefined_SecurityState (tt)) >>= fun (w__16 : SecurityState) =>
   (undefined_CachePASpace (tt)) >>= fun (w__17 : CachePASpace) =>
   returnM (({| CacheRecord_acctype := w__0;
                CacheRecord_cacheop := w__1;
                CacheRecord_opscope := w__2;
                CacheRecord_cachetype := w__3;
                CacheRecord_regval := w__4;
                CacheRecord_paddress := w__5;
                CacheRecord_vaddress := w__6;
                CacheRecord_setnum := w__7;
                CacheRecord_waynum := w__8;
                CacheRecord_level := w__9;
                CacheRecord_shareability := w__10;
                CacheRecord_translated := w__11;
                CacheRecord_is_vmid_valid := w__12;
                CacheRecord_vmid := w__13;
                CacheRecord_is_asid_valid := w__14;
                CacheRecord_asid := w__15;
                CacheRecord_security := w__16;
                CacheRecord_cpas := w__17 |})).

Definition undefined_Regime '(tt : unit) : M (Regime) :=
   (internal_pick ([Regime_EL3; Regime_EL30; Regime_EL2; Regime_EL20; Regime_EL10]))  : M (Regime).

Definition undefined_TGx '(tt : unit) : M (TGx) :=
   (internal_pick ([TGx_4KB; TGx_16KB; TGx_64KB]))  : M (TGx).

Definition undefined_TLBContext '(tt : unit) : M (TLBContext) :=
   (undefined_SecurityState (tt)) >>= fun (w__0 : SecurityState) =>
   (undefined_Regime (tt)) >>= fun (w__1 : Regime) =>
   (undefined_bitvector (16)) >>= fun (w__2 : mword 16) =>
   (undefined_bitvector (16)) >>= fun (w__3 : mword 16) =>
   (undefined_bitvector (1)) >>= fun (w__4 : mword 1) =>
   (undefined_PASpace (tt)) >>= fun (w__5 : PASpace) =>
   (undefined_bool (tt)) >>= fun (w__6 : bool) =>
   (undefined_bool (tt)) >>= fun (w__7 : bool) =>
   (undefined_bool (tt)) >>= fun (w__8 : bool) =>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   (undefined_TGx (tt)) >>= fun (w__10 : TGx) =>
   (undefined_bitvector (1)) >>= fun (w__11 : mword 1) =>
   (undefined_int (tt)) >>= fun (w__12 : Z) =>
   (undefined_bool (tt)) >>= fun (w__13 : bool) =>
   (undefined_bitvector (1)) >>= fun (w__14 : mword 1) =>
   returnM (({| TLBContext_ss := w__0;
                TLBContext_regime := w__1;
                TLBContext_vmid := w__2;
                TLBContext_asid := w__3;
                TLBContext_nG := w__4;
                TLBContext_ipaspace := w__5;
                TLBContext_includes_s1_name := w__6;
                TLBContext_includes_s2_name := w__7;
                TLBContext_includes_gpt_name := w__8;
                TLBContext_ia := w__9;
                TLBContext_tg := w__10;
                TLBContext_cnp := w__11;
                TLBContext_level := w__12;
                TLBContext_isd128 := w__13;
                TLBContext_xs := w__14 |})).

Definition undefined_AddressDescriptor '(tt : unit) : M (AddressDescriptor) :=
   (undefined_FaultRecord (tt)) >>= fun (w__0 : FaultRecord) =>
   (undefined_MemoryAttributes (tt)) >>= fun (w__1 : MemoryAttributes) =>
   (undefined_FullAddress (tt)) >>= fun (w__2 : FullAddress) =>
   (undefined_TLBContext (tt)) >>= fun (w__3 : TLBContext) =>
   (undefined_bool (tt)) >>= fun (w__4 : bool) =>
   (undefined_bool (tt)) >>= fun (w__5 : bool) =>
   (undefined_bitvector (16)) >>= fun (w__6 : mword 16) =>
   (undefined_bitvector (64)) >>= fun (w__7 : mword 64) =>
   returnM (({| AddressDescriptor_fault := w__0;
                AddressDescriptor_memattrs := w__1;
                AddressDescriptor_paddress := w__2;
                AddressDescriptor_tlbcontext := w__3;
                AddressDescriptor_s1assured := w__4;
                AddressDescriptor_s2fs1mro := w__5;
                AddressDescriptor_mecid := w__6;
                AddressDescriptor_vaddress := w__7 |})).

Definition undefined_TranslationStartInfo '(tt : unit) : M (TranslationStartInfo) :=
   (undefined_SecurityState (tt)) >>= fun (w__0 : SecurityState) =>
   (undefined_Regime (tt)) >>= fun (w__1 : Regime) =>
   (undefined_bitvector (16)) >>= fun (w__2 : mword 16) =>
   (undefined_bitvector (16)) >>= fun (w__3 : mword 16) =>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   (undefined_bitvector (1)) >>= fun (w__5 : mword 1) =>
   (undefined_AccessDescriptor (tt)) >>= fun (w__6 : AccessDescriptor) =>
   (undefined_int (tt)) >>= fun (w__7 : Z) =>
   returnM (({| TranslationStartInfo_ss := w__0;
                TranslationStartInfo_regime := w__1;
                TranslationStartInfo_vmid := w__2;
                TranslationStartInfo_asid := w__3;
                TranslationStartInfo_va := w__4;
                TranslationStartInfo_cnp := w__5;
                TranslationStartInfo_accdesc := w__6;
                TranslationStartInfo_size := w__7 |})).

Definition undefined_TLBILevel '(tt : unit) : M (TLBILevel) :=
   (internal_pick ([TLBILevel_Any; TLBILevel_Last]))  : M (TLBILevel).

Definition undefined_TLBIOp '(tt : unit) : M (TLBIOp) :=
   (internal_pick
      ([TLBIOp_DALL;
      TLBIOp_DASID;
      TLBIOp_DVA;
      TLBIOp_IALL;
      TLBIOp_IASID;
      TLBIOp_IVA;
      TLBIOp_ALL;
      TLBIOp_ASID;
      TLBIOp_IPAS2;
      TLBIPOp_IPAS2;
      TLBIOp_VAA;
      TLBIOp_VA;
      TLBIPOp_VAA;
      TLBIPOp_VA;
      TLBIOp_VMALL;
      TLBIOp_VMALLS12;
      TLBIOp_RIPAS2;
      TLBIPOp_RIPAS2;
      TLBIOp_RVAA;
      TLBIOp_RVA;
      TLBIPOp_RVAA;
      TLBIPOp_RVA;
      TLBIOp_RPA;
      TLBIOp_PAALL]))
    : M (TLBIOp).

Definition undefined_TLBIMemAttr '(tt : unit) : M (TLBIMemAttr) :=
   (internal_pick ([TLBI_AllAttr; TLBI_ExcludeXS]))  : M (TLBIMemAttr).

Definition undefined_TLBIRecord '(tt : unit) : M (TLBIRecord) :=
   (undefined_TLBIOp (tt)) >>= fun (w__0 : TLBIOp) =>
   (undefined_bool (tt)) >>= fun (w__1 : bool) =>
   (undefined_SecurityState (tt)) >>= fun (w__2 : SecurityState) =>
   (undefined_Regime (tt)) >>= fun (w__3 : Regime) =>
   (undefined_bitvector (16)) >>= fun (w__4 : mword 16) =>
   (undefined_bitvector (16)) >>= fun (w__5 : mword 16) =>
   (undefined_TLBILevel (tt)) >>= fun (w__6 : TLBILevel) =>
   (undefined_TLBIMemAttr (tt)) >>= fun (w__7 : TLBIMemAttr) =>
   (undefined_PASpace (tt)) >>= fun (w__8 : PASpace) =>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   (undefined_bitvector (64)) >>= fun (w__10 : mword 64) =>
   (undefined_bool (tt)) >>= fun (w__11 : bool) =>
   (undefined_bool (tt)) >>= fun (w__12 : bool) =>
   (undefined_bitvector (4)) >>= fun (w__13 : mword 4) =>
   (undefined_bitvector (2)) >>= fun (w__14 : mword 2) =>
   returnM (({| TLBIRecord_op := w__0;
                TLBIRecord_from_aarch64 := w__1;
                TLBIRecord_security := w__2;
                TLBIRecord_regime := w__3;
                TLBIRecord_vmid := w__4;
                TLBIRecord_asid := w__5;
                TLBIRecord_level := w__6;
                TLBIRecord_attr := w__7;
                TLBIRecord_ipaspace := w__8;
                TLBIRecord_address := w__9;
                TLBIRecord_end_address_name := w__10;
                TLBIRecord_d64 := w__11;
                TLBIRecord_d128 := w__12;
                TLBIRecord_ttl := w__13;
                TLBIRecord_tg := w__14 |})).

Definition undefined_TLBIInfo '(tt : unit) : M (TLBIInfo) :=
   (undefined_TLBIRecord (tt)) >>= fun (w__0 : TLBIRecord) =>
   (undefined_Shareability (tt)) >>= fun (w__1 : Shareability) =>
   returnM (({| TLBIInfo_rec := w__0;  TLBIInfo_shareability := w__1 |})).

Definition undefined_DxB '(tt : unit) : M (DxB) :=
   (undefined_MBReqDomain (tt)) >>= fun (w__0 : MBReqDomain) =>
   (undefined_MBReqTypes (tt)) >>= fun (w__1 : MBReqTypes) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   returnM (({| DxB_domain := w__0;  DxB_types := w__1;  DxB_nXS := w__2 |})).

Definition undefined_move_imm_data '(tt : unit) : M (move_imm_data) :=
   (undefined_bitvector (16)) >>= fun (w__0 : mword 16) =>
   (undefined_bitvector (2)) >>= fun (w__1 : mword 2) =>
   returnM (({| move_imm_data_imm := w__0;  move_imm_data_hw := w__1 |})).

Definition GPRs : vec (register_ref (bits 64)) 31 :=
vec_of_list_len [R30_ref;R29_ref;R28_ref;R27_ref;R26_ref;R25_ref;R24_ref;R23_ref;R22_ref;R21_ref;
                 R20_ref;R19_ref;R18_ref;R17_ref;R16_ref;R15_ref;R14_ref;R13_ref;R12_ref;R11_ref;
                 R10_ref;R9_ref;R8_ref;R7_ref;R6_ref;R5_ref;R4_ref;R3_ref;R2_ref;R1_ref;R0_ref].
#[export] Hint Unfold GPRs : sail.
Definition wX (n : Z) (value : mword 64) (*(0 <=? n) && (n <=? 31)*) : M (unit) :=
   (if neq_int (n) (31) return M (unit) then
      write_reg_ref (vec_access_dec (GPRs) (n)) value
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition rX (n : Z) (*(0 <=? n) && (n <=? 31)*) : M (mword 64) :=
   (if neq_int (n) (31) return M (mword 64) then
      (reg_deref ((vec_access_dec (GPRs) (n))))
       : M (mword 64)
    else returnM (((Ox"0000000000000000")  : mword 64)))
    : M (mword 64).

Definition wW (n : Z) (value : mword 32) (*(0 <=? n) && (n <=? 31)*) : M (unit) :=
   (if neq_int (n) (31) return M (unit) then
      write_reg_ref (vec_access_dec (GPRs) (n)) (zero_extend (value) (64))
       : M (unit)
    else returnM (tt))
    : M (unit).

Definition rW (n : Z) (*(0 <=? n) && (n <=? 31)*) : M (mword 32) :=
   (if neq_int (n) (31) return M (mword 32) then
      (reg_deref ((vec_access_dec (GPRs) (n)))) >>= fun (w__0 : mword 64) =>
      returnM ((subrange_vec_dec (w__0) (31) (0)))
    else returnM (((Ox"00000000")  : mword 32)))
    : M (mword 32).

Definition rPC '(tt : unit) : M (mword 64) := ((read_reg _PC)  : M (mword 64))  : M (mword 64).

Definition wPC (pc : mword 64) : M (unit) := write_reg _PC pc  : M (unit).

Definition undefined_ProcState '(tt : unit) : M (ProcState) :=
   (undefined_bitvector (1)) >>= fun (w__0 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__1 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__2 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__3 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__4 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__5 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__6 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__7 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__8 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__9 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__10 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__11 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__12 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__13 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__14 : mword 1) =>
   (undefined_bitvector (2)) >>= fun (w__15 : mword 2) =>
   (undefined_bitvector (1)) >>= fun (w__16 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__17 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__18 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__19 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__20 : mword 1) =>
   (undefined_bitvector (2)) >>= fun (w__21 : mword 2) =>
   (undefined_bitvector (1)) >>= fun (w__22 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__23 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__24 : mword 1) =>
   (undefined_bitvector (4)) >>= fun (w__25 : mword 4) =>
   (undefined_bitvector (1)) >>= fun (w__26 : mword 1) =>
   (undefined_bitvector (8)) >>= fun (w__27 : mword 8) =>
   (undefined_bitvector (1)) >>= fun (w__28 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__29 : mword 1) =>
   (undefined_bitvector (1)) >>= fun (w__30 : mword 1) =>
   (undefined_bitvector (5)) >>= fun (w__31 : mword 5) =>
   returnM (({| ProcState_N := w__0;
                ProcState_Z := w__1;
                ProcState_C := w__2;
                ProcState_V := w__3;
                ProcState_D := w__4;
                ProcState_A := w__5;
                ProcState_I := w__6;
                ProcState_F := w__7;
                ProcState_EXLOCK := w__8;
                ProcState_PAN := w__9;
                ProcState_UAO := w__10;
                ProcState_DIT := w__11;
                ProcState_TCO := w__12;
                ProcState_PM := w__13;
                ProcState_PPEND := w__14;
                ProcState_BTYPE := w__15;
                ProcState_ZA := w__16;
                ProcState_SM := w__17;
                ProcState_ALLINT := w__18;
                ProcState_SS := w__19;
                ProcState_IL := w__20;
                ProcState_EL := w__21;
                ProcState_nRW := w__22;
                ProcState_SP := w__23;
                ProcState_Q := w__24;
                ProcState_GE := w__25;
                ProcState_SSBS := w__26;
                ProcState_IT := w__27;
                ProcState_J := w__28;
                ProcState_T := w__29;
                ProcState_E := w__30;
                ProcState_M := w__31 |})).

Definition is_ok {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => true | Err _ => false end.

Definition is_err {a : Type} {b : Type} (r : result a b) : bool :=
   match r with | Ok _ => false | Err _ => true end.

Definition ok_option {a : Type} {b : Type} (r : result a b) : option a :=
   match r with | Ok x => Some (x) | Err _ => None end.

Definition err_option {a : Type} {b : Type} (r : result a b) : option b :=
   match r with | Ok _ => None | Err err => Some (err) end.

Definition unwrap_or {a : Type} {b : Type} (r : result a b) (y : a) : a :=
   match r with | Ok x => x | Err _ => y end.

Definition sail_instr_announce {n : Z} (_ : mword n) (*n >? 0*) : unit := tt.

Definition sail_branch_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition sail_reset_registers '(tt : unit) : unit := tt.

Definition sail_synchronize_registers '(tt : unit) : unit := tt.

Definition sail_mark_register {a : Type} (_ : register_ref a) (_ : string) : unit := tt.

Definition sail_mark_register_pair {a : Type} {b : Type}
(_ : register_ref a) (_ : register_ref b) (_ : string)
: unit :=
   tt.

Definition sail_ignore_write_to {a : Type} (reg : register_ref a) : unit :=
   sail_mark_register (reg) ("ignore_write").

Definition sail_pick_dependency {a : Type} (reg : register_ref a) : unit :=
   sail_mark_register (reg) ("pick").

Definition __monomorphize {n : Z} (bv : mword n) (*n >=? 0*) : mword n := bv.

Definition __monomorphize_int (n : Z) : Z := n.

Definition __monomorphize_bool (b : bool) : bool := b.

Definition __monomorphize_reads : bool := false.
#[export] Hint Unfold __monomorphize_reads : sail.
Definition __monomorphize_writes : bool := false.
#[export] Hint Unfold __monomorphize_writes : sail.
Definition sail_address_announce (addrsize : Z) (_ : mword addrsize)
(*member_Z_list addrsize [32; 64]*)
: unit :=
   tt.

Definition addr_size' : Z := 56.
#[export] Hint Unfold addr_size' : sail.
Definition base_AccessDescriptor (acctype : AccessType) : AccessDescriptor :=
   {| AccessDescriptor_acctype := acctype;
      AccessDescriptor_el := zeros (2);
      AccessDescriptor_ss := SS_NonSecure;
      AccessDescriptor_acqsc := false;
      AccessDescriptor_acqpc := false;
      AccessDescriptor_relsc := false;
      AccessDescriptor_limitedordered := false;
      AccessDescriptor_exclusive := false;
      AccessDescriptor_atomicop := false;
      AccessDescriptor_modop := MemAtomicOp_ADD;
      AccessDescriptor_nontemporal := false;
      AccessDescriptor_read := false;
      AccessDescriptor_write := false;
      AccessDescriptor_cacheop := CacheOp_Clean;
      AccessDescriptor_opscope := CacheOpScope_ALLU;
      AccessDescriptor_cachetype := CacheType_Data;
      AccessDescriptor_pan := false;
      AccessDescriptor_transactional := false;
      AccessDescriptor_nonfault := false;
      AccessDescriptor_firstfault := false;
      AccessDescriptor_first := false;
      AccessDescriptor_contiguous := false;
      AccessDescriptor_streamingsve := false;
      AccessDescriptor_ls64 := false;
      AccessDescriptor_mops := false;
      AccessDescriptor_rcw := false;
      AccessDescriptor_rcws := false;
      AccessDescriptor_toplevel := false;
      AccessDescriptor_varange := VARange_LOWER;
      AccessDescriptor_a32lsmd := false;
      AccessDescriptor_tagchecked := false;
      AccessDescriptor_tagaccess := false;
      AccessDescriptor_mpam :=
        {| MPAMinfo_mpam_sp := PIdSpace_NonSecure;
           MPAMinfo_partid := (Ox"0000")  : mword 16;
           MPAMinfo_pmg := (Ox"00")  : mword 8 |} |}.

Definition current_el '(tt : unit) : M (mword 2) :=
   read_reg PSTATE >>= fun (w__0 : ProcState) => returnM (w__0.(ProcState_EL)).

Definition create_GPRAccessDescriptor (is_write : bool) (ordering : MemoryOrdering)
: M (AccessDescriptor) :=
   let accdesc := base_AccessDescriptor (AccessType_GPR) in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_write := is_write|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_read := negb (is_write)|> in
   (current_el (tt)) >>= fun (w__0 : mword 2) =>
   let accdesc := (accdesc <|AccessDescriptor_el := w__0|>)  : AccessDescriptor in
   let accdesc : AccessDescriptor :=
     match ordering with
     | Ordering_Relaxed => accdesc
     | Ordering_Acquire => accdesc <|AccessDescriptor_acqsc := true|>
     | Ordering_AcquireRCpc => accdesc <|AccessDescriptor_acqpc := true|>
     | Ordering_Release => accdesc <|AccessDescriptor_relsc := true|>
     end in
   returnM (accdesc).

Definition create_readAccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   (create_GPRAccessDescriptor (false) (Ordering_Relaxed))  : M (AccessDescriptor).

Definition create_writeAccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   (create_GPRAccessDescriptor (true) (Ordering_Relaxed))  : M (AccessDescriptor).

Definition create_readAcquireAccessDescriptor (ordering : MemoryOrdering) : M (AccessDescriptor) :=
   (create_GPRAccessDescriptor (false) (ordering))  : M (AccessDescriptor).

Definition create_writeReleaseAccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   (create_GPRAccessDescriptor (true) (Ordering_Release))  : M (AccessDescriptor).

Definition create_iFetchAccessDescriptor '(tt : unit) : M (AccessDescriptor) :=
   let accdesc := base_AccessDescriptor (AccessType_IFETCH) in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_read := true|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_write := false|> in
   (current_el (tt)) >>= fun (w__0 : mword 2) =>
   let accdesc := (accdesc <|AccessDescriptor_el := w__0|>)  : AccessDescriptor in
   returnM (accdesc).

Definition undefined_DescriptorType '(tt : unit) : M (DescriptorType) :=
   (internal_pick ([DescriptorType_Table; DescriptorType_Leaf; DescriptorType_Invalid]))
    : M (DescriptorType).

Definition base_FullAddress '(tt : unit) : FullAddress :=
   {| FullAddress_paspace := PAS_NonSecure;  FullAddress_address := zeros (56) |}.

Definition base_FaultRecord (accdesc : AccessDescriptor) : FaultRecord :=
   {| FaultRecord_statuscode := Fault_None;
      FaultRecord_access := accdesc;
      FaultRecord_ipaddress := base_FullAddress (tt);
      FaultRecord_gpcf := {| GPCFRecord_gpf := GPCF_None;  GPCFRecord_level := 0 |};
      FaultRecord_paddress := base_FullAddress (tt);
      FaultRecord_gpcfs2walk := false;
      FaultRecord_s2fs1walk := false;
      FaultRecord_write :=
        andb ((negb (accdesc.(AccessDescriptor_read)))) (accdesc.(AccessDescriptor_write));
      FaultRecord_s1tagnotdata := false;
      FaultRecord_tagaccess := false;
      FaultRecord_level := 0;
      FaultRecord_extflag := zeros (1);
      FaultRecord_secondstage := false;
      FaultRecord_assuredonly := false;
      FaultRecord_toplevel := false;
      FaultRecord_overlay := false;
      FaultRecord_dirtybit := false;
      FaultRecord_domain := zeros (4);
      FaultRecord_merrorstate := ErrorState_UC;
      FaultRecord_debugmoe := zeros (4) |}.

Definition base_MemoryAttributes '(tt : unit) : MemoryAttributes :=
   {| MemoryAttributes_memtype := MemType_Normal;
      MemoryAttributes_device := DeviceType_GRE;
      MemoryAttributes_inner :=
        {| MemAttrHints_attrs := zeros (2);
           MemAttrHints_hints := zeros (2);
           MemAttrHints_transient := false |};
      MemoryAttributes_outer :=
        {| MemAttrHints_attrs := zeros (2);
           MemAttrHints_hints := zeros (2);
           MemAttrHints_transient := false |};
      MemoryAttributes_shareability := Shareability_ISH;
      MemoryAttributes_tags := MemTag_Untagged;
      MemoryAttributes_notagaccess := false;
      MemoryAttributes_xs := zeros (1) |}.

Definition base_TLBContext '(tt : unit) : TLBContext :=
   {| TLBContext_ss := SS_NonSecure;
      TLBContext_regime := Regime_EL10;
      TLBContext_vmid := zeros (16);
      TLBContext_asid := zeros (16);
      TLBContext_nG := zeros (1);
      TLBContext_ipaspace := PAS_NonSecure;
      TLBContext_includes_s1_name := false;
      TLBContext_includes_s2_name := false;
      TLBContext_includes_gpt_name := false;
      TLBContext_ia := zeros (64);
      TLBContext_tg := TGx_4KB;
      TLBContext_cnp := zeros (1);
      TLBContext_level := 0;
      TLBContext_isd128 := false;
      TLBContext_xs := zeros (1) |}.

Definition base_AddressDescriptor (accdesc : AccessDescriptor) : AddressDescriptor :=
   {| AddressDescriptor_fault := base_FaultRecord (accdesc);
      AddressDescriptor_memattrs := base_MemoryAttributes (tt);
      AddressDescriptor_paddress := base_FullAddress (tt);
      AddressDescriptor_tlbcontext := base_TLBContext (tt);
      AddressDescriptor_s1assured := false;
      AddressDescriptor_s2fs1mro := false;
      AddressDescriptor_mecid := zeros (16);
      AddressDescriptor_vaddress := zeros (64) |}.

Definition base_TLBIRecord (op : TLBIOp) : TLBIRecord :=
   {| TLBIRecord_op := op;
      TLBIRecord_from_aarch64 := true;
      TLBIRecord_security := SS_NonSecure;
      TLBIRecord_regime := Regime_EL10;
      TLBIRecord_vmid := (Ox"0000")  : mword 16;
      TLBIRecord_asid := (Ox"0000")  : mword 16;
      TLBIRecord_level := TLBILevel_Any;
      TLBIRecord_attr := TLBI_AllAttr;
      TLBIRecord_ipaspace := PAS_NonSecure;
      TLBIRecord_address := zeros (64);
      TLBIRecord_end_address_name := zeros (64);
      TLBIRecord_d64 := true;
      TLBIRecord_d128 := false;
      TLBIRecord_ttl := (Ox"0")  : mword 4;
      TLBIRecord_tg := ('b"00")  : mword 2 |}.

Definition addr_space_def := PAS_NonSecure.
#[export] Hint Unfold addr_space_def : sail.
Definition read_memory (N : Z) (addr : mword 56) (accdesc : AccessDescriptor) (*N >? 0*)
: M (mword (N * 8)) :=
   let req : Mem_request N 0 addr_size addr_space AccessDescriptor :=
     {| Mem_request_access_kind := accdesc;
        Mem_request_address := vector_truncate (addr) (addr_size');
        Mem_request_address_space := addr_space_def;
        Mem_request_size := N;
        Mem_request_num_tag := 0 |} in
   (sail_mem_read ((autocast (T := fun _sz => (Mem_request _ _ _sz _ _)%type) req))) >>= fun (w__0 : result ((vec (mword 8) N * vec bool 0)) Fault) =>
   match w__0 with
   | Ok (bytes, _) => returnM ((autocast (T := mword) (from_bytes_le ((__id (N))) (bytes))))
   | Err _e => exit tt  : M (mword (N * 8))
   end
    : M (mword (N * 8)).

Definition iFetch (addr : mword 56) (accdesc : AccessDescriptor) : M (mword 32) :=
   (read_memory (4) (addr) (accdesc))  : M (mword (4 * 8)).

Definition rMem (N : Z) (addr : mword 56) (accdesc : AccessDescriptor) (*N >? 0*)
: M (mword (N * 8)) :=
   (read_memory (N) (addr) (accdesc))  : M (mword (N * 8)).

Definition wMem_Addr (addr : mword 56) : unit :=
   sail_address_announce (64) ((zero_extend (addr) (64))).

Definition wMem (N : Z) (addr : mword 56) (value : mword (N * 8)) (accdesc : AccessDescriptor)
(*N >? 0*)
: M (unit) :=
   let req : Mem_request N 0 addr_size addr_space AccessDescriptor :=
     {| Mem_request_access_kind := accdesc;
        Mem_request_address := vector_truncate (addr) (addr_size');
        Mem_request_address_space := addr_space_def;
        Mem_request_size := N;
        Mem_request_num_tag := 0 |} in
   (sail_mem_write ((autocast (T := fun _sz => (Mem_request _ _ _sz _ _)%type) req))
      ((to_bytes_le (N) ((autocast (T := mword)  value)))) ((vec_of_list_len []))) >>= fun (w__0 : result unit Fault) =>
   match w__0 with | Ok _ => returnM (tt) | Err _ => exit tt  : M (unit) end
    : M (unit).

Definition dataMemoryBarrier (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   (sail_barrier
      ((Barrier_DMB (({| DxB_domain := domain;  DxB_types := types;  DxB_nXS := false |})))))
    : M (unit).

Definition dataSynchronizationBarrer (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   (sail_barrier
      ((Barrier_DSB (({| DxB_domain := domain;  DxB_types := types;  DxB_nXS := false |})))))
    : M (unit).

Definition instructionSynchronizationBarrier '(tt : unit) : M (unit) :=
   (sail_barrier ((Barrier_ISB (tt))))  : M (unit).

Definition reportTLBI (op : TLBIOp) (addr : option (mword 64)) (asid : option (mword 16)) : M (unit) :=
   let r := base_TLBIRecord (op) in
   let r : TLBIRecord :=
     r
     <|TLBIRecord_address :=
       match addr with | Some addr => addr | None => (Ox"0000000000000000")  : mword 64 end|> in
   let r : TLBIRecord :=
     r
     <|TLBIRecord_asid := match asid with | Some asid => asid | None => (Ox"0000")  : mword 16 end|> in
   (sail_tlbi (({| TLBIInfo_rec := r;  TLBIInfo_shareability := Shareability_ISH |})))
    : M (unit).

Definition undefined_Permissions '(tt : unit) : M (Permissions) :=
   (undefined_bool (tt)) >>= fun (w__0 : bool) =>
   (undefined_bool (tt)) >>= fun (w__1 : bool) =>
   (undefined_bool (tt)) >>= fun (w__2 : bool) =>
   (undefined_bool (tt)) >>= fun (w__3 : bool) =>
   returnM (({| Permissions_allow_write := w__0;
                Permissions_allow_unprivileged_data := w__1;
                Permissions_allow_unprivileged_exec := w__2;
                Permissions_allow_privileged_exec := w__3 |})).

Definition extract_perms_table (descriptor : mword 64) : Permissions :=
   let ap_table := subrange_vec_dec (descriptor) (62) (61) in
   {| Permissions_allow_write :=
        eq_vec ((vec_of_bits [access_vec_dec (ap_table) (1)]  : mword 1)) ((('b"0")  : mword 1));
      Permissions_allow_unprivileged_data :=
        eq_vec ((vec_of_bits [access_vec_dec (ap_table) (0)]  : mword 1)) ((('b"0")  : mword 1));
      Permissions_allow_unprivileged_exec :=
        eq_vec ((vec_of_bits [access_vec_dec (descriptor) (60)]  : mword 1)) ((('b"0")  : mword 1));
      Permissions_allow_privileged_exec :=
        eq_vec ((vec_of_bits [access_vec_dec (descriptor) (59)]  : mword 1)) ((('b"0")  : mword 1)) |}.

Definition extract_perms_leaf (descriptor : mword 64) : Permissions :=
   let ap := subrange_vec_dec (descriptor) (7) (6) in
   {| Permissions_allow_write :=
        eq_vec ((vec_of_bits [access_vec_dec (ap) (1)]  : mword 1)) ((('b"0")  : mword 1));
      Permissions_allow_unprivileged_data :=
        eq_vec ((vec_of_bits [access_vec_dec (ap) (0)]  : mword 1)) ((('b"1")  : mword 1));
      Permissions_allow_unprivileged_exec :=
        eq_vec ((vec_of_bits [access_vec_dec (descriptor) (54)]  : mword 1)) ((('b"0")  : mword 1));
      Permissions_allow_privileged_exec :=
        eq_vec ((vec_of_bits [access_vec_dec (descriptor) (53)]  : mword 1)) ((('b"0")  : mword 1)) |}.

Definition create_AccessDescriptorTTW (toplevel : bool) (varange : VARange) : M (AccessDescriptor) :=
   let accdesc : AccessDescriptor := base_AccessDescriptor (AccessType_TTW) in
   read_reg PSTATE >>= fun (w__0 : ProcState) =>
   let accdesc := (accdesc <|AccessDescriptor_el := w__0.(ProcState_EL)|>)  : AccessDescriptor in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_read := true|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_toplevel := toplevel|> in
   let accdesc : AccessDescriptor := accdesc <|AccessDescriptor_varange := varange|> in
   returnM (accdesc).

Definition get_VARange (va : mword 64) : VARange :=
   if eq_vec ((vec_of_bits [access_vec_dec (va) (48)]  : mword 1)) ((('b"0")  : mword 1)) then
     VARange_LOWER
   else VARange_UPPER.

Definition va_out_of_range (va : mword 64) : bool :=
   negb
     ((orb ((eq_vec ((subrange_vec_dec (va) (63) (48))) (((Ox"0000")  : mword 16))))
         ((eq_vec ((subrange_vec_dec (va) (63) (48))) (((Ox"FFFF")  : mword 16)))))).

Definition get_translation_base_address (varange : VARange) : M (mword 56) :=
   match varange with
   | VARange_LOWER => ((read_reg TTBR0_EL1)  : M (mword 64))  : M (mword 64)
   | VARange_UPPER => ((read_reg TTBR1_EL1)  : M (mword 64))  : M (mword 64)
   end >>= fun (ttbr : bits 64) =>
   let baddr := zeros (56) in
   let baddr : mword 56 :=
     update_subrange_vec_dec (baddr) (47) (5) ((subrange_vec_dec (ttbr) (47) (5))) in
   returnM (baddr).

Definition ASID_read '(tt : unit) : M (mword 16) :=
   ((read_reg TCR_EL1)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   (if eq_vec ((slice (w__0) (22) (1))) ((zeros (1))) return M (mword 16) then
      ((read_reg TTBR0_EL1)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
      returnM ((slice (w__1) (48) (16)))
    else
      ((read_reg TTBR1_EL1)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
      returnM ((slice (w__2) (48) (16))))
    : M (mword 16).

Definition is_fault (addrdesc : AddressDescriptor) : bool :=
   match addrdesc.(AddressDescriptor_fault).(FaultRecord_statuscode) with
   | Fault_None => false
   | _ => true
   end.

Definition check_permission (perms : Permissions) (accdesc : AccessDescriptor) : bool :=
   let at_el0 := eq_vec (accdesc.(AccessDescriptor_el)) ((('b"00")  : mword 2)) in
   if generic_eq (accdesc.(AccessDescriptor_acctype)) (AccessType_IFETCH) then
     if at_el0 then perms.(Permissions_allow_unprivileged_exec)
     else perms.(Permissions_allow_privileged_exec)
   else if andb (accdesc.(AccessDescriptor_write)) ((negb (perms.(Permissions_allow_write)))) then
     false
   else if andb (at_el0) ((negb (perms.(Permissions_allow_unprivileged_data)))) then false
   else true.

Definition get_TTEntryAddress (level : Z) (ia : mword 64) (baseaddress : mword 56)
(*(0 <=? level) && (level <=? 3)*)
: mword 56 :=
   let stride := 9 in
   let lsb := Z.add ((Z.mul ((Z.sub (3) (level))) (stride))) (12) in
   let msb := Z.sub ((Z.add (lsb) (stride))) (1) in
   let index := zero_extend ((concat_vec ((subrange_vec_dec (ia) (msb) (lsb))) ((zeros (3))))) (56) in
   or_vec (baseaddress) (index).

Definition decode_desc_type (descriptor : mword 64) (level : Z) : DescriptorType :=
   if eq_vec ((vec_of_bits [access_vec_dec (descriptor) (0)]  : mword 1)) ((('b"0")  : mword 1))
   then
     DescriptorType_Invalid
   else if eq_vec ((vec_of_bits [access_vec_dec (descriptor) (1)]  : mword 1))
             ((('b"1")
              : mword 1)) then
     if Z.eqb (level) (3) then DescriptorType_Leaf
     else DescriptorType_Table
   else if eq_vec ((vec_of_bits [access_vec_dec (descriptor) (1)]  : mword 1))
             ((('b"0")
              : mword 1)) then
     if orb ((Z.eqb (level) (1))) ((Z.eqb (level) (2))) then DescriptorType_Leaf
     else DescriptorType_Invalid
   else DescriptorType_Invalid.

Definition pgt_walk (va : mword 64) (accdesc : AccessDescriptor) : M (AddressDescriptor) :=
   catch_early_return
     (let varange := get_VARange (va) in
     liftR ((get_translation_base_address (varange))) >>= fun baseaddress =>
     let descaddress := get_TTEntryAddress (0) (va) (baseaddress) in
     let addrdesc := base_AddressDescriptor (accdesc) in
     let addrdesc : AddressDescriptor := addrdesc <|AddressDescriptor_vaddress := va|> in
     let addrdesc : AddressDescriptor :=
       addrdesc
       <|AddressDescriptor_fault :=
         addrdesc.(AddressDescriptor_fault)
         <|FaultRecord_write := accdesc.(AccessDescriptor_write)|>|> in
     let addrdesc : AddressDescriptor :=
       addrdesc
       <|AddressDescriptor_fault :=
         addrdesc.(AddressDescriptor_fault)
         <|FaultRecord_access := accdesc|>|> in
     (let '(loop_level_lower) := 0 in
     let '(loop_level_upper) := 3 in
     (foreach_ZM_up loop_level_lower loop_level_upper 1 (addrdesc, descaddress)
       (fun level '(addrdesc, descaddress) =>
         let addrdesc : AddressDescriptor :=
           addrdesc
           <|AddressDescriptor_fault :=
             addrdesc.(AddressDescriptor_fault)
             <|FaultRecord_level := level|>|> in
         liftR ((create_AccessDescriptorTTW ((Z.eqb (level) (0))) (varange))) >>= fun walkaccess =>
         liftR ((read_memory (8) (descaddress) (walkaccess))) >>= fun descriptor =>
         match decode_desc_type (descriptor) (level) with
         | DescriptorType_Table =>
            let perms := extract_perms_table (descriptor) in
            (if negb ((check_permission (perms) (accdesc)))
               return
               MR (AddressDescriptor) ((AddressDescriptor * mword 56)) then
               let addrdesc : AddressDescriptor :=
                 addrdesc
                 <|AddressDescriptor_fault :=
                   addrdesc.(AddressDescriptor_fault)
                   <|FaultRecord_statuscode := Fault_Permission|>|> in
               (early_return (addrdesc  : AddressDescriptor) : MR AddressDescriptor unit) >>
               returnR (AddressDescriptor) ((addrdesc, descaddress))
             else
               let next_baseaddress :=
                 concat_vec (((Ox"00")  : mword 8))
                   ((concat_vec ((subrange_vec_dec (descriptor) (47) (12)))
                       (((Ox"000")
                        : mword 12)))) in
               liftR (assert_exp' (Z.ltb (level) (3)) "Table entry at level 3") >>= fun _ =>
               let descaddress : mword 56 :=
                 get_TTEntryAddress ((Z.add (level) (1))) (va) (next_baseaddress) in
               returnR (AddressDescriptor) ((addrdesc, descaddress)))
             : MR (AddressDescriptor) ((AddressDescriptor * mword 56))
         | DescriptorType_Leaf =>
            let perms := extract_perms_leaf (descriptor) in
            let '((w__0, addrdesc)) :=
              (if negb ((check_permission (perms) (accdesc))) then
                 let addrdesc : AddressDescriptor :=
                   addrdesc
                   <|AddressDescriptor_fault :=
                     addrdesc.(AddressDescriptor_fault)
                     <|FaultRecord_statuscode := Fault_Permission|>|> in
                 (addrdesc, addrdesc)
               else
                 let offset := Z.add (12) ((Z.mul ((Z.sub (3) (level))) (9))) in
                 let out_pa :=
                   concat_vec (((Ox"00")  : mword 8))
                     ((concat_vec ((subrange_vec_dec (descriptor) (47) (offset)))
                         ((subrange_vec_dec (va) ((Z.sub (offset) (1))) (0))))) in
                 let addrdesc : AddressDescriptor :=
                   addrdesc
                   <|AddressDescriptor_paddress :=
                     addrdesc.(AddressDescriptor_paddress)
                     <|FullAddress_address := autocast (T := mword)  out_pa|>|> in
                 (addrdesc, addrdesc))
               : (AddressDescriptor * AddressDescriptor) in
            (early_return (w__0  : AddressDescriptor) : MR AddressDescriptor unit) >>
            returnR (AddressDescriptor) ((addrdesc, descaddress))
         | DescriptorType_Invalid =>
            let addrdesc : AddressDescriptor :=
              addrdesc
              <|AddressDescriptor_fault :=
                addrdesc.(AddressDescriptor_fault)
                <|FaultRecord_statuscode := Fault_Translation|>|> in
            (early_return (addrdesc  : AddressDescriptor) : MR AddressDescriptor unit) >>
            returnR (AddressDescriptor) ((addrdesc, descaddress))
         end
          : MR (AddressDescriptor) ((AddressDescriptor * mword 56))))) >>= fun '((addrdesc, descaddress)
     : (AddressDescriptor * mword 56)) =>
     liftR (exit tt)
      : MR (AddressDescriptor) (AddressDescriptor)).

Definition handle_fault (addrdesc : AddressDescriptor) : M (unit) :=
   let fault : FaultRecord := addrdesc.(AddressDescriptor_fault) in
   let vaddress := addrdesc.(AddressDescriptor_vaddress) in
   let source_el := fault.(FaultRecord_access).(AccessDescriptor_el) in
   let target_el := ('b"01")  : mword 2 in
   (if eq_vec (source_el) (target_el) return M (mword 12) then
      read_reg PSTATE >>= fun (w__0 : ProcState) =>
      let w__1 : mword 12 :=
        if eq_vec (w__0.(ProcState_SP)) ((('b"0")  : mword 1)) then (Ox"000")  : mword 12
        else (Ox"200")  : mword 12 in
      returnM (w__1)
    else returnM (((Ox"400")  : mword 12))) >>= fun vect_offset =>
   (sail_take_exception ((Some (fault)))) >>
   let ec := ('b"000000")  : mword 6 in
   let il := ('b"1")  : mword 1 in
   (if generic_eq (fault.(FaultRecord_access).(AccessDescriptor_acctype)) (AccessType_IFETCH) then
      let ec : mword 6 :=
        if eq_vec (source_el) (target_el) then ('b"100001")  : mword 6
        else ('b"100000")  : mword 6 in
      returnM (ec)
    else if generic_eq (fault.(FaultRecord_access).(AccessDescriptor_acctype)) (AccessType_GPR) then
      let ec : mword 6 :=
        if eq_vec (source_el) (target_el) then ('b"100101")  : mword 6
        else ('b"100100")  : mword 6 in
      returnM (ec)
    else exit tt >> returnM (ec)) >>= fun (ec : mword 6) =>
   let l__0 := fault.(FaultRecord_level) in
   (if Z.eqb (l__0) (0) then returnM ((('b"00")  : mword 2))
    else if Z.eqb (l__0) (1) then returnM ((('b"01")  : mword 2))
    else if Z.eqb (l__0) (2) then returnM ((('b"10")  : mword 2))
    else if Z.eqb (l__0) (3) then returnM ((('b"11")  : mword 2))
    else exit tt  : M (mword 2)) >>= fun (level_bit : bits 2) =>
   let dfsc : bits 6 :=
     if generic_eq (fault.(FaultRecord_statuscode)) (Fault_Translation) then
       concat_vec (((Ox"1")  : mword 4)) (level_bit)
     else if generic_eq (fault.(FaultRecord_statuscode)) (Fault_Permission) then
       concat_vec (((Ox"3")  : mword 4)) (level_bit)
     else ('b"000000")  : mword 6 in
   let wnr := if fault.(FaultRecord_write) then ('b"1")  : mword 1 else ('b"0")  : mword 1 in
   let iss := zero_extend ((concat_vec (wnr) (dfsc))) (25) in
   write_reg ESR_EL1 (zero_extend ((concat_vec ((concat_vec (ec) (il))) (iss))) (64)) >>
   write_reg FAR_EL1 vaddress >>
   read_reg PSTATE >>= fun (w__6 : ProcState) =>
   read_reg PSTATE >>= fun (w__7 : ProcState) =>
   read_reg PSTATE >>= fun (w__8 : ProcState) =>
   read_reg PSTATE >>= fun (w__9 : ProcState) =>
   read_reg PSTATE >>= fun (w__10 : ProcState) =>
   read_reg PSTATE >>= fun (w__11 : ProcState) =>
   read_reg PSTATE >>= fun (w__12 : ProcState) =>
   read_reg PSTATE >>= fun (w__13 : ProcState) =>
   read_reg PSTATE >>= fun (w__14 : ProcState) =>
   read_reg PSTATE >>= fun (w__15 : ProcState) =>
   write_reg
     SPSR_EL1
     (zero_extend
        ((concat_vec (w__6.(ProcState_N))
            ((concat_vec (w__7.(ProcState_Z))
                ((concat_vec (w__8.(ProcState_C))
                    ((concat_vec (w__9.(ProcState_V))
                        ((concat_vec ((('b"0000000000000000000")  : mword 19))
                            ((concat_vec (w__10.(ProcState_D))
                                ((concat_vec (w__11.(ProcState_A))
                                    ((concat_vec (w__12.(ProcState_I))
                                        ((concat_vec (w__13.(ProcState_F))
                                            ((concat_vec ((('b"00")  : mword 2))
                                                ((concat_vec (w__14.(ProcState_EL))
                                                    ((concat_vec ((('b"0")  : mword 1))
                                                        (w__15.(ProcState_SP))))))))))))))))))))))))))
        (64)) >>
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__16 : mword 64) =>
   write_reg ELR_EL1 w__16 >>
   read_reg PSTATE >>= fun (w__17 : ProcState) =>
   write_reg PSTATE (w__17 <|ProcState_EL := ('b"01")  : mword 2|>) >>
   read_reg PSTATE >>= fun (w__18 : ProcState) =>
   write_reg PSTATE (w__18 <|ProcState_SP := ('b"1")  : mword 1|>) >>
   read_reg PSTATE >>= fun (w__19 : ProcState) =>
   write_reg PSTATE (w__19 <|ProcState_D := ('b"1")  : mword 1|>) >>
   read_reg PSTATE >>= fun (w__20 : ProcState) =>
   write_reg PSTATE (w__20 <|ProcState_A := ('b"1")  : mword 1|>) >>
   read_reg PSTATE >>= fun (w__21 : ProcState) =>
   write_reg PSTATE (w__21 <|ProcState_I := ('b"1")  : mword 1|>) >>
   read_reg PSTATE >>= fun (w__22 : ProcState) =>
   write_reg PSTATE (w__22 <|ProcState_F := ('b"1")  : mword 1|>) >>
   ((read_reg VBAR_EL1)  : M (mword 64)) >>= fun (w__23 : mword 64) =>
   write_reg _PC (concat_vec ((slice (w__23) (12) (52))) (vect_offset))
    : M (unit).

Definition translate_address (va : mword 64) (accdesc : AccessDescriptor) : M (option (mword 56)) :=
   ((read_reg SCTLR_EL1)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   (if eq_vec ((slice (w__0) (0) (1))) ((('b"0")  : mword 1)) then
      returnM ((Some ((vector_truncate (va) (addr_size')))))
    else
      (if generic_eq ((get_VARange (va))) (VARange_LOWER) return M (mword 1) then
         ((read_reg TTBR0_EL1)  : M (mword 64)) >>= fun (w__1 : mword 64) =>
         returnM ((slice (w__1) (0) (1)))
       else
         ((read_reg TTBR1_EL1)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
         returnM ((slice (w__2) (0) (1)))) >>= fun cnp =>
      (ASID_read (tt)) >>= fun (w__3 : mword 16) =>
      let tsi : TranslationStartInfo :=
        {| TranslationStartInfo_ss := SS_NonSecure;
           TranslationStartInfo_regime := Regime_EL10;
           TranslationStartInfo_vmid := (Ox"0000")  : mword 16;
           TranslationStartInfo_asid := w__3;
           TranslationStartInfo_va := va;
           TranslationStartInfo_cnp := cnp;
           TranslationStartInfo_accdesc := accdesc;
           TranslationStartInfo_size := 0 |} in
      (sail_translation_start (tsi)) >>
      (if va_out_of_range (va) then
         let addrdesc := base_AddressDescriptor (accdesc) in
         let addrdesc : AddressDescriptor :=
           addrdesc
           <|AddressDescriptor_fault :=
             addrdesc.(AddressDescriptor_fault)
             <|FaultRecord_statuscode := Fault_Translation|>|> in
         let addrdesc : AddressDescriptor :=
           addrdesc
           <|AddressDescriptor_fault :=
             addrdesc.(AddressDescriptor_fault)
             <|FaultRecord_write := accdesc.(AccessDescriptor_write)|>|> in
         let addrdesc : AddressDescriptor :=
           addrdesc
           <|AddressDescriptor_fault :=
             addrdesc.(AddressDescriptor_fault)
             <|FaultRecord_access := accdesc|>|> in
         returnM (addrdesc)
       else (pgt_walk (va) (accdesc))  : M (AddressDescriptor)) >>= fun addrdesc =>
      (sail_translation_end (addrdesc)) >>
      (if is_fault (addrdesc) return M (option (mword 56)) then
         (handle_fault (addrdesc)) >> returnM (None)
       else returnM ((Some (addrdesc.(AddressDescriptor_paddress).(FullAddress_address)))))
       : M (option (mword 56)))
    : M (option (mword 56)).

Definition execute_load (sf : bitU) (t : Z) (vaddr : mword 64) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   catch_early_return
     (liftR ((create_readAccessDescriptor (tt))) >>= fun accdesc =>
     liftR ((translate_address (vaddr) (accdesc))) >>= fun (w__0 : option (mword 56)) =>
     match w__0 with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 56))  : MR (unit) (mword 56)
     end >>= fun (addr : bits addr_size) =>
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__2 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__2) (4))) >>
     (if eq_bit (sf) (B1) return MR (unit) (unit) then
        liftR ((rMem (8) (addr) (accdesc))) >>= fun (data : bits 64) =>
        liftR ((wX (t) (data)))
         : MR (unit) (unit)
      else
        liftR ((rMem (4) (addr) (accdesc))) >>= fun (data : bits 32) =>
        liftR ((wW (t) (data)))
         : MR (unit) (unit))
      : MR (unit) (unit)).

Definition execute_store (sf : bitU) (t : Z) (vaddr : mword 64) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   catch_early_return
     (liftR ((create_writeAccessDescriptor (tt))) >>= fun accdesc =>
     liftR ((translate_address (vaddr) (accdesc))) >>= fun (w__0 : option (mword 56)) =>
     match w__0 with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 56))  : MR (unit) (mword 56)
     end >>= fun (addr : bits addr_size) =>
     let '(_) := (wMem_Addr (addr))  : unit in
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__2 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__2) (4))) >>
     (if eq_bit (sf) (B1) return MR (unit) (unit) then
        liftR ((rX (t))) >>= fun data =>
        liftR ((wMem (8) (addr) (data) (accdesc)))
         : MR (unit) (unit)
      else
        liftR ((rW (t))) >>= fun data =>
        liftR ((wMem (4) (addr) (data) (accdesc)))
         : MR (unit) (unit))
      : MR (unit) (unit)).

Definition execute_load_acquire (sf : bitU) (t : Z) (vaddr : mword 64) (ordering : MemoryOrdering)
(*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   catch_early_return
     (liftR ((create_readAcquireAccessDescriptor (ordering))) >>= fun accdesc =>
     liftR ((translate_address (vaddr) (accdesc))) >>= fun (w__0 : option (mword 56)) =>
     match w__0 with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 56))  : MR (unit) (mword 56)
     end >>= fun (addr : bits addr_size) =>
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__2 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__2) (4))) >>
     (if eq_bit (sf) (B1) return MR (unit) (unit) then
        liftR ((rMem (8) (addr) (accdesc))) >>= fun (data : bits 64) =>
        liftR ((wX (t) (data)))
         : MR (unit) (unit)
      else
        liftR ((rMem (4) (addr) (accdesc))) >>= fun (data : bits 32) =>
        liftR ((wW (t) (data)))
         : MR (unit) (unit))
      : MR (unit) (unit)).

Definition execute_store_release (sf : bitU) (t : Z) (vaddr : mword 64) (*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   catch_early_return
     (liftR ((create_writeReleaseAccessDescriptor (tt))) >>= fun accdesc =>
     liftR ((translate_address (vaddr) (accdesc))) >>= fun (w__0 : option (mword 56)) =>
     match w__0 with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 56))  : MR (unit) (mword 56)
     end >>= fun (addr : bits addr_size) =>
     let '(_) := (wMem_Addr (addr))  : unit in
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__2 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__2) (4))) >>
     (if eq_bit (sf) (B1) return MR (unit) (unit) then
        liftR ((rX (t))) >>= fun data =>
        liftR ((wMem (8) (addr) (data) (accdesc)))
         : MR (unit) (unit)
      else
        liftR ((rW (t))) >>= fun data =>
        liftR ((wMem (4) (addr) (data) (accdesc)))
         : MR (unit) (unit))
      : MR (unit) (unit)).

Definition decodeLoadStoreRegister
(size : mword 2) (opc : mword 2) (Rm : mword 5) (option_v : mword 3) (S' : bitU) (Rn : mword 5)
(Rt : mword 5)
: option ast :=
   let t : reg_index := uint (Rt) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
   if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
   then
     None
   else if orb ((neq_vec (option_v) ((('b"011")  : mword 3)))) ((eq_bit (S') (B1))) then None
   else if eq_vec (opc) ((('b"01")  : mword 2)) then Some ((Load ((sf, t, n, OperandReg (m)))))
   else if eq_vec (opc) ((('b"00")  : mword 2)) then Some ((Store ((sf, t, n, OperandReg (m)))))
   else None.

Definition decodeLoadStoreImmediate
(size : mword 2) (opc : mword 2) (imm12 : mword 12) (Rn : mword 5) (Rt : mword 5)
: option ast :=
   let t : reg_index := uint (Rt) in
   let n : reg_index := uint (Rn) in
   let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
   if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
   then
     None
   else if eq_vec (opc) ((('b"01")  : mword 2)) then Some ((Load ((sf, t, n, OperandImm (imm12)))))
   else if eq_vec (opc) ((('b"00")  : mword 2)) then Some ((Store ((sf, t, n, OperandImm (imm12)))))
   else None.

Definition decodeBitwiseAndRegister
(sf : bitU) (shift : mword 2) (N : bitU) (Rm : mword 5) (imm6 : mword 6) (Rn : mword 5)
(Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if andb ((eq_bit (sf) (B0))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))) then None
   else if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
   else Some ((BitwiseAnd ((sf, d, n, OperandReg (m))))).

Definition decode_bitmask_immediate (N : bitU) (imms : mword 6) (immr : mword 6) : option (mword 64) :=
   if andb ((eq_bit (N) (B1))) ((eq_vec (immr) ((('b"000000")  : mword 6)))) then
     let ones : Z := Z.add ((uint (imms))) (1) in
     if andb ((Z.geb (ones) (1))) ((Z.leb (ones) (63))) then
       let mask : bits 64 := sail_mask (64) ((sail_ones (ones))) in
       Some (mask)
     else None
   else None.

Definition decodeBitwiseAndImmediate
(sf : bitU) (N : bitU) (immr : mword 6) (imms : mword 6) (Rn : mword 5) (Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   if andb ((eq_bit (sf) (B0))) ((eq_bit (N) (B1))) then None
   else
     match decode_bitmask_immediate (N) (imms) (immr) with
     | Some mask =>
        let imm12 : bits 12 := subrange_vec_dec (mask) (11) (0) in
        Some ((BitwiseAnd ((sf, d, n, OperandImm (imm12)))))
     | None => None
     end.

Definition decodeExclusiveOr
(sf : bitU) (shift : mword 2) (N : bitU) (Rm : mword 5) (imm6 : mword 6) (Rn : mword 5)
(Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if andb ((eq_bit (sf) (B0))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))) then None
   else if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
   else Some ((ExclusiveOr ((sf, d, n, m)))).

Definition decodeInclusiveOr
(sf : bitU) (shift : mword 2) (N : bitU) (Rm : mword 5) (imm6 : mword 6) (Rn : mword 5)
(Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if andb ((eq_bit (sf) (B0))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))) then None
   else if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
   else Some ((InclusiveOr ((sf, d, n, m)))).

Definition decodeAddSub
(sf : bitU) (op : bitU) (is_imm : bitU) (shift : mword 2) (imm12 : mword 12) (imm6 : mword 6)
(Rm : mword 5) (Rn : mword 5) (Rd : mword 5)
: option ast :=
   let d : reg_index := uint (Rd) in
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   if andb ((eq_bit (sf) (B0)))
        ((andb ((eq_bit (is_imm) (B0))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))))) then
     None
   else if eq_bit (is_imm) (B0) then
     if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
     else if eq_bit (op) (B0) then Some ((Add ((sf, d, n, OperandReg (m)))))
     else Some ((Sub ((sf, d, n, OperandReg (m)))))
   else if eq_vec (shift) ((('b"00")  : mword 2)) then
     if eq_bit (op) (B0) then Some ((Add ((sf, d, n, OperandImm (imm12)))))
     else Some ((Sub ((sf, d, n, OperandImm (imm12)))))
   else None.

Definition decodeCompare
(sf : bitU) (shift : mword 2) (imm12 : mword 12) (imm6 : mword 6) (Rm : mword 5) (Rn : mword 5)
: option ast :=
   let n : reg_index := uint (Rn) in
   let m : reg_index := uint (Rm) in
   let is_imm :=
     orb ((neq_vec (imm12) (((Ox"000")  : mword 12))))
       ((andb ((eq_vec (Rm) ((('b"00000")  : mword 5))))
           ((eq_vec (imm6) ((('b"000000")  : mword 6)))))) in
   if andb ((eq_bit (sf) (B0)))
        ((andb ((Bool.eqb (is_imm) (false))) ((eq_bit ((access_vec_dec (imm6) (5))) (B1))))) then
     None
   else if Bool.eqb (is_imm) (false) then
     if neq_vec (imm6) ((('b"000000")  : mword 6)) then None
     else Some ((Compare ((sf, n, OperandReg (m)))))
   else if eq_vec (shift) ((('b"00")  : mword 2)) then
     Some ((Compare ((sf, n, OperandImm (imm12)))))
   else None.

Definition decodeDataBarrier (CRm : mword 4) (is_sync : bool) : option ast :=
   pure_early_return
     (let b__3 := subrange_vec_dec (CRm) (3) (2) in
     (if eq_vec (b__3) ((('b"11")  : mword 2)) then inr (MBReqDomain_FullSystem)
      else if eq_vec (b__3) ((('b"10")  : mword 2)) then inr (MBReqDomain_InnerShareable)
      else if eq_vec (b__3) ((('b"01")  : mword 2)) then inr (MBReqDomain_Nonshareable)
      else if eq_vec (b__3) ((('b"00")  : mword 2)) then inr (MBReqDomain_OuterShareable)
      else
        (inl (None  : option ast) : sum (option ast) MBReqDomain)
         : sum (option ast) (MBReqDomain)) >>$= fun '(domain) =>
     let b__0 := subrange_vec_dec (CRm) (1) (0) in
     (if eq_vec (b__0) ((('b"01")  : mword 2)) then inr (MBReqTypes_Reads)
      else if eq_vec (b__0) ((('b"10")  : mword 2)) then inr (MBReqTypes_Writes)
      else if eq_vec (b__0) ((('b"11")  : mword 2)) then inr (MBReqTypes_All)
      else (inl (None  : option ast) : sum (option ast) MBReqTypes)  : sum (option ast) (MBReqTypes)) >>$= fun '(types) =>
     inr ((if is_sync then Some ((DataSynchronizationBarrier ((domain, types))))
           else Some ((DataMemoryBarrier ((domain, types))))))).

Definition decodeCompareAndBranch (sf : bitU) (op : bitU) (imm19 : mword 19) (Rt : mword 5)
: option ast :=
   let t : reg_index := uint (Rt) in
   let offset : bits 64 := sign_extend ((concat_vec (imm19) ((('b"00")  : mword 2)))) (64) in
   let iszero : bool := eq_bit (op) (B0) in
   Some ((CompareAndBranch ((sf, t, offset, iszero)))).

Definition decodeTLBI (op1 : mword 3) (CRn : mword 4) (CRm : mword 4) (op2 : mword 3) (Rt : mword 5)
: option ast :=
   pure_early_return
     (let t : reg_index := uint (Rt) in
     match (op1, CRn, CRm, op2) with
     | (b__0, b__1, b__2, b__3) =>
        (if andb ((eq_vec (b__0) ((('b"100")  : mword 3))))
              ((andb ((eq_vec (b__1) (((Ox"8")  : mword 4))))
                  ((andb ((eq_vec (b__2) (((Ox"7")  : mword 4))))
                      ((eq_vec (b__3) ((('b"100")  : mword 3)))))))) then
           inr (TLBIOp_ALL)
         else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                   ((andb ((eq_vec (b__1) (((Ox"8")  : mword 4))))
                       ((andb ((eq_vec (b__2) (((Ox"3")  : mword 4))))
                           ((eq_vec (b__3) ((('b"001")  : mword 3)))))))) then
           inr (TLBIOp_VA)
         else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                   ((andb ((eq_vec (b__1) (((Ox"8")  : mword 4))))
                       ((andb ((eq_vec (b__2) (((Ox"3")  : mword 4))))
                           ((eq_vec (b__3) ((('b"010")  : mword 3)))))))) then
           inr (TLBIOp_ASID)
         else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                   ((andb ((eq_vec (b__1) (((Ox"8")  : mword 4))))
                       ((andb ((eq_vec (b__2) (((Ox"3")  : mword 4))))
                           ((eq_vec (b__3) ((('b"011")  : mword 3)))))))) then
           inr (TLBIOp_VAA)
         else (inl (None  : option ast) : sum (option ast) TLBIOp)  : sum (option ast) (TLBIOp))
         : sum (option ast) (TLBIOp)
     end >>$= fun '(tlbi_op) =>
     inr ((Some ((TLBInvalidation ((tlbi_op, t))))))).

Definition condition_holds (cond : mword 4) : M (bool) :=
   read_reg PSTATE >>= fun (w__0 : ProcState) =>
   let n := eq_vec (w__0.(ProcState_N)) ((('b"1")  : mword 1)) in
   read_reg PSTATE >>= fun (w__1 : ProcState) =>
   let z := eq_vec (w__1.(ProcState_Z)) ((('b"1")  : mword 1)) in
   read_reg PSTATE >>= fun (w__2 : ProcState) =>
   let c := eq_vec (w__2.(ProcState_C)) ((('b"1")  : mword 1)) in
   read_reg PSTATE >>= fun (w__3 : ProcState) =>
   let v := eq_vec (w__3.(ProcState_V)) ((('b"1")  : mword 1)) in
   let b__0 := cond in
   returnM ((if eq_vec (b__0) (((Ox"0")  : mword 4)) then z
             else if eq_vec (b__0) (((Ox"1")  : mword 4)) then negb (z)
             else if eq_vec (b__0) (((Ox"2")  : mword 4)) then c
             else if eq_vec (b__0) (((Ox"3")  : mword 4)) then negb (c)
             else if eq_vec (b__0) (((Ox"4")  : mword 4)) then n
             else if eq_vec (b__0) (((Ox"5")  : mword 4)) then negb (n)
             else if eq_vec (b__0) (((Ox"6")  : mword 4)) then v
             else if eq_vec (b__0) (((Ox"7")  : mword 4)) then negb (v)
             else if eq_vec (b__0) (((Ox"8")  : mword 4)) then andb (c) ((negb (z)))
             else if eq_vec (b__0) (((Ox"9")  : mword 4)) then orb ((negb (c))) (z)
             else if eq_vec (b__0) (((Ox"A")  : mword 4)) then Bool.eqb (n) (v)
             else if eq_vec (b__0) (((Ox"B")  : mword 4)) then neq_bool (n) (v)
             else if eq_vec (b__0) (((Ox"C")  : mword 4)) then
               andb ((negb (z))) ((Bool.eqb (n) (v)))
             else if eq_vec (b__0) (((Ox"D")  : mword 4)) then orb (z) ((neq_bool (n) (v)))
             else if eq_vec (b__0) (((Ox"E")  : mword 4)) then true
             else true)).

Definition decodeSystemRegisterMove
(is_read : bool) (op1 : mword 3) (CRn : mword 4) (CRm : mword 4) (op2 : mword 3) (Rt : mword 5)
: option ast :=
   Some ((SystemRegisterMove ((is_read, op1, CRn, CRm, op2, uint (Rt))))).

Definition lookup_sys_reg (op1 : mword 3) (CRn : mword 4) (CRm : mword 4) (op2 : mword 3)
: option (register_ref (mword 64)) :=
   match (op1, CRn, CRm, op2) with
   | (b__0, b__1, b__2, b__3) =>
      if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
           ((andb ((eq_vec (b__1) (((Ox"1")  : mword 4))))
               ((andb ((eq_vec (b__2) (((Ox"0")  : mword 4))))
                   ((eq_vec (b__3) ((('b"000")  : mword 3)))))))) then
        Some (SCTLR_EL1_ref)
      else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                ((andb ((eq_vec (b__1) (((Ox"2")  : mword 4))))
                    ((andb ((eq_vec (b__2) (((Ox"0")  : mword 4))))
                        ((eq_vec (b__3) ((('b"000")  : mword 3)))))))) then
        Some (TTBR0_EL1_ref)
      else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                ((andb ((eq_vec (b__1) (((Ox"2")  : mword 4))))
                    ((andb ((eq_vec (b__2) (((Ox"0")  : mword 4))))
                        ((eq_vec (b__3) ((('b"001")  : mword 3)))))))) then
        Some (TTBR1_EL1_ref)
      else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                ((andb ((eq_vec (b__1) (((Ox"2")  : mword 4))))
                    ((andb ((eq_vec (b__2) (((Ox"0")  : mword 4))))
                        ((eq_vec (b__3) ((('b"010")  : mword 3)))))))) then
        Some (TCR_EL1_ref)
      else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                ((andb ((eq_vec (b__1) (((Ox"4")  : mword 4))))
                    ((andb ((eq_vec (b__2) (((Ox"0")  : mword 4))))
                        ((eq_vec (b__3) ((('b"000")  : mword 3)))))))) then
        Some (SPSR_EL1_ref)
      else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                ((andb ((eq_vec (b__1) (((Ox"4")  : mword 4))))
                    ((andb ((eq_vec (b__2) (((Ox"0")  : mword 4))))
                        ((eq_vec (b__3) ((('b"001")  : mword 3)))))))) then
        Some (ELR_EL1_ref)
      else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                ((andb ((eq_vec (b__1) (((Ox"5")  : mword 4))))
                    ((andb ((eq_vec (b__2) (((Ox"2")  : mword 4))))
                        ((eq_vec (b__3) ((('b"000")  : mword 3)))))))) then
        Some (ESR_EL1_ref)
      else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                ((andb ((eq_vec (b__1) (((Ox"6")  : mword 4))))
                    ((andb ((eq_vec (b__2) (((Ox"0")  : mword 4))))
                        ((eq_vec (b__3) ((('b"000")  : mword 3)))))))) then
        Some (FAR_EL1_ref)
      else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                ((andb ((eq_vec (b__1) (((Ox"7")  : mword 4))))
                    ((andb ((eq_vec (b__2) (((Ox"4")  : mword 4))))
                        ((eq_vec (b__3) ((('b"000")  : mword 3)))))))) then
        Some (PAR_EL1_ref)
      else if andb ((eq_vec (b__0) ((('b"000")  : mword 3))))
                ((andb ((eq_vec (b__1) (((Ox"C")  : mword 4))))
                    ((andb ((eq_vec (b__2) (((Ox"0")  : mword 4))))
                        ((eq_vec (b__3) ((('b"000")  : mword 3)))))))) then
        Some (VBAR_EL1_ref)
      else None
   end.

Definition execute_TLBInvalidation (op : TLBIOp) (t : Z) (*(0 <=? t) && (t <=? 31)*) : M (unit) :=
   catch_early_return
     (match op with
     | TLBIOp_ALL => returnR (unit) ((None, None))
     | TLBIOp_VA =>
        liftR ((rX (t))) >>= fun (w__0 : mword 64) => returnR (unit) ((Some (w__0), None))
     | TLBIOp_ASID =>
        liftR ((rX (t))) >>= fun (w__1 : mword 64) =>
        returnR (unit) ((None, Some ((subrange_vec_dec (w__1) (63) (48)))))
     | TLBIOp_VAA =>
        liftR ((rX (t))) >>= fun (w__2 : mword 64) => returnR (unit) ((Some (w__2), None))
     | _ =>
        (early_return (tt  : unit) : MR unit (option (mword 64) * option (mword 16)))
         : MR (unit) ((option (mword 64) * option (mword 16)))
     end >>= fun '((va, asid)
     : (option (bits 64) * option (bits 16))) =>
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__4 : mword 64) =>
     liftR (write_reg _PC (add_vec_int (w__4) (4))) >>
     liftR ((reportTLBI (op) (va) (asid)))
      : MR (unit) (unit)).

Definition execute_SystemRegisterMove
(is_read : bool) (op1 : mword 3) (CRn : mword 4) (CRm : mword 4) (op2 : mword 3) (t : Z)
(*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   let sys_reg_opt := lookup_sys_reg (op1) (CRn) (CRm) (op2) in
   match sys_reg_opt with
   | Some reg_ref =>
      (if is_read return M (unit) then
         (reg_deref (reg_ref)) >>= fun (w__1 : mword 64) => (wX (t) (w__1))  : M (unit)
       else (rX (t)) >>= fun (w__2 : mword 64) => write_reg_ref reg_ref w__2  : M (unit))
       : M (unit)
   | None =>
      assert_exp' false (String.append ("Unsupported System Register: ")
                           ((String.append ((if is_read then "MRS" else "MSR"))
                               ((String.append (" op1=")
                                   ((String.append ((string_of_bits (op1)))
                                       ((String.append (" CRn=")
                                           ((String.append ((string_of_bits (CRn)))
                                               ((String.append (" CRm=")
                                                   ((String.append ((string_of_bits (CRm)))
                                                       ((String.append (" op2=")
                                                           ((String.append ((string_of_bits (op2)))
                                                               ((String.append (" Rt=")
                                                                   ((dec_str (t)))))))))))))))))))))))) >>= fun _ =>
      exit tt
   end
    : M (unit).

Definition execute_SupervisorCall (imm16 : mword 16) : M (unit) :=
   read_reg PSTATE >>= fun (w__0 : ProcState) =>
   let source_el := w__0.(ProcState_EL) in
   let target_el := ('b"01")  : mword 2 in
   (if eq_vec (source_el) (target_el) return M (mword 12) then
      read_reg PSTATE >>= fun (w__1 : ProcState) =>
      let w__2 : mword 12 :=
        if eq_vec (w__1.(ProcState_SP)) ((('b"0")  : mword 1)) then (Ox"000")  : mword 12
        else (Ox"200")  : mword 12 in
      returnM (w__2)
    else returnM (((Ox"400")  : mword 12))) >>= fun (vect_offset : bits 12) =>
   (sail_take_exception (None)) >>
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__3 : mword 64) =>
   write_reg ELR_EL1 (add_vec_int (w__3) (4)) >>
   ((read_reg VBAR_EL1)  : M (mword 64)) >>= fun (w__4 : mword 64) =>
   write_reg _PC (concat_vec ((subrange_vec_dec (w__4) (63) (12))) (vect_offset)) >>
   let ec : bits 6 := ('b"010101")  : mword 6 in
   let il : bits 1 := ('b"1")  : mword 1 in
   let iss : bits 25 := zero_extend (imm16) (25) in
   write_reg ESR_EL1 (zero_extend ((concat_vec ((concat_vec (ec) (il))) (iss))) (64)) >>
   read_reg PSTATE >>= fun (w__5 : ProcState) =>
   read_reg PSTATE >>= fun (w__6 : ProcState) =>
   read_reg PSTATE >>= fun (w__7 : ProcState) =>
   read_reg PSTATE >>= fun (w__8 : ProcState) =>
   read_reg PSTATE >>= fun (w__9 : ProcState) =>
   read_reg PSTATE >>= fun (w__10 : ProcState) =>
   read_reg PSTATE >>= fun (w__11 : ProcState) =>
   read_reg PSTATE >>= fun (w__12 : ProcState) =>
   read_reg PSTATE >>= fun (w__13 : ProcState) =>
   read_reg PSTATE >>= fun (w__14 : ProcState) =>
   write_reg
     SPSR_EL1
     (zero_extend
        ((concat_vec (w__5.(ProcState_N))
            ((concat_vec (w__6.(ProcState_Z))
                ((concat_vec (w__7.(ProcState_C))
                    ((concat_vec (w__8.(ProcState_V))
                        ((concat_vec ((('b"0000000000000000000")  : mword 19))
                            ((concat_vec (w__9.(ProcState_D))
                                ((concat_vec (w__10.(ProcState_A))
                                    ((concat_vec (w__11.(ProcState_I))
                                        ((concat_vec (w__12.(ProcState_F))
                                            ((concat_vec ((('b"00")  : mword 2))
                                                ((concat_vec (w__13.(ProcState_EL))
                                                    ((concat_vec ((('b"0")  : mword 1))
                                                        (w__14.(ProcState_SP))))))))))))))))))))))))))
        (64)) >>
   read_reg PSTATE >>= fun (w__15 : ProcState) =>
   write_reg
     PSTATE
     (w__15
     <|ProcState_EL := ('b"01")  : mword 2|>
     <|ProcState_SP := ('b"1")  : mword 1|>
     <|ProcState_D := ('b"1")  : mword 1|>
     <|ProcState_A := ('b"1")  : mword 1|>
     <|ProcState_I := ('b"1")  : mword 1|>
     <|ProcState_F := ('b"1")  : mword 1|>)
    : M (unit).

Definition execute_Sub (sf : bitU) (d : Z) (n : Z) (op : operand) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun op1 =>
      match op with
      | OperandReg m => (rX (m))  : M (mword 64)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (64)))
      end >>= fun (op2 : bits 64) =>
      (wX (d) ((add_vec (op1) ((add_vec_int ((not_vec (op2))) (1))))))
       : M (unit)
    else
      (rW (n)) >>= fun op1 =>
      match op with
      | OperandReg m => (rW (m))  : M (mword 32)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (32)))
      end >>= fun (op2 : bits 32) =>
      (wW (d) ((add_vec (op1) ((add_vec_int ((not_vec (op2))) (1))))))
       : M (unit))
    : M (unit).

Definition execute_StoreRelease (sf : bitU) (t : Z) (n : Z) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   (rX (n)) >>= fun (addr : bits 64) => (execute_store_release (sf) (t) (addr))  : M (unit).

Definition execute_Store (sf : bitU) (t : Z) (n : Z) (op : operand) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   match op with
   | OperandReg m =>
      (rX (n)) >>= fun (w__0 : mword 64) =>
      (rX (m)) >>= fun (w__1 : mword 64) => returnM ((add_vec (w__0) (w__1)))
   | OperandImm imm12 =>
      (if eq_bit (sf) (B1) return M (mword 64) then
         (rX (n)) >>= fun (w__2 : mword 64) =>
         returnM ((add_vec (w__2)
                     ((zero_extend ((concat_vec (imm12) ((('b"000")  : mword 3)))) (64)))))
       else
         (rX (n)) >>= fun (w__3 : mword 64) =>
         returnM ((add_vec (w__3)
                     ((zero_extend ((concat_vec (imm12) ((('b"00")  : mword 2)))) (64))))))
       : M (mword 64)
   end >>= fun (addr : bits 64) =>
   (execute_store (sf) (t) (addr))
    : M (unit).

Definition execute_Nop '(tt : unit) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4))
    : M (unit).

Definition execute_Move (sf : bitU) (d : Z) (op : move_operand) (*(0 <=? d) && (d <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      match op with
      | MoveReg m => (rX (m))  : M (mword 64)
      | MoveImm data =>
         let b__2 := data.(move_imm_data_hw) in
         returnM ((if eq_vec (b__2) ((('b"00")  : mword 2)) then
                     zero_extend (data.(move_imm_data_imm)) (64)
                   else if eq_vec (b__2) ((('b"01")  : mword 2)) then
                     concat_vec ((zero_extend (data.(move_imm_data_imm)) (48)))
                       (((Ox"0000")
                        : mword 16))
                   else if eq_vec (b__2) ((('b"10")  : mword 2)) then
                     concat_vec ((zero_extend (data.(move_imm_data_imm)) (32)))
                       (((Ox"00000000")
                        : mword 32))
                   else concat_vec (data.(move_imm_data_imm)) (((Ox"000000000000")  : mword 48))))
      end >>= fun (res : bits 64) =>
      (wX (d) (res))
       : M (unit)
    else
      match op with
      | MoveReg m => (rW (m))  : M (mword 32)
      | MoveImm data =>
         let b__0 := data.(move_imm_data_hw) in
         returnM ((if eq_vec (b__0) ((('b"00")  : mword 2)) then
                     zero_extend (data.(move_imm_data_imm)) (32)
                   else if eq_vec (b__0) ((('b"01")  : mword 2)) then
                     concat_vec (data.(move_imm_data_imm)) (((Ox"0000")  : mword 16))
                   else zeros (32)))
      end >>= fun (res : bits 32) =>
      (wW (d) (res))
       : M (unit))
    : M (unit).

Definition execute_LogicalShiftRight (sf : bitU) (d : Z) (n : Z) (op : operand)
(*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun operand =>
      match op with
      | OperandReg m =>
         (rX (m)) >>= fun (w__1 : mword 64) => returnM ((uint ((subrange_vec_dec (w__1) (5) (0)))))
      | OperandImm imm => returnM ((uint ((subrange_vec_dec (imm) (5) (0)))))
      end >>= fun (shift_amount : Z) =>
      (wX (d) ((shiftr (operand) (shift_amount))))
       : M (unit)
    else
      (rW (n)) >>= fun operand =>
      match op with
      | OperandReg m =>
         (rW (m)) >>= fun (w__2 : mword 32) => returnM ((uint ((subrange_vec_dec (w__2) (4) (0)))))
      | OperandImm imm => returnM ((uint ((subrange_vec_dec (imm) (4) (0)))))
      end >>= fun (shift_amount : Z) =>
      (wW (d) ((shiftr (operand) (shift_amount))))
       : M (unit))
    : M (unit).

Definition execute_LoadAcquire (sf : bitU) (t : Z) (n : Z) (ordering : MemoryOrdering)
(*(0 <=? t) && (t <=? 31)*) (*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   (rX (n)) >>= fun (addr : bits 64) =>
   (execute_load_acquire (sf) (t) (addr) (ordering))
    : M (unit).

Definition execute_Load (sf : bitU) (t : Z) (n : Z) (op : operand) (*(0 <=? t) && (t <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   match op with
   | OperandReg m =>
      (rX (n)) >>= fun (w__0 : mword 64) =>
      (rX (m)) >>= fun (w__1 : mword 64) => returnM ((add_vec (w__0) (w__1)))
   | OperandImm imm12 =>
      (if eq_bit (sf) (B1) return M (mword 64) then
         (rX (n)) >>= fun (w__2 : mword 64) =>
         returnM ((add_vec (w__2)
                     ((zero_extend ((concat_vec (imm12) ((('b"000")  : mword 3)))) (64)))))
       else
         (rX (n)) >>= fun (w__3 : mword 64) =>
         returnM ((add_vec (w__3)
                     ((zero_extend ((concat_vec (imm12) ((('b"00")  : mword 2)))) (64))))))
       : M (mword 64)
   end >>= fun (addr : bits 64) =>
   (execute_load (sf) (t) (addr))
    : M (unit).

Definition execute_InstructionSynchronizationBarrier '(tt : unit) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >> (instructionSynchronizationBarrier (tt))  : M (unit).

Definition execute_InclusiveOr (sf : bitU) (d : Z) (n : Z) (m : Z) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun operand1 =>
      (rX (m)) >>= fun operand2 => (wX (d) ((or_vec (operand1) (operand2))))  : M (unit)
    else
      (rW (n)) >>= fun operand1 =>
      (rW (m)) >>= fun operand2 => (wW (d) ((or_vec (operand1) (operand2))))  : M (unit))
    : M (unit).

Definition execute_ExclusiveOr (sf : bitU) (d : Z) (n : Z) (m : Z) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun operand1 =>
      (rX (m)) >>= fun operand2 => (wX (d) ((xor_vec (operand1) (operand2))))  : M (unit)
    else
      (rW (n)) >>= fun operand1 =>
      (rW (m)) >>= fun operand2 => (wW (d) ((xor_vec (operand1) (operand2))))  : M (unit))
    : M (unit).

Definition execute_ExceptionReturn '(tt : unit) : M (unit) :=
   ((read_reg ELR_EL1)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC w__0 >>
   ((read_reg SPSR_EL1)  : M (mword 64)) >>= fun spsr =>
   read_reg PSTATE >>= fun (w__1 : ProcState) =>
   let new_pstate :=
     w__1
     <|ProcState_N := subrange_vec_dec (spsr) (31) (31)|>
     <|ProcState_Z := subrange_vec_dec (spsr) (30) (30)|>
     <|ProcState_C := subrange_vec_dec (spsr) (29) (29)|>
     <|ProcState_V := subrange_vec_dec (spsr) (28) (28)|>
     <|ProcState_D := subrange_vec_dec (spsr) (9) (9)|>
     <|ProcState_A := subrange_vec_dec (spsr) (8) (8)|>
     <|ProcState_I := subrange_vec_dec (spsr) (7) (7)|>
     <|ProcState_F := subrange_vec_dec (spsr) (6) (6)|>
     <|ProcState_EL := subrange_vec_dec (spsr) (3) (2)|>
     <|ProcState_SP := subrange_vec_dec (spsr) (0) (0)|> in
   write_reg PSTATE new_pstate
    : M (unit).

Definition execute_DataSynchronizationBarrier (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (dataSynchronizationBarrer (domain) (types))
    : M (unit).

Definition execute_DataMemoryBarrier (domain : MBReqDomain) (types : MBReqTypes) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >> (dataMemoryBarrier (domain) (types))  : M (unit).

Definition execute_ConditionalSelect (sf : bitU) (d : Z) (n : Z) (m : Z) (cond : mword 4)
(*(0 <=? d) && (d <=? 31)*) (*(0 <=? n) && (n <=? 31)*) (*(0 <=? m) && (m <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (condition_holds (cond)) >>= fun cond_holds =>
   (if eq_bit (sf) (B1) return M (unit) then
      (if cond_holds return M (mword 64) then (rX (n))  : M (mword 64)
       else (rX (m))  : M (mword 64)) >>= fun (w__3 : mword 64) =>
      (wX (d) (w__3))
       : M (unit)
    else
      (if cond_holds return M (mword 32) then (rW (n))  : M (mword 32)
       else (rW (m))  : M (mword 32)) >>= fun (w__6 : mword 32) =>
      (wW (d) (w__6))
       : M (unit))
    : M (unit).

Definition execute_CompareAndBranch (sf : bitU) (t : Z) (offset : mword 64) (iszero : bool)
(*(0 <=? t) && (t <=? 31)*)
: M (unit) :=
   (if eq_bit (sf) (B1) return M (mword 64) then (rX (t))  : M (mword 64)
    else (rW (t)) >>= fun (w__1 : mword 32) => returnM ((zero_extend (w__1) (64)))) >>= fun (operand : bits 64) =>
   let condition_met :=
     if iszero then eq_vec (operand) (((Ox"0000000000000000")  : mword 64))
     else neq_vec (operand) (((Ox"0000000000000000")  : mword 64)) in
   (if condition_met return M (unit) then
      (rPC (tt)) >>= fun base =>
      let addr := add_vec (base) (offset) in
      (wPC (addr))
       : M (unit)
    else
      ((read_reg _PC)  : M (mword 64)) >>= fun (w__2 : mword 64) =>
      write_reg _PC (add_vec_int (w__2) (4))
       : M (unit))
    : M (unit).

Definition execute_Compare (sf : bitU) (n : Z) (op : operand) (*(0 <=? n) && (n <=? 31)*) : M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun (op1 : bits 64) =>
      match op with
      | OperandReg m => (rX (m))  : M (mword 64)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (64)))
      end >>= fun (op2 : bits 64) =>
      let result' : bits 65 :=
        add_vec_int ((add_vec ((zero_extend (op1) (65))) ((zero_extend ((not_vec (op2))) (65)))))
          (1) in
      let result64 : bits 64 := subrange_vec_dec (result') (63) (0) in
      let sign1 := subrange_vec_dec (op1) (63) (63) in
      let sign2 := subrange_vec_dec (op2) (63) (63) in
      let signr := subrange_vec_dec (result64) (63) (63) in
      let overflow : bool := andb ((neq_vec (sign1) (sign2))) ((neq_vec (sign1) (signr))) in
      read_reg PSTATE >>= fun (w__2 : ProcState) =>
      write_reg
        PSTATE
        (w__2
        <|ProcState_N := signr|>
        <|ProcState_Z :=
          if eq_vec (result64) (((Ox"0000000000000000")  : mword 64)) then ('b"1")  : mword 1
          else ('b"0")  : mword 1|>
        <|ProcState_C := subrange_vec_dec (result') (64) (64)|>
        <|ProcState_V := if overflow then ('b"1")  : mword 1 else ('b"0")  : mword 1|>)
       : M (unit)
    else
      (rW (n)) >>= fun (op1 : bits 32) =>
      match op with
      | OperandReg m => (rW (m))  : M (mword 32)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (32)))
      end >>= fun (op2 : bits 32) =>
      let result' : bits 33 :=
        add_vec_int ((add_vec ((zero_extend (op1) (33))) ((zero_extend ((not_vec (op2))) (33)))))
          (1) in
      let result32 : bits 32 := subrange_vec_dec (result') (31) (0) in
      let sign1 := subrange_vec_dec (op1) (31) (31) in
      let sign2 := subrange_vec_dec (op2) (31) (31) in
      let signr := subrange_vec_dec (result32) (31) (31) in
      let overflow : bool := andb ((neq_vec (sign1) (sign2))) ((neq_vec (sign1) (signr))) in
      read_reg PSTATE >>= fun (w__4 : ProcState) =>
      write_reg
        PSTATE
        (w__4
        <|ProcState_N := signr|>
        <|ProcState_Z :=
          if eq_vec (result32) (((Ox"00000000")  : mword 32)) then ('b"1")  : mword 1
          else ('b"0")  : mword 1|>
        <|ProcState_C := subrange_vec_dec (result') (32) (32)|>
        <|ProcState_V := if overflow then ('b"1")  : mword 1 else ('b"0")  : mword 1|>)
       : M (unit))
    : M (unit).

Definition execute_Branch (offset : mword 64) : M (unit) :=
   (rPC (tt)) >>= fun base =>
   let target := add_vec (base) (offset) in
   (wPC (target))
    : M (unit).

Definition execute_BitwiseAnd (sf : bitU) (d : Z) (n : Z) (op : operand) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun operand1 =>
      match op with
      | OperandReg m => (rX (m))  : M (mword 64)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (64)))
      end >>= fun (operand2 : bits 64) =>
      (wX (d) ((and_vec (operand1) (operand2))))
       : M (unit)
    else
      (rW (n)) >>= fun operand1 =>
      match op with
      | OperandReg m => (rW (m))  : M (mword 32)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (32)))
      end >>= fun (operand2 : bits 32) =>
      (wW (d) ((and_vec (operand1) (operand2))))
       : M (unit))
    : M (unit).

Definition execute_Add (sf : bitU) (d : Z) (n : Z) (op : operand) (*(0 <=? d) && (d <=? 31)*)
(*(0 <=? n) && (n <=? 31)*)
: M (unit) :=
   ((read_reg _PC)  : M (mword 64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC (add_vec_int (w__0) (4)) >>
   (if eq_bit (sf) (B1) return M (unit) then
      (rX (n)) >>= fun op1 =>
      match op with
      | OperandReg m => (rX (m))  : M (mword 64)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (64)))
      end >>= fun (op2 : bits 64) =>
      (wX (d) ((add_vec (op1) (op2))))
       : M (unit)
    else
      (rW (n)) >>= fun op1 =>
      match op with
      | OperandReg m => (rW (m))  : M (mword 32)
      | OperandImm imm12 => returnM ((zero_extend (imm12) (32)))
      end >>= fun (op2 : bits 32) =>
      (wW (d) ((add_vec (op1) (op2))))
       : M (unit))
    : M (unit).

Definition execute (merge_var : ast) : M (unit) :=
   match merge_var with
   | Load (sf, t, n, op) => (execute_Load (sf) (t) (n) (op))  : M (unit)
   | Store (sf, t, n, op) => (execute_Store (sf) (t) (n) (op))  : M (unit)
   | LoadAcquire (sf, t, n, ordering) => (execute_LoadAcquire (sf) (t) (n) (ordering))  : M (unit)
   | StoreRelease (sf, t, n) => (execute_StoreRelease (sf) (t) (n))  : M (unit)
   | BitwiseAnd (sf, d, n, op) => (execute_BitwiseAnd (sf) (d) (n) (op))  : M (unit)
   | ExclusiveOr (sf, d, n, m) => (execute_ExclusiveOr (sf) (d) (n) (m))  : M (unit)
   | InclusiveOr (sf, d, n, m) => (execute_InclusiveOr (sf) (d) (n) (m))  : M (unit)
   | Move (sf, d, op) => (execute_Move (sf) (d) (op))  : M (unit)
   | Add (sf, d, n, op) => (execute_Add (sf) (d) (n) (op))  : M (unit)
   | Sub (sf, d, n, op) => (execute_Sub (sf) (d) (n) (op))  : M (unit)
   | DataMemoryBarrier (domain, types) => (execute_DataMemoryBarrier (domain) (types))  : M (unit)
   | DataSynchronizationBarrier (domain, types) =>
      (execute_DataSynchronizationBarrier (domain) (types))  : M (unit)
   | InstructionSynchronizationBarrier arg0 =>
      (execute_InstructionSynchronizationBarrier (arg0))  : M (unit)
   | Nop arg0 => (execute_Nop (arg0))  : M (unit)
   | CompareAndBranch (sf, t, offset, iszero) =>
      (execute_CompareAndBranch (sf) (t) (offset) (iszero))  : M (unit)
   | LogicalShiftRight (sf, d, n, op) => (execute_LogicalShiftRight (sf) (d) (n) (op))  : M (unit)
   | Branch offset => (execute_Branch (offset))  : M (unit)
   | TLBInvalidation (op, t) => (execute_TLBInvalidation (op) (t))  : M (unit)
   | SupervisorCall imm16 => (execute_SupervisorCall (imm16))  : M (unit)
   | ExceptionReturn arg0 => (execute_ExceptionReturn (arg0))  : M (unit)
   | Compare (sf, n, op) => (execute_Compare (sf) (n) (op))  : M (unit)
   | ConditionalSelect (sf, d, n, m, cond) =>
      (execute_ConditionalSelect (sf) (d) (n) (m) (cond))  : M (unit)
   | SystemRegisterMove (is_read, op1, CRn, CRm, op2, t) =>
      (execute_SystemRegisterMove (is_read) (op1) (CRn) (CRm) (op2) (t))  : M (unit)
   end
    : M (unit).

Definition decode (v__0 : mword 32) : option ast :=
   if andb ((eq_vec ((subrange_vec_dec (v__0) (29) (24))) ((('b"111000")  : mword 6))))
        ((andb ((eq_vec ((subrange_vec_dec (v__0) (21) (21))) ((('b"1")  : mword 1))))
            ((eq_vec ((subrange_vec_dec (v__0) (11) (10))) ((('b"10")  : mword 2)))))) then
     let S' := access_vec_dec (v__0) (12) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let option_v : bits 3 := subrange_vec_dec (v__0) (15) (13) in
     let opc : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     decodeLoadStoreRegister (size) (opc) (Rm) (option_v) (S') (Rn) (Rt)
   else if eq_vec ((subrange_vec_dec (v__0) (29) (24))) ((('b"111001")  : mword 6)) then
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let opc : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm12 : bits 12 := subrange_vec_dec (v__0) (21) (10) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     decodeLoadStoreImmediate (size) (opc) (imm12) (Rn) (Rt)
   else if eq_vec ((subrange_vec_dec (v__0) (29) (10))) (((Ox"237DF")  : mword 20)) then
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let t : reg_index := uint (Rt) in
     let n : reg_index := uint (Rn) in
     let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
     if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
     then
       None
     else Some ((LoadAcquire ((sf, t, n, Ordering_Acquire))))
   else if eq_vec ((subrange_vec_dec (v__0) (29) (10))) (((Ox"22FF0")  : mword 20)) then
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let t : reg_index := uint (Rt) in
     let n : reg_index := uint (Rn) in
     let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
     if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
     then
       None
     else Some ((LoadAcquire ((sf, t, n, Ordering_AcquireRCpc))))
   else if eq_vec ((subrange_vec_dec (v__0) (29) (10))) (((Ox"227FF")  : mword 20)) then
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let size : bits 2 := subrange_vec_dec (v__0) (31) (30) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let t : reg_index := uint (Rt) in
     let n : reg_index := uint (Rn) in
     let sf : datasize := if eq_vec (size) ((('b"11")  : mword 2)) then B1 else B0 in
     if andb ((neq_vec (size) ((('b"11")  : mword 2)))) ((neq_vec (size) ((('b"10")  : mword 2))))
     then
       None
     else Some ((StoreRelease ((sf, t, n))))
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0001010")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (21) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeBitwiseAndRegister (sf) (shift) (N) (Rm) (imm6) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (23))) (((Ox"24")  : mword 8)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (22) in
     let imms : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let immr : bits 6 := subrange_vec_dec (v__0) (21) (16) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeBitwiseAndImmediate (sf) (N) (immr) (imms) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1001010")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (21) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeExclusiveOr (sf) (shift) (N) (Rm) (imm6) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0101010")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (21) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeInclusiveOr (sf) (shift) (N) (Rm) (imm6) (Rn) (Rd)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (21))) ((('b"0101010000")  : mword 10))))
             ((eq_vec ((subrange_vec_dec (v__0) (15) (5))) ((('b"00000011111")  : mword 11)))) then
     let sf := access_vec_dec (v__0) (31) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     let m : reg_index := uint (Rm) in
     Some ((Move ((sf, d, MoveReg (m)))))
   else if eq_vec ((subrange_vec_dec (v__0) (30) (23))) (((Ox"A5")  : mword 8)) then
     let sf := access_vec_dec (v__0) (31) in
     let imm16 : bits 16 := subrange_vec_dec (v__0) (20) (5) in
     let hw : bits 2 := subrange_vec_dec (v__0) (22) (21) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     if andb ((eq_bit (sf) (B0))) ((eq_bit ((access_vec_dec (hw) (1))) (B1))) then None
     else
       Some
         ((Move ((sf, d, MoveImm (({| move_imm_data_imm := imm16;  move_imm_data_hw := hw |}))))))
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0001011")  : mword 7))))
             ((eq_vec ((subrange_vec_dec (v__0) (21) (21))) ((('b"0")  : mword 1)))) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeAddSub (sf) (B0) (B0) (shift) (((Ox"000")  : mword 12)) (imm6) (Rm) (Rn) (Rd)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1001011")  : mword 7))))
             ((eq_vec ((subrange_vec_dec (v__0) (21) (21))) ((('b"0")  : mword 1)))) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeAddSub (sf) (B1) (B0) (shift) (((Ox"000")  : mword 12)) (imm6) (Rm) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0010001")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm12 : bits 12 := subrange_vec_dec (v__0) (21) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeAddSub (sf) (B0) (B1) (shift) (imm12) ((('b"000000")  : mword 6))
       ((('b"00000")
        : mword 5)) (Rn) (Rd)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1010001")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm12 : bits 12 := subrange_vec_dec (v__0) (21) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeAddSub (sf) (B1) (B1) (shift) (imm12) ((('b"000000")  : mword 6))
       ((('b"00000")
        : mword 5)) (Rn) (Rd)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1101011")  : mword 7))))
             ((andb ((eq_vec ((subrange_vec_dec (v__0) (21) (21))) ((('b"0")  : mword 1))))
                 ((eq_vec ((subrange_vec_dec (v__0) (4) (0))) ((('b"11111")  : mword 5)))))) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm6 : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     decodeCompare (sf) (shift) (((Ox"000")  : mword 12)) (imm6) (Rm) (Rn)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"1110001")  : mword 7))))
             ((eq_vec ((subrange_vec_dec (v__0) (4) (0))) ((('b"11111")  : mword 5)))) then
     let sf := access_vec_dec (v__0) (31) in
     let shift : bits 2 := subrange_vec_dec (v__0) (23) (22) in
     let imm12 : bits 12 := subrange_vec_dec (v__0) (21) (10) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     decodeCompare (sf) (shift) (imm12) ((('b"000000")  : mword 6)) ((('b"00000")  : mword 5)) (Rn)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (21))) ((('b"0011010100")  : mword 10))))
             ((eq_vec ((subrange_vec_dec (v__0) (11) (10))) ((('b"00")  : mword 2)))) then
     let sf := access_vec_dec (v__0) (31) in
     let cond : bits 4 := subrange_vec_dec (v__0) (15) (12) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     let n : reg_index := uint (Rn) in
     let m : reg_index := uint (Rm) in
     Some ((ConditionalSelect ((sf, d, n, m, cond))))
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (12))) (((Ox"D5033")  : mword 20))))
             ((eq_vec ((subrange_vec_dec (v__0) (7) (0))) (((Ox"BF")  : mword 8)))) then
     let CRm : bits 4 := subrange_vec_dec (v__0) (11) (8) in
     decodeDataBarrier (CRm) (false)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (12))) (((Ox"D5033")  : mword 20))))
             ((eq_vec ((subrange_vec_dec (v__0) (7) (0))) (((Ox"9F")  : mword 8)))) then
     let CRm : bits 4 := subrange_vec_dec (v__0) (11) (8) in
     decodeDataBarrier (CRm) (true)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (12))) (((Ox"D5033")  : mword 20))))
             ((eq_vec ((subrange_vec_dec (v__0) (7) (0))) (((Ox"DF")  : mword 8)))) then
     Some ((InstructionSynchronizationBarrier (tt)))
   else if eq_vec (v__0) (((Ox"D503201F")  : mword 32)) then Some ((Nop (tt)))
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0110100")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let imm19 : bits 19 := subrange_vec_dec (v__0) (23) (5) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeCompareAndBranch (sf) (B0) (imm19) (Rt)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (24))) ((('b"0110101")  : mword 7)) then
     let sf := access_vec_dec (v__0) (31) in
     let imm19 : bits 19 := subrange_vec_dec (v__0) (23) (5) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     decodeCompareAndBranch (sf) (B1) (imm19) (Rt)
   else if eq_vec ((subrange_vec_dec (v__0) (30) (23))) (((Ox"A6")  : mword 8)) then
     let sf := access_vec_dec (v__0) (31) in
     let N := access_vec_dec (v__0) (22) in
     let imms : bits 6 := subrange_vec_dec (v__0) (15) (10) in
     let immr : bits 6 := subrange_vec_dec (v__0) (21) (16) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     let n : reg_index := uint (Rn) in
     let valid_64 :=
       andb ((eq_bit (sf) (B1)))
         ((andb ((eq_bit (N) (B1))) ((eq_vec (imms) ((('b"111111")  : mword 6)))))) in
     let valid_32 :=
       andb ((eq_bit (sf) (B0)))
         ((andb ((eq_bit (N) (B0))) ((eq_vec (imms) ((('b"011111")  : mword 6)))))) in
     if orb (valid_64) (valid_32) then
       Some ((LogicalShiftRight ((sf, d, n, OperandImm ((zero_extend (immr) (12)))))))
     else None
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (30) (21))) ((('b"0011010110")  : mword 10))))
             ((eq_vec ((subrange_vec_dec (v__0) (15) (10))) ((('b"001001")  : mword 6)))) then
     let sf := access_vec_dec (v__0) (31) in
     let Rn : bits 5 := subrange_vec_dec (v__0) (9) (5) in
     let Rm : bits 5 := subrange_vec_dec (v__0) (20) (16) in
     let Rd : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let d : reg_index := uint (Rd) in
     let n : reg_index := uint (Rn) in
     let m : reg_index := uint (Rm) in
     Some ((LogicalShiftRight ((sf, d, n, OperandReg (m)))))
   else if eq_vec ((subrange_vec_dec (v__0) (31) (26))) ((('b"000101")  : mword 6)) then
     let imm26 : bits 26 := subrange_vec_dec (v__0) (25) (0) in
     let offset : bits 64 := sign_extend ((concat_vec (imm26) ((('b"00")  : mword 2)))) (64) in
     Some ((Branch (offset)))
   else if eq_vec ((subrange_vec_dec (v__0) (31) (19))) ((('b"1101010100001")  : mword 13)) then
     let op2 : bits 3 := subrange_vec_dec (v__0) (7) (5) in
     let op1 : bits 3 := subrange_vec_dec (v__0) (18) (16) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let CRn : bits 4 := subrange_vec_dec (v__0) (15) (12) in
     let CRm : bits 4 := subrange_vec_dec (v__0) (11) (8) in
     decodeTLBI (op1) (CRn) (CRm) (op2) (Rt)
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (21))) ((('b"11010100000")  : mword 11))))
             ((eq_vec ((subrange_vec_dec (v__0) (4) (0))) ((('b"00001")  : mword 5)))) then
     let imm16 : bits 16 := subrange_vec_dec (v__0) (20) (5) in
     Some ((SupervisorCall (imm16)))
   else if eq_vec (v__0) (((Ox"D69F03E0")  : mword 32)) then Some ((ExceptionReturn (tt)))
   else if andb ((eq_vec ((subrange_vec_dec (v__0) (31) (22))) ((('b"1101010100")  : mword 10))))
             ((eq_vec ((subrange_vec_dec (v__0) (20) (19))) ((('b"11")  : mword 2)))) then
     let L := access_vec_dec (v__0) (21) in
     let op2 : bits 3 := subrange_vec_dec (v__0) (7) (5) in
     let op1 : bits 3 := subrange_vec_dec (v__0) (18) (16) in
     let Rt : bits 5 := subrange_vec_dec (v__0) (4) (0) in
     let CRn : bits 4 := subrange_vec_dec (v__0) (15) (12) in
     let CRm : bits 4 := subrange_vec_dec (v__0) (11) (8) in
     decodeSystemRegisterMove ((eq_bit (L) (B1))) (op1) (CRn) (CRm) (op2) (Rt)
   else None.

Definition fetch_and_execute '(tt : unit) : M (unit) :=
   catch_early_return
     (liftR ((create_iFetchAccessDescriptor (tt))) >>= fun accdesc =>
     ((liftR (read_reg _PC))  : MR (unit) (mword 64)) >>= fun (w__0 : mword 64) =>
     liftR ((translate_address (w__0) (accdesc))) >>= fun (w__1 : option (mword 56)) =>
     match w__1 with
     | Some addr => returnR (unit) (addr)
     | None => (early_return (tt  : unit) : MR unit (mword 56))  : MR (unit) (mword 56)
     end >>= fun (addr : bits addr_size) =>
     liftR ((iFetch (addr) (accdesc))) >>= fun machineCode =>
     let instr := decode (machineCode) in
     match instr with
     | Some instr => liftR ((execute (instr)))  : MR (unit) (unit)
     | None => liftR (assert_exp' false "Unsupported Encoding") >>= fun _ => liftR (exit tt)
     end
      : MR (unit) (unit)).

Definition initialize_registers '(tt : unit) : M (unit) :=
   (undefined_bitvector (64)) >>= fun (w__0 : mword 64) =>
   write_reg _PC w__0 >>
   (undefined_bitvector (64)) >>= fun (w__1 : mword 64) =>
   write_reg R30 w__1 >>
   (undefined_bitvector (64)) >>= fun (w__2 : mword 64) =>
   write_reg R29 w__2 >>
   (undefined_bitvector (64)) >>= fun (w__3 : mword 64) =>
   write_reg R28 w__3 >>
   (undefined_bitvector (64)) >>= fun (w__4 : mword 64) =>
   write_reg R27 w__4 >>
   (undefined_bitvector (64)) >>= fun (w__5 : mword 64) =>
   write_reg R26 w__5 >>
   (undefined_bitvector (64)) >>= fun (w__6 : mword 64) =>
   write_reg R25 w__6 >>
   (undefined_bitvector (64)) >>= fun (w__7 : mword 64) =>
   write_reg R24 w__7 >>
   (undefined_bitvector (64)) >>= fun (w__8 : mword 64) =>
   write_reg R23 w__8 >>
   (undefined_bitvector (64)) >>= fun (w__9 : mword 64) =>
   write_reg R22 w__9 >>
   (undefined_bitvector (64)) >>= fun (w__10 : mword 64) =>
   write_reg R21 w__10 >>
   (undefined_bitvector (64)) >>= fun (w__11 : mword 64) =>
   write_reg R20 w__11 >>
   (undefined_bitvector (64)) >>= fun (w__12 : mword 64) =>
   write_reg R19 w__12 >>
   (undefined_bitvector (64)) >>= fun (w__13 : mword 64) =>
   write_reg R18 w__13 >>
   (undefined_bitvector (64)) >>= fun (w__14 : mword 64) =>
   write_reg R17 w__14 >>
   (undefined_bitvector (64)) >>= fun (w__15 : mword 64) =>
   write_reg R16 w__15 >>
   (undefined_bitvector (64)) >>= fun (w__16 : mword 64) =>
   write_reg R15 w__16 >>
   (undefined_bitvector (64)) >>= fun (w__17 : mword 64) =>
   write_reg R14 w__17 >>
   (undefined_bitvector (64)) >>= fun (w__18 : mword 64) =>
   write_reg R13 w__18 >>
   (undefined_bitvector (64)) >>= fun (w__19 : mword 64) =>
   write_reg R12 w__19 >>
   (undefined_bitvector (64)) >>= fun (w__20 : mword 64) =>
   write_reg R11 w__20 >>
   (undefined_bitvector (64)) >>= fun (w__21 : mword 64) =>
   write_reg R10 w__21 >>
   (undefined_bitvector (64)) >>= fun (w__22 : mword 64) =>
   write_reg R9 w__22 >>
   (undefined_bitvector (64)) >>= fun (w__23 : mword 64) =>
   write_reg R8 w__23 >>
   (undefined_bitvector (64)) >>= fun (w__24 : mword 64) =>
   write_reg R7 w__24 >>
   (undefined_bitvector (64)) >>= fun (w__25 : mword 64) =>
   write_reg R6 w__25 >>
   (undefined_bitvector (64)) >>= fun (w__26 : mword 64) =>
   write_reg R5 w__26 >>
   (undefined_bitvector (64)) >>= fun (w__27 : mword 64) =>
   write_reg R4 w__27 >>
   (undefined_bitvector (64)) >>= fun (w__28 : mword 64) =>
   write_reg R3 w__28 >>
   (undefined_bitvector (64)) >>= fun (w__29 : mword 64) =>
   write_reg R2 w__29 >>
   (undefined_bitvector (64)) >>= fun (w__30 : mword 64) =>
   write_reg R1 w__30 >>
   (undefined_bitvector (64)) >>= fun (w__31 : mword 64) =>
   write_reg R0 w__31 >>
   (undefined_bitvector (64)) >>= fun (w__32 : mword 64) =>
   write_reg SP_EL0 w__32 >>
   (undefined_bitvector (64)) >>= fun (w__33 : mword 64) =>
   write_reg SP_EL1 w__33 >>
   (undefined_bitvector (64)) >>= fun (w__34 : mword 64) =>
   write_reg SP_EL2 w__34 >>
   (undefined_bitvector (64)) >>= fun (w__35 : mword 64) =>
   write_reg SP_EL3 w__35 >>
   (undefined_bitvector (64)) >>= fun (w__36 : mword 64) =>
   write_reg ELR_EL1 w__36 >>
   (undefined_bitvector (64)) >>= fun (w__37 : mword 64) =>
   write_reg ELR_EL2 w__37 >>
   (undefined_bitvector (64)) >>= fun (w__38 : mword 64) =>
   write_reg ELR_EL3 w__38 >>
   (undefined_ProcState (tt)) >>= fun (w__39 : ProcState) =>
   write_reg PSTATE w__39 >>
   (undefined_bitvector (64)) >>= fun (w__40 : mword 64) =>
   write_reg ESR_EL1 w__40 >>
   (undefined_bitvector (64)) >>= fun (w__41 : mword 64) =>
   write_reg ESR_EL2 w__41 >>
   (undefined_bitvector (64)) >>= fun (w__42 : mword 64) =>
   write_reg ESR_EL3 w__42 >>
   (undefined_bitvector (64)) >>= fun (w__43 : mword 64) =>
   write_reg FAR_EL1 w__43 >>
   (undefined_bitvector (64)) >>= fun (w__44 : mword 64) =>
   write_reg FAR_EL2 w__44 >>
   (undefined_bitvector (64)) >>= fun (w__45 : mword 64) =>
   write_reg FAR_EL3 w__45 >>
   (undefined_bitvector (64)) >>= fun (w__46 : mword 64) =>
   write_reg PAR_EL1 w__46 >>
   (undefined_bitvector (64)) >>= fun (w__47 : mword 64) =>
   write_reg TTBR0_EL1 w__47 >>
   (undefined_bitvector (64)) >>= fun (w__48 : mword 64) =>
   write_reg TTBR1_EL1 w__48 >>
   (undefined_bitvector (64)) >>= fun (w__49 : mword 64) =>
   write_reg TTBR0_EL2 w__49 >>
   (undefined_bitvector (64)) >>= fun (w__50 : mword 64) =>
   write_reg TTBR1_EL2 w__50 >>
   (undefined_bitvector (64)) >>= fun (w__51 : mword 64) =>
   write_reg TTBR0_EL3 w__51 >>
   (undefined_bitvector (64)) >>= fun (w__52 : mword 64) =>
   write_reg VTTBR_EL2 w__52 >>
   (undefined_bitvector (64)) >>= fun (w__53 : mword 64) =>
   write_reg VBAR_EL1 w__53 >>
   (undefined_bitvector (64)) >>= fun (w__54 : mword 64) =>
   write_reg VBAR_EL2 w__54 >>
   (undefined_bitvector (64)) >>= fun (w__55 : mword 64) =>
   write_reg VBAR_EL3 w__55 >>
   (undefined_bitvector (64)) >>= fun (w__56 : mword 64) =>
   write_reg SPSR_EL1 w__56 >>
   (undefined_bitvector (64)) >>= fun (w__57 : mword 64) =>
   write_reg SPSR_EL2 w__57 >>
   (undefined_bitvector (64)) >>= fun (w__58 : mword 64) =>
   write_reg SPSR_EL3 w__58 >>
   (undefined_bitvector (64)) >>= fun (w__59 : mword 64) =>
   write_reg ID_AA64MMFR0_EL1 w__59 >>
   (undefined_bitvector (64)) >>= fun (w__60 : mword 64) =>
   write_reg ID_AA64MMFR1_EL1 w__60 >>
   (undefined_bitvector (64)) >>= fun (w__61 : mword 64) =>
   write_reg ID_AA64MMFR2_EL1 w__61 >>
   (undefined_bitvector (64)) >>= fun (w__62 : mword 64) =>
   write_reg ID_AA64MMFR3_EL1 w__62 >>
   (undefined_bitvector (64)) >>= fun (w__63 : mword 64) =>
   write_reg ID_AA64MMFR4_EL1 w__63 >>
   (undefined_bitvector (64)) >>= fun (w__64 : mword 64) =>
   write_reg TCR_EL1 w__64 >>
   (undefined_bitvector (64)) >>= fun (w__65 : mword 64) =>
   write_reg TCR_EL2 w__65 >>
   (undefined_bitvector (64)) >>= fun (w__66 : mword 64) =>
   write_reg TCR_EL3 w__66 >>
   (undefined_bitvector (64)) >>= fun (w__67 : mword 64) =>
   write_reg VTCR_EL2 w__67 >>
   (undefined_bitvector (64)) >>= fun (w__68 : mword 64) =>
   write_reg SCTLR_EL1 w__68 >>
   (undefined_bitvector (64)) >>= fun (w__69 : mword 64) =>
   write_reg SCTLR_EL2 w__69 >>
   (undefined_bitvector (64)) >>= fun (w__70 : mword 64) => write_reg SCTLR_EL3 w__70  : M (unit).

Definition sail_model_init (_ : unit) : M (unit) := (initialize_registers (tt))  : M (unit).



